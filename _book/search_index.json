[["pop-DST.html", "Chapter 4 Population density", " Chapter 4 Population density Population data at municipality level for the same period we have BBR data (2004-2019) have been retrieved from Statistics Denmark. We have used the R-package danstat and the table FT: Population figures from the censuses. id_table &lt;- &quot;FT&quot; dat_meta &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Variables variables &lt;- list( # Municipalities list(code = &quot;HOVEDDELE&quot;, values = c(&quot;101&quot;,&quot;147&quot;)), # Population at the first day of the year (from 2004 to 2019) list(code = &quot;Tid&quot;, values = seq(2004, 2019, 1)) ) # Get data pop_tot_muni &lt;- get_data(&quot;FT&quot;, variables) %&gt;% # Translate names into English rename(muni_name = HOVEDDELE, date = TID, pop_total = INDHOLD) # Add spatial information pop_tot_muni_sf &lt;- cph_commune %&gt;% left_join(pop_tot_muni, by = &quot;muni_name&quot;) We disaggregate the population data to grid cells of 100m x 100m using residential buildings as ancillary data. The procedure is as follow: Calculate the occupancy rate (OR) for the residential units of each municipality (j): \\[OR_{j} = \\frac{pop_{j}}{N_{j}}\\] Make grid cells of 100m x 100m over the study area, and select only the grids with residential units Detect to what municipality (j) belong each grid (i) (Note that one grids may be in more that one municipality) Calculate the number of dwellings per grid and municipality (\\(N_{ij}\\)) Estimate the population in each grid (i) base the occupancy rate by parish (j): \\[pop_{gi} = \\sum_{j = 1}^{n}(OR_{j} \\cdot N_{ij})\\] Population density: \\[PD_{i} = \\frac{pop_{i}}{A_{i}}\\] We can therefore estimate the population density at the first day of the year by grid cells of 100m x 100m (figure 4.1). #&#39; Aux. function for calculate the population density in the grids created by f_grids #&#39; @param .year Year of the analysis (e.g. 2019) f_pd_grids &lt;- function(.year) { # Population at the first day of the year (.year) in each municipality pop_year &lt;- pop_tot_muni_sf %&gt;% # select the data at the first day of the year filter(date == .year) # BBR of the selected year (represent the first day of the year) BBR_year &lt;- res_units %&gt;% filter(BBR_year == .year) %&gt;% select(geometry) # Calculate occupancy rate (&quot;OR&quot;) of the residential units in each municipality in a year OR &lt;- pop_year %&gt;% # number of units per parish mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # mean population per unit in each parish mutate(across(starts_with(&quot;pop&quot;), ~ . / n_units)) %&gt;% # output as table as_tibble() %&gt;% select(-n_units, -geometry) # Get only the grids with residential units on them gru &lt;- grids100m$data_poly[[1]] %&gt;% # Number of residential units per grid mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # Get grids with residential buildings filter(n_units &gt; 0) %&gt;% # Add date mutate(date = .year) # Detect to what area belong the grid gru_muni &lt;- gru %&gt;% st_intersection(., cph_commune) %&gt;% # Remove parish area select(-muni_area_km2, -muni_name) # Population density by grids pop_grids &lt;- gru_muni %&gt;% # convert to table as_tibble() %&gt;% select(-geometry) %&gt;% # Merge OR per area left_join(OR, by = &quot;muni_id&quot;) %&gt;% # recalculate population by grid mutate(across(starts_with(&quot;pop&quot;), ~ . * n_units)) %&gt;% # sum population of each municipality of the grid group_by(grid_ID) %&gt;% summarise(pop_total = sum(pop_total), n_units = sum(n_units)) %&gt;% ungroup() # Add spatial information gru %&gt;% select(-n_units) %&gt;% left_join(pop_grids, by = &quot;grid_ID&quot;) %&gt;% # Area of the grid mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # Remove polygons with 0 population filter(pop_total_km2 &gt; 0) } # List of years with BBR data (2004-2019) and population data (2008-2019) years_pd &lt;- seq(2004, 2019, 1) # Increase future maximum allowed size of global variables options(future.globals.maxSize = 8000 * 1024^2) # Population density plan(multisession, workers = 7) pop_g100m &lt;- future_map_dfr(.x = years_pd, .f = f_pd_grids) plan(&quot;default&quot;) # Default value options(future.globals.maxSize = 500 * 1024^2) # Add breaks brks &lt;- c(min(pop_g100m$pop_total_km2), 1, 2, 3, 4, 5, 10, 15, 20, 30, ceiling(max(pop_g100m$pop_total_km2))) pop_g100m &lt;- pop_g100m %&gt;% mutate(pop_total_km2_cut = cut(pop_total_km2, breaks = brks, include.lowest = TRUE)) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = pop_total_km2_cut, group = interaction(pop_total_km2_cut, date)), color = NA) + geom_sf(data = cph_commune, fill = NA, color = &quot;grey50&quot;, size = 0.1) + scale_fill_brewer( name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), palette = &quot;RdYlBu&quot;, direction = -1, drop = FALSE) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Population density by grid cells of 100m x 100m&quot;, subtitle = paste(&quot;Date&quot;, df$date, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- pop_g100m %&gt;% group_split(date) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 4.1: Dasymetric map "]]
