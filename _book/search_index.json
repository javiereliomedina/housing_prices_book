[["study-area.html", "Chapter 3 Copenhagen region 3.1 Population density by grid cells of 100m x 100m 3.2 House prices by grid cells of 100m x 100m 3.3 Population density and house prices", " Chapter 3 Copenhagen region We focus the study on Copenhagen (muni_id = 0101) and Frederiksberg (muni_id = 0147) municipalities (Figure 3.1A), and we make the analysis at a scale of grid cells of 100m x 100m (Figure 3.1B). # Communes polygons of Denmark, and select those in the study area dk_country &lt;- st_union(dk_muni) # Codes of the communes under study (KOMKODE) study_area_codes &lt;- c(&quot;0101&quot;, &quot;0147&quot;) # Select municipalities under study cph_muni &lt;- dk_muni %&gt;% filter(muni_id %in% study_area_codes) # Parishes polygons of Denmark, and select those in the study area parish_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_parish &lt;- read_sf(parish_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the study area dk_parish_cent &lt;- st_centroid(dk_parish) cph_parish_cent &lt;- st_intersection(dk_parish_cent, cph_muni) cph_parish &lt;- filter(dk_parish, SOGNEKODE %in% cph_parish_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) # Contour of the study area (merge the parishes in one polygon): study_area &lt;- cph_parish %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Make grid cells of 100m x 100m grids100m &lt;- study_area %&gt;% # Make regular grids (100m x 100m) st_make_grid(cellsize = 100) %&gt;% st_sf() %&gt;% # Select grids only in the study area mutate(int = st_intersects(., study_area) %&gt;% lengths &gt; 0) %&gt;% filter(int == TRUE) %&gt;% select(-int) %&gt;% # Name grids as &quot;g001&quot;, &quot;g002&quot;, ... mutate(grid_ID = paste0(&quot;g&quot;, stringr::str_pad(seq(1, nrow(.), 1), 3, pad = &quot;0&quot;))) # Centroids of the grid cells (for Potential Model) grids100m &lt;- grids100m %&gt;% # Nesting nest(data_poly = everything()) %&gt;% # add centroids of the grids mutate(data_points = map(data_poly, st_centroid)) # Plot parish in the study area p1 &lt;- ggplot() + geom_sf(data = cph_muni, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + my_theme_map() + labs(title = &quot;A) Municipalities&quot;) # Plot grids p2 &lt;- ggplot() + geom_sf(data = cph_muni, fill = NA, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = grids100m$data_poly[[1]], fill = NA, color = &quot;red&quot;, size = 0.05) + my_theme_map() + labs(title = &quot;B) Grid cells of 100m x 100m&quot;) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(1.30, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) # Plot p1 + p2 Figure 3.1: Copenhagen and Frederiksberg municipalities 3.1 Population density by grid cells of 100m x 100m We disaggregate therefore population data at municipality level to the grid cells of 100m x 100m (i.e. 10786 grid cells in the study area) using all residences for year-round living (ENH_ANVEND_KODE) (i.e. from the Building and Dwelling Register - BBR as ancillary data. We also removed from the dataset those dwellings that are not actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig) and dwellings with a size lower than that 10 \\(m^2\\). # Buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 110, &quot;Farmhouse&quot;, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;, 150, &quot;College&quot;, 160, &quot;Residential institution&quot;, 190, &quot;Second building&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Function for reading residential units in the study area from a BBR files (.csv): f_res_units &lt;- function(.file, .muni = study_area_codes) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # Format KomKode and select municipalities of the study area mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% filter.(KomKode %in% .muni) %&gt;% # Remove residential units not used for for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() } # Load residential units (from .csv files) # NOTE: you may need to change the path to your file on &quot;OneDrive - Aalborg Universitet&quot; csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) plan(multisession, workers = 7) res_units_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_res_units) plan(&quot;default&quot;) # Clean dataset res_units &lt;- res_units_read %&gt;% # Input empty cells (buildings with only one floor) in Etagebetegn as &quot;st&quot; mutate.(Etagebetegn = fifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn)) %&gt;% # Etagebetegn as ordered factor mutate.(Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE)) %&gt;% # Group floor levels with 5 or more mutate.(floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join.(res_codes, by = &quot;ENH_ANVEND_KODE&quot;) %&gt;% # Convert columns with codes (*_KODE) to character mutate.(across.(ends_with(&quot;KODE&quot;), ~as.character(.))) # Convert to sf objects res_units_sf &lt;- res_units %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) The population data at municipality level for the same period we have BBR data (2004-2019) have been retrieved from Statistics Denmark. We have used the R-package danstat and the table FT: Population figures from the censuses. id_table &lt;- &quot;FT&quot; dat_meta &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Variables variables &lt;- list( # Municipalities list(code = &quot;HOVEDDELE&quot;, values = c(&quot;101&quot;,&quot;147&quot;)), # Population at the first day of the year (from 2004 to 2019) list(code = &quot;Tid&quot;, values = seq(2004, 2019, 1)) ) # Get data pop_tot_muni &lt;- get_data(&quot;FT&quot;, variables) %&gt;% # Translate names into English rename(muni_name = HOVEDDELE, date = TID, pop_total = INDHOLD) %&gt;% # Translate København mutate(muni_name = gsub(&quot;Copenhagen&quot;, &quot;København&quot;, muni_name)) # Add spatial information pop_tot_muni_sf &lt;- cph_muni %&gt;% left_join(pop_tot_muni, by = &quot;muni_name&quot;) The procedure for disaggregating the population data is therefore as follow: Calculate the occupancy rate (OR) for the residential units of each municipality (j): \\[OR_{j} = \\frac{pop_{j}}{N_{j}}\\] Make grid cells of 100m x 100m over the study area, and select only the grids with residential units Detect to what municipality (j) belong each grid (i) (Note that one grids may be in more that one municipality) Calculate the number of dwellings per grid and municipality (\\(N_{ij}\\)) Estimate the population in each grid (i) base the occupancy rate by parish (j): \\[pop_{gi} = \\sum_{j = 1}^{n}(OR_{j} \\cdot N_{ij})\\] Population density: \\[PD_{i} = \\frac{pop_{i}}{A_{i}}\\] We can therefore estimate the population density at the first day of the year by grid cells of 100m x 100m (figure 3.2). #&#39; Aux. function for calculate the population density in the grids created by f_grids #&#39; @param .year Year of the analysis (e.g. 2019) f_pd_grids &lt;- function(.year) { # Population at the first day of the year (.year) in each municipality pop_year &lt;- pop_tot_muni_sf %&gt;% # select the data at the first day of the year filter(date == .year) # Dwellings (points) of the selected year BBR_year &lt;- res_units_sf %&gt;% filter(year == .year) %&gt;% select(geometry) # Calculate occupancy rate (&quot;OR&quot;) of the residential units in each municipality in a year OR &lt;- pop_year %&gt;% # number of units per municipality mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # mean population per unit in each parish mutate(across(starts_with(&quot;pop&quot;), ~ . / n_units)) %&gt;% # output as table as_tibble() %&gt;% select(-n_units, -geometry) # Get only the grids with residential units on them gru &lt;- grids100m$data_poly[[1]] %&gt;% # Number of residential units per grid mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # Get grids with residential buildings filter(n_units &gt; 0) %&gt;% # Add date mutate(date = .year) # Detect to what area belong the grid gru_muni &lt;- gru %&gt;% st_intersection(., cph_muni) %&gt;% # Remove parish area select(-area_km2, -muni_name) # Population density by grids pop_grids &lt;- gru_muni %&gt;% # convert to table as_tibble() %&gt;% select(-geometry) %&gt;% # Merge OR per area left_join(OR, by = &quot;muni_id&quot;) %&gt;% # recalculate population by grid mutate(across(starts_with(&quot;pop&quot;), ~ . * n_units)) %&gt;% # sum population of each municipality of the grid group_by(grid_ID) %&gt;% summarise(pop_total = sum(pop_total), n_units = sum(n_units)) %&gt;% ungroup() # Add spatial information gru %&gt;% select(-n_units) %&gt;% left_join(pop_grids, by = &quot;grid_ID&quot;) %&gt;% # Area of the grid mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # Remove polygons with 0 population filter(pop_total_km2 &gt; 0) } # List of years with BBR data (2004-2019) and population data (2008-2019) years_pd &lt;- seq(2004, 2019, 1) # Increase future maximum allowed size of global variables options(future.globals.maxSize = 8000 * 1024^2) # Population density plan(multisession, workers = 7) pop_g100m &lt;- future_map_dfr(.x = years_pd, .f = f_pd_grids) plan(&quot;default&quot;) # Default value options(future.globals.maxSize = 500 * 1024^2) # Add breaks brks &lt;- c(min(pop_g100m$pop_total_km2), 1, 2, 3, 4, 5, 10, 15, 20, 30, ceiling(max(pop_g100m$pop_total_km2))) pop_g100m &lt;- pop_g100m %&gt;% mutate(pop_total_km2_cut = cut(pop_total_km2, breaks = brks, include.lowest = TRUE)) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = pop_total_km2), color = NA) + # geom_sf(data = cph_muni, fill = NA, color = &quot;grey50&quot;, size = 0.1) + scale_fill_viridis(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), option = &quot;turbo&quot;, limits = c(0.2, 174), trans = &quot;log10&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$date, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- pop_g100m %&gt;% group_split(date) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 3.2: Population density by grid cells of 100m x 100m ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = pop_g100m, aes(fill = pop_total_km2), color = NA) + scale_fill_viridis(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), option = &quot;turbo&quot;, trans = &quot;log10&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap(~date) Figure 3.3: Population density by grid cells of 100m x 100m 3.2 House prices by grid cells of 100m x 100m However, for housing prices we focus our analysis to the main building types in the City of Copenhagen (Figure 3.4), which are in this order: i) multi-storey residential buildings (code 140), ii) detached single-family houses (codes 120, 121, 122), iii) colleges (code 150), and iv) semi-detached houses (codes 130, 131, 132). # Aux. function for plotting 2D kernel density maps: f &lt;- function(.data) { .data %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_point(aes(X, Y), size = 0.02, shape = 16) + stat_density_2d(aes(X, Y, fill = ..level..), alpha = 0.5, h = 700, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = .data$type, x = &quot;&quot;, y = &quot;&quot;) } # Plots p &lt;- res_units_sf %&gt;% filter(year == 2019) %&gt;% # Reorder type factors by the frequency they appear mutate(type = fct_infreq(type)) %&gt;% # Split by house type group_split(type) %&gt;% map( ~ f(.)) wrap_plots(p) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(0.70, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) + plot_annotation(title = &quot;Residential units in 2019&quot;, theme = theme(plot.title = element_text(size = 14, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), plot.caption = element_text(size = 9, colour = &quot;grey25&quot;) ) ) Figure 3.4: 2D kernel density map Then, we selected from the main residential buildings those that are on the ordinary free trade (OVERDRAGELSES_KODE == 1 - Almindelig frit salg) or public sales (OVERDRAGELSES_KODE == 3 - Auktion). Colleges were also excluded from the data analysis since they are a special type of buildings dedicated to students residences mainly outside of the free marked. Finally, we adjusted the housing prices to 2019 prices and estimated the price per square meter (\\(kDDK/m^2\\)) by dividing the 2019 adjusted prices and the size of the dwelling (BEBO_ARL). Inconsistent values have been removed; i.e. 2019 adjusted prices = 0 kDKK. selected_res_units &lt;- c(&quot;Multi-storey&quot;, &quot;Single-family house&quot;, &quot;Semi-detached house&quot;) res_units_oft &lt;- res_units %&gt;% # Select main residential units in the area filter.(type %in% selected_res_units) %&gt;% # ordinary free trade or auction filter.(OVERDRAGELSES_KODE == &quot;1&quot; | OVERDRAGELSES_KODE == &quot;3&quot;) %&gt;% # Drop unused factors levels droplevels() %&gt;% # 2019 adjusted house prices left_join.(price_index, by = c(&quot;year&quot; = &quot;index_year&quot;)) %&gt;% mutate.(index_2019 = price_index_2019$index_year, price_2019_kDKK = (price_kDKK * index_2019 / index_value), price_2019_kDKK_m2 = price_2019_kDKK / BEBO_ARL) %&gt;% # Remove prices &gt; 0 kDKK filter.(price_2019_kDKK &gt; 0) The total number of residential units used for the analysis is therefore 197019 (Table 3.1). # Table with Number of residential units res_units_oft %&gt;% # Summarize by type or residency and year group_by(type, year) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Arrange and add row with totals arrange(year, desc(n)) %&gt;% # Pivot pivot_wider(names_from = year, values_from = n) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% kbl(caption = &quot;Number of residential dwellings in the free trade by year&quot;) %&gt;% kable_paper() %&gt;% row_spec(4, bold = TRUE) %&gt;% scroll_box(width = &quot;100%&quot;) Table 3.1: Number of residential dwellings in the free trade by year type 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 Multi-storey 12076 14106 13735 12204 7085 5175 14717 8348 9217 9911 11483 12807 11322 12096 11523 11868 Single-family house 667 669 550 563 464 433 795 552 899 661 698 704 713 707 665 719 Semi-detached house 268 288 280 355 256 203 313 478 457 483 520 527 1347 1254 1312 546 Total 13011 15063 14565 13122 7805 5811 15825 9378 10573 11055 12701 14038 13382 14057 13500 13133 The summary descriptive statistics of the housing prices are: # Table theme theme_gtsummary_compact() # Create variable labels of the variables to be printed in the table labelled::var_label(res_units_oft$price_2019_kDKK) &lt;- &quot;Adjusted prices (kDKK)&quot; labelled::var_label(res_units_oft$BEBO_ARL) &lt;- &quot;Dwelling size (m2)&quot; labelled::var_label(res_units_oft$price_2019_kDKK_m2) &lt;- &quot;Adjusted prices per square meter (kDKK/m2)&quot; # Summary table res_units_oft %&gt;% # Select variables of interest select(type, price_2019_kDKK, BEBO_ARL, price_2019_kDKK_m2) %&gt;% # Summary values tbl_summary(by = type, type = all_continuous() ~ &quot;continuous2&quot;, statistic = all_continuous() ~ c(&quot;{mean}&quot;, &quot;{median}&quot;, &quot;{p25} - {p75}&quot;, &quot;{min} - {max}&quot;), missing = &quot;no&quot;) %&gt;% add_overall() %&gt;% modify_spanning_header(c(&quot;stat_1&quot;, &quot;stat_2&quot;, &quot;stat_3&quot;) ~ &quot;**House type**&quot;) %&gt;% modify_footnote(update = everything() ~ NA) %&gt;% bold_labels() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #efoodfieex .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: small; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #efoodfieex .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #efoodfieex .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #efoodfieex .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #efoodfieex .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #efoodfieex .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #efoodfieex .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #efoodfieex .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #efoodfieex .gt_column_spanner_outer:first-child { padding-left: 0; } #efoodfieex .gt_column_spanner_outer:last-child { padding-right: 0; } #efoodfieex .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #efoodfieex .gt_group_heading { padding: 1px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #efoodfieex .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #efoodfieex .gt_from_md > :first-child { margin-top: 0; } #efoodfieex .gt_from_md > :last-child { margin-bottom: 0; } #efoodfieex .gt_row { padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #efoodfieex .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #efoodfieex .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; } #efoodfieex .gt_first_summary_row { padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #efoodfieex .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; } #efoodfieex .gt_first_grand_summary_row { padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #efoodfieex .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #efoodfieex .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #efoodfieex .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #efoodfieex .gt_footnote { margin: 0px; font-size: 90%; padding: 1px; } #efoodfieex .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #efoodfieex .gt_sourcenote { font-size: 90%; padding: 1px; } #efoodfieex .gt_left { text-align: left; } #efoodfieex .gt_center { text-align: center; } #efoodfieex .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #efoodfieex .gt_font_normal { font-weight: normal; } #efoodfieex .gt_font_bold { font-weight: bold; } #efoodfieex .gt_font_italic { font-style: italic; } #efoodfieex .gt_super { font-size: 65%; } #efoodfieex .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Overall, N = 197,019 House type Multi-storey, N = 177,673 Semi-detached house, N = 8,887 Single-family house, N = 10,459 Adjusted prices (kDKK) Mean 39,036 42,437 8,814 6,947 Median 3,714 3,560 4,264 4,325 IQR 2,208 - 13,046 2,112 - 18,043 3,636 - 6,006 3,333 - 5,722 Range 0 - 1,807,452 0 - 1,807,452 0 - 255,863 4 - 240,251 Dwelling size (m2) Mean 89 84 131 137 Median 81 77 130 128 IQR 60 - 108 58 - 101 115 - 142 103 - 158 Range 10 - 733 10 - 655 12 - 402 10 - 733 Adjusted prices per square meter (kDKK/m2) Mean 539 589 73 85 Median 39 40 36 35 IQR 30 - 152 30 - 219 29 - 45 27 - 43 Range 0 - 37,655 0 - 37,655 0 - 12,038 0 - 14,445 # Detect to what grid belongs a house plan(multisession, workers = 7) res_units_oft_g100m &lt;- res_units_oft %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = 25832) %&gt;% group_split(year) %&gt;% future_map_dfr(., ~st_intersection(., grids100m$data_poly[[1]])) plan(&quot;default&quot;) # Summary house prices by grid cells of 100m x 100m sum_runits_prices &lt;- res_units_oft_g100m %&gt;% st_drop_geometry() %&gt;% group_by(year, grid_ID) %&gt;% summarise(n_runits_oft = n(), mean_2019_kDKK_m2 = mean(price_2019_kDKK_m2, na.rm = TRUE), median_2019_kDKK_m2 = median(price_2019_kDKK_m2, na.rm = TRUE)) %&gt;% ungroup() # Link with population data by grids of 100m x 100m prices_g100m &lt;- pop_g100m %&gt;% select(-pop_total_km2_cut) %&gt;% rename(year = date) %&gt;% right_join(sum_runits_prices, by = c(&quot;year&quot;, &quot;grid_ID&quot;)) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = cut(median_2019_kDKK_m2, breaks = quantile(prices_g100m$median_2019_kDKK_m2, seq(0, 1, 0.1)), include.lowest = TRUE, right = TRUE, dig.lab = 0, ordered_result = TRUE)), color = NA) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;turbo&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- prices_g100m %&gt;% group_split(year) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 3.5: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = prices_g100m, aes(fill = cut_number(median_2019_kDKK_m2, n = 10, ordered_result = TRUE, dig.lab = 0)), color = NA) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;turbo&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~year) Figure 3.6: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m 3.3 Population density and house prices ggplot(data = filter(prices_g100m, n_runits_oft &gt;= 5, median_2019_kDKK_m2 &gt; 1), aes(x = pop_total_km2, y = median_2019_kDKK_m2, colour = factor(year))) + geom_point() + scale_x_log10() + scale_y_log10() + theme_bw() Bivariate map # Aux. function for plotting bivariate map for each year f_bi_map &lt;- function(df) { # create classes bi_data &lt;- bi_class(df, x = pop_total_km2, y = median_2019_kDKK_m2, style = &quot;quantile&quot;, dim = 3) # create map p_map &lt;- ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), color = NA, size = 0.1, show.legend = FALSE) + bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + labs(title = df$year) + bi_theme() + theme(plot.title = element_text(size = 10, hjust = 0, colour = &quot;grey25&quot;)) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;ppl/km2&quot;, ylab = &quot;kDKK/m2&quot;, size = 8) # combine map with legend p_map + inset_element(p_legend, left = 0, bottom = 0, right = 0.25, top = 0.25, align_to = &#39;full&#39;) } # Plot each year plan(multisession, workers = 7) plts &lt;- prices_g100m %&gt;% group_split(year) %&gt;% future_map(., .f = f_bi_map) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 3.7: Population density and house prices in the ordinary free trade # Create classes bi_data &lt;- prices_g100m %&gt;% group_by(year) %&gt;% bi_class(x = pop_total_km2, y = median_2019_kDKK_m2, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() # Create map p1 &lt;- ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), color = NA, size = 0.1, show.legend = FALSE) + bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;ppl/km2&quot;, ylab = &quot;kDKK/m2&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.8: Population density and house prices in the ordinary free trade "]]
