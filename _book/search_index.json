[["population-data.html", "Chapter 4 Population data 4.1 Population density", " Chapter 4 Population data Population data at parish level have been retrieved from Statistics Denmark using the R-package danstat. We have created two auxiliary function for reading the data. steps loops by year for getting small pieces of information from the DST API and then putting all together in a data frame. In this sense, we overcome the limitation of the number of rows we can retrieve from the API (i.e. if we call a large dataset we get the error: Error: API did not return text/csv). Then, rm_words is used in the cleaning process for simplifying the description of some variables we would like to use as columns names. # Loop by year for getting DST data steps &lt;- function(year){ var_values &lt;- list(id_region, id_ancestry, year) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Remove punctuation, lowercase, stem, stopwords, and collapse strings rm_words &lt;- function(x, stopwords) { x %&gt;% strsplit(&quot; &quot;, fixed = TRUE) %&gt;% lapply(tm::removePunctuation) %&gt;% lapply(tolower) %&gt;% lapply(SnowballC::wordStem) %&gt;% lapply(function(x) x[!x %in% stopwords]) %&gt;% vapply(function(x) paste(x , collapse = &quot;_&quot;), character(1)) } We have loaded the following tables: KMSTA001: Population 1. January by parish, ancestry and National Church id_table &lt;- &quot;KMSTA001&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;HERKOMST&quot;, &quot;Tid&quot;) # Values for var_input # Region: parishes of the study area (i.e. cph_parish) id_region &lt;- cph_parish$SOGNEKODE # Ancestry id_ancestry &lt;- NA # Quarters id_year &lt;- var_pop$values[[4]]$id # Select all years # Read data prsh_ances_dst &lt;- id_year %&gt;% future_map(steps) %&gt;% bind_rows() plan(&quot;default&quot;) # Clean data prsh_ances &lt;- prsh_ances_dst %&gt;% # Translate column names into English rename(parish = SOGN, ancestry = HERKOMST, date = TID, value = INDHOLD) %&gt;% # Get parish codes (first number of the string) mutate(prsh_id = stringr::str_extract(parish, &quot;[[:alnum:]]*&quot;)) %&gt;% # Remove the code from the string (prsh) mutate(parish = sub(&quot;[[:alnum:]]* &quot;, &quot;&quot;, parish)) %&gt;% # Get municipality (info inside the parenthesis) mutate(prsh_muni = stringr::str_extract(parish, &quot;(?&lt;=\\\\().*(?=\\\\))&quot;), prsh_muni = gsub(&quot; Municipality&quot;, &quot;&quot;, prsh_muni), # removes white space from start and end of string prsh_muni = stringr::str_trim(prsh_muni)) %&gt;% # Get parish name (outside parenthesis) mutate(prsh_name = stringr::str_extract(parish, &quot;(.*(?=\\\\())&quot;), prsh_name = stringr::str_trim(prsh_name)) %&gt;% # Remove duplicate info and order columns select(prsh_id, prsh_name, prsh_muni, date, ancestry, value) %&gt;% # Make shorter names in ancestry mutate(ancestry = case_when( ancestry == &quot;Persons of Danish origin&quot; ~ &quot;pop_dan&quot;, ancestry == &quot;Immigrants from western countries&quot; ~ &quot;pop_mi_wst&quot;, ancestry == &quot;Immigrants from non-western countries&quot; ~ &quot;pop_mi_nwst&quot;, ancestry == &quot;Descendants from western countries&quot; ~ &quot;pop_de_wst&quot;, ancestry == &quot;Descendants from non-western countries&quot; ~ &quot;pop_de_nwst&quot;), ancestry = factor(ancestry)) %&gt;% # Pivot (one row for peach parish and year) pivot_wider(names_from = ancestry, values_from = value) %&gt;% # Merge immigrants and their descendants (i.e. foreigners) mutate(pop_frgn_wst = pop_mi_wst + pop_de_wst, pop_frgn_nwst = pop_mi_nwst + pop_de_nwst) %&gt;% select(-c(pop_mi_wst, pop_de_wst, pop_mi_nwst, pop_de_nwst)) %&gt;% # Add column with total population mutate(pop_total = select(., starts_with(&quot;pop_&quot;)) %&gt;% rowSums()) KMSTA003: Summary vital statistics by parish and movements id_table &lt;- &quot;KMSTA003&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;KIRKEBEV&quot;, &quot;Tid&quot;) # Values for var_input # Region: all parish id_region &lt;- cph_parish$SOGNEKODE # Ancestry id_movements &lt;- NA # Quarters id_year &lt;- var_pop$values[[3]]$id # Select all years # Read data plan(multisession) prsh_stats_dst &lt;- id_year %&gt;% future_map(steps) %&gt;% bind_rows() plan(&quot;default&quot;) # Clean data prsh_stats &lt;- prsh_stats_dst %&gt;% # Translate column names into English rename(parish = SOGN, movements = KIRKEBEV, date = TID, value = INDHOLD) %&gt;% # Get parish codes (first number of the string) mutate(prsh_id = stringr::str_extract(parish, &quot;[[:alnum:]]*&quot;)) %&gt;% # Remove the code from the string (prsh) mutate(parish = sub(&quot;[[:alnum:]]* &quot;, &quot;&quot;, parish)) %&gt;% # Get municipality (info inside the parenthesis) mutate(prsh_muni = stringr::str_extract(parish, &quot;(?&lt;=\\\\().*(?=\\\\))&quot;), prsh_muni = gsub(&quot; Municipality&quot;, &quot;&quot;, prsh_muni), # removes white space from start and end of string prsh_muni = stringr::str_trim(prsh_muni)) %&gt;% # Get parish name (outside parenthesis) mutate(prsh_name = stringr::str_extract(parish, &quot;(.*(?=\\\\())&quot;), prsh_name = stringr::str_trim(prsh_name)) %&gt;% # remove duplicate info and order columns select(prsh_id, prsh_name, prsh_muni, date, movements, value) %&gt;% # Clean arguments in movements (remove punctuation, stop-words, stem, and collapse) mutate(movements = rm_words(movements, c(&quot;in&quot;, &quot;the&quot;, &quot;of&quot;))) %&gt;% # Pivot (one row for each parish and year) pivot_wider(names_from = movements, values_from = value) One we have the data we merge both dataset and add the spatial information (note that there are only summary statistics from 2015): # Merge both tables in one: prsh_pop &lt;- prsh_ances %&gt;% full_join(prsh_stats) %&gt;% # remove rows with no summary data (summary data only from 2015 to 2020) filter(date &gt;= 2015, date &lt;= 2020) # Add the spatial information: prsh_pop_sf &lt;- cph_parish %&gt;% rename(prsh_id = SOGNEKODE) %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(prsh_pop, by = c(&quot;prsh_id&quot;)) 4.1 Population density We disaggregate the population data at Parish level to grid cells of 100m x 100m using residential buildings as ancillary data. BBR data represent the situation at the beginning of the given year. Therefore, when we link the BBR data with the population data, which also represent the situation at the first day of the year, we use the population of the same year (e.g. BBR data from 2019 and population data from 2019). 4.1.1 Choropleth by ancestry Plot population density at the last day of 2019 (first of 2010) by parish and ancestry (figure 4.1). col &lt;- brewer.pal(9, &quot;YlGnBu&quot;) pal &lt;- colorRampPalette(col) my_pallette &lt;- pal(10) pop_dens_choropleth &lt;- prsh_pop_sf %&gt;% select(prsh_id, prsh_name, prsh_area_km2, date, pop_total, pop_dan, pop_frgn_wst, pop_frgn_nwst) %&gt;% filter(date == 2019) %&gt;% # Calulate population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * prsh_area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% as_tibble() %&gt;% pivot_longer(starts_with(&quot;pop_&quot;)) %&gt;% st_as_sf() %&gt;% mutate(name = factor(name, levels = c(&quot;pop_total_km2&quot;, &quot;pop_dan_km2&quot;, &quot;pop_frgn_wst_km2&quot;, &quot;pop_frgn_nwst_km2&quot;), labels = c(&quot;Total&quot;, &quot;Danish origin&quot;, &quot;Immigrants and their descendants from western countries&quot;, &quot;Immigrants and their descendants from non-western countries&quot;))) brks_c &lt;- c(min(pop_dens_choropleth$value), 1, 2, 4, 8, 12, 16, 20, 25, 30, ceiling(max(pop_dens_choropleth$value))) pop_dens_choropleth %&gt;% ggplot() + geom_sf(aes(fill = cut(value, breaks = brks_c, include.lowest = T)), color = &quot;grey50&quot;, size = 0.05) + scale_fill_manual(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), values = my_pallette, drop = FALSE, guide = guide_legend(reverse=TRUE)) + my_theme_map() + theme(plot.title = element_text(size = 12, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), strip.text = element_text(size = 9, color = &quot;black&quot;, face = &quot;italic&quot;)) + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~ name) Figure 4.1: Population density at the first day of 2019 by parishes (choropleth) 4.1.2 Disaggregating population data The procedure is as follow: We calculate the occupancy rate (OR) for the residential units of each parish (j): \\[OR_{j} = \\frac{pop_{j}}{N_{j}}\\] We make grid cells of 100m x 100m over the study area We select only the grids with residential units Detect to what parish (j) belong each grid (i). (Note that one grids may be in more that one parish) Calculate the number of dwellings per grid and parish (\\(N_{ij}\\)) Estimate the population in each grid (i) base the occupancy rate by parish (j): \\[pop_{gi} = \\sum_{j = 1}^{n}(OR_{j} \\cdot N_{ij})\\] Population density: \\[PD_{i} = \\frac{pop_{i}}{A_{i}}\\] We have created the following function for the analysis: #&#39; Calculate the population density in the grids created by f_grids #&#39; @param .pop POLYGONS with the population data (i.e. prsh_pop_sf) #&#39; @param .parish POLYGONS where the number of units will be calculated #&#39; @param .res_points POINTS with the residential units (e.g. res_units) #&#39; @param .grids Grid cells generated by f_grids #&#39; @param .year Year of the analysis f_pd_grids &lt;- function(.pop, .parish, .res_points, .grids, .year) { # Population at the last day of the year (.year) pop_year &lt;- .pop %&gt;% # Select population data at the first day of the quarter select(prsh_id, prsh_name, prsh_area_km2, date, pop_total, pop_dan, pop_frgn_wst, pop_frgn_nwst) %&gt;% # select the data at the end of the year (first dat of the next year) filter(date == (.year)) # BBR of the selected year (represent the last day of the year) BBR_year &lt;- filter(.res_points, BBR_year == .year) # Calculate occupancy rate (&quot;OR&quot;) of the residential units in each parish in a year OR &lt;- pop_year %&gt;% # number of units per parish mutate(n_units = st_intersects(., BBR_year, dist = 10) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # mean population per unit in each parish mutate(across(starts_with(&quot;pop&quot;), ~ . / n_units)) %&gt;% rename_with(~paste(.x, &quot;or&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # output as table as_tibble() %&gt;% select(-n_units, -geometry) # Get only the grids with residential units on them gru &lt;- .grids %&gt;% # Number of residential units per grid mutate(n_units = st_intersects(., BBR_year , dist = 10) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # Get grids with residential buildings filter(n_units &gt; 0) %&gt;% # Detect to what parish belong the grid st_intersection(., .parish ) %&gt;% # Remove parish area select(-prsh_area_km2, -SOGNENAVN) %&gt;% # convert to table as_tibble() # Population density by grids gru %&gt;% # Merge OR per parish left_join(OR, by = c(&quot;SOGNEKODE&quot; = &quot;prsh_id&quot;)) %&gt;% st_sf() %&gt;% # recalculate population by grid mutate(across(starts_with(&quot;pop&quot;), ~ . * n_units)) %&gt;% rename_with(~gsub(&quot;_or&quot;, &quot;&quot;, .), .col = starts_with(&quot;pop&quot;)) %&gt;% # sum population of each parish of the grid group_by(grid_ID) %&gt;% summarise(pop_total = sum(pop_total), pop_dan = sum(pop_dan), pop_frgn_wst = sum(pop_frgn_wst), pop_frgn_nwst = sum(pop_frgn_nwst), n_units = sum(n_units)) %&gt;% ungroup() %&gt;% # Area of the grid mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # Pivot longer as_tibble() %&gt;% pivot_longer(starts_with(&quot;pop_&quot;)) %&gt;% st_as_sf() %&gt;% # Remove polygons with 0 population filter(value &gt; 0) } We can therefore estimate the population in a specific year (e.g. 2019) at the first day of the year by grid cells of 100m x 100m and ancestry (figure 4.2). pop_2019_g100m &lt;- f_pd_grids(.pop = prsh_pop_sf, .parish = cph_parish, .res_points = res_units, .grids = grids100m$data_poly[[1]], .year = 2019) brks &lt;- c(min(pop_2019_g100m$value), 1, 2, 4, 8, 12, 16, 20, 25, 30, ceiling(max(pop_2019_g100m$value))) pop_2019_g100m %&gt;% mutate(name = factor(name, levels = c(&quot;pop_total_km2&quot;, &quot;pop_dan_km2&quot;, &quot;pop_frgn_wst_km2&quot;, &quot;pop_frgn_nwst_km2&quot;), labels = c(&quot;Total&quot;, &quot;Danish origin&quot;, &quot;Immigrants and their descendants from western countries&quot;, &quot;Immigrants and their descendants from non-western countries&quot;))) %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(aes(fill = cut(value, breaks = brks, include.lowest = T)), color = NA) + scale_fill_manual(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), values = my_pallette, drop = FALSE, guide = guide_legend(reverse = TRUE)) + my_theme_map() + theme(plot.title = element_text(size = 12, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), strip.text = element_text(size = 9, color = &quot;black&quot;, face = &quot;italic&quot;)) + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~ name) Figure 4.2: Population density at the first day of 2019 by grid cells of 100m x 100m 4.1.3 Population density WorldPop We compare our results with the WorldPop total population estimation per grid-cell of 3 arc (approx. gri cells of 100m x 100m; Figure 4.3), and the spatial pattern is similar between both maps although our approach seems more precise since it takes into account the population data at parish level from Statistic Denmark. dnk_ppp_2019_link &lt;- &quot;https://data.worldpop.org/GIS/Population/Global_2000_2020/2019/DNK/dnk_ppp_2019.tif&quot; # Download data into the local repository (i.e. loc_dir) download.file(url = dnk_ppp_2019_link, destfile = paste(loc_dir, &quot;dnk_ppp_2019.tif&quot;, sep = &quot;/&quot;), method = &quot;curl&quot;) # Load file dnk_ppp_2019 &lt;- read_stars(.x = paste(loc_dir, &quot;dnk_ppp_2019.tif&quot;, sep = &quot;/&quot;), proxy = TRUE) # Crop study area bbox &lt;- study_area %&gt;% st_transform(crs = st_crs(dnk_ppp_2019)) cph_ppp_2019 &lt;- st_crop(dnk_ppp_2019, bbox) %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Plot col &lt;- brewer.pal(9, &quot;YlGnBu&quot;) pal &lt;- colorRampPalette(col) my_pallette &lt;- pal(10) brks &lt;- c(min(cph_ppp_2019$dnk_ppp_2019.tif, na.rm = TRUE), 1, 2, 4, 8, 12, 16, 20, 25, 30, max(cph_ppp_2019$dnk_ppp_2019.tif, na.rm = TRUE)) cph_ppp_2019 &lt;- cph_ppp_2019 %&gt;% mutate( pop_cuts = cut(dnk_ppp_2019.tif, breaks = brks, include.lowest = T)) ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_stars(data = cph_ppp_2019, aes(fill = pop_cuts)) + scale_fill_manual(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), values = my_pallette, drop = FALSE, guide = guide_legend(reverse=TRUE)) + labs(title = &quot;Estimated total number of people per grid-cell of 3 arc&quot;, caption = &quot;Source: WorlpPop (https://data.worldpop.org)&quot;) + my_theme_map() Figure 4.3: WorldPop total population density estimations in 2019 "]]
