[["level-CPH.html", "Chapter 4 Copenhagen city 4.1 Population density by grid cells of 100m x 100m 4.2 House prices by grid cells of 100m x 100m 4.3 Population density and house prices", " Chapter 4 Copenhagen city We focus the study on Copenhagen (muni_id = 0101) and Frederiksberg (muni_id = 0147) municipalities (Figure 4.1A), and we make the analysis at a scale of grid cells of 100m x 100m (Figure 4.1B). # Codes of the communes under study (KOMKODE) study_area_codes &lt;- c(&quot;0101&quot;, &quot;0147&quot;) # Select municipalities under study cph_muni &lt;- dk_muni %&gt;% filter(muni_id %in% study_area_codes) # Parishes polygons of Denmark, and select those in the study area parish_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_parish &lt;- read_sf(parish_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the study area dk_parish_cent &lt;- st_centroid(dk_parish) cph_parish_cent &lt;- st_intersection(dk_parish_cent, cph_muni) cph_parish &lt;- filter(dk_parish, SOGNEKODE %in% cph_parish_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) # Contour of the study area (merge the parishes in one polygon): study_area &lt;- cph_parish %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Make grid cells of 100m x 100m grids100m &lt;- study_area %&gt;% # Make regular grids (100m x 100m) st_make_grid(cellsize = 100) %&gt;% st_sf() %&gt;% # Select grids only in the study area mutate(int = st_intersects(., study_area) %&gt;% lengths &gt; 0) %&gt;% filter(int == TRUE) %&gt;% select(-int) %&gt;% # Name grids as &quot;g001&quot;, &quot;g002&quot;, ... mutate(grid_ID = paste0(&quot;g&quot;, stringr::str_pad(seq(1, nrow(.), 1), 3, pad = &quot;0&quot;))) # Centroids of the grid cells (for Potential Model) grids100m &lt;- grids100m %&gt;% # Nesting nest(data_poly = everything()) %&gt;% # add centroids of the grids mutate(data_points = map(data_poly, st_centroid)) # Plot parish in the study area p1 &lt;- ggplot() + geom_sf(data = cph_muni, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + my_theme_map() + labs(title = &quot;A) Municipalities&quot;) # Plot grids p2 &lt;- ggplot() + geom_sf(data = cph_muni, fill = NA, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = grids100m$data_poly[[1]], fill = NA, color = &quot;red&quot;, size = 0.05) + my_theme_map() + labs(title = &quot;B) Grid cells of 100m x 100m&quot;) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(1.30, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) # Plot p1 + p2 Figure 4.1: Copenhagen and Frederiksberg municipalities 4.1 Population density by grid cells of 100m x 100m We disaggregate therefore population data at municipality level to the grid cells of 100m x 100m (i.e. 10786 grid cells in the study area) using all residences for year-round living (ENH_ANVEND_KODE) (i.e. from the Building and Dwelling Register - BBR as ancillary data. We also removed from the dataset those dwellings that are not actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig) and dwellings with a size lower than that 10 \\(m^2\\). # Buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 110, &quot;Farmhouse&quot;, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;, 150, &quot;College&quot;, 160, &quot;Residential institution&quot;, 190, &quot;Second building&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Function for reading residential units in the study area from a BBR files (.csv): f_res_units &lt;- function(.file, .muni = study_area_codes) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # Format KomKode and select municipalities of the study area mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% filter.(KomKode %in% .muni) %&gt;% # Remove residential units not used for for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() } # Load residential units (from .csv files) # NOTE: you may need to change the path to your file on &quot;OneDrive - Aalborg Universitet&quot; csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) plan(multisession, workers = 7) res_units_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_res_units) plan(&quot;default&quot;) # Clean dataset res_units &lt;- res_units_read %&gt;% # Input empty cells (buildings with only one floor) in Etagebetegn as &quot;st&quot; mutate.(Etagebetegn = fifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn)) %&gt;% # Etagebetegn as ordered factor mutate.(Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE)) %&gt;% # Group floor levels with 5 or more mutate.(floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join.(res_codes, by = &quot;ENH_ANVEND_KODE&quot;) %&gt;% # Convert columns with codes (*_KODE) to character mutate.(across.(ends_with(&quot;KODE&quot;), ~as.character(.))) # Convert to sf objects res_units_sf &lt;- res_units %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) The population data at municipality level for the same period we have BBR data (2004-2019) have been retrieved from Statistics Denmark. We have used the R-package danstat and the table FT: Population figures from the censuses. id_table &lt;- &quot;FT&quot; dat_meta &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Variables variables &lt;- list( # Municipalities list(code = &quot;HOVEDDELE&quot;, values = c(&quot;101&quot;,&quot;147&quot;)), # Population at the first day of the year (from 2004 to 2019) list(code = &quot;Tid&quot;, values = seq(2004, 2019, 1)) ) # Get data pop_tot_muni &lt;- get_data(&quot;FT&quot;, variables) %&gt;% # Translate names into English rename(muni_name = HOVEDDELE, date = TID, pop_total = INDHOLD) %&gt;% # Translate København mutate(muni_name = gsub(&quot;Copenhagen&quot;, &quot;København&quot;, muni_name)) # Add spatial information pop_tot_muni_sf &lt;- cph_muni %&gt;% left_join(pop_tot_muni, by = &quot;muni_name&quot;) The procedure for disaggregating the population data is therefore as follow: Calculate the occupancy rate (OR) for the residential units of each municipality (j): \\[OR_{j} = \\frac{pop_{j}}{N_{j}}\\] Make grid cells of 100m x 100m over the study area, and select only the grids with residential units Detect to what municipality (j) belong each grid (i) (Note that one grids may be in more that one municipality) Calculate the number of dwellings per grid and municipality (\\(N_{ij}\\)) Estimate the population in each grid (i) base the occupancy rate by parish (j): \\[pop_{gi} = \\sum_{j = 1}^{n}(OR_{j} \\cdot N_{ij})\\] Population density: \\[PD_{i} = \\frac{pop_{i}}{A_{i}}\\] We can therefore estimate the population density at the first day of the year by grid cells of 100m x 100m (figure 4.2). #&#39; Aux. function for calculate the population density in the grids created by f_grids #&#39; @param .year Year of the analysis (e.g. 2019) f_pd_grids &lt;- function(.year) { # Population at the first day of the year (.year) in each municipality pop_year &lt;- pop_tot_muni_sf %&gt;% # select the data at the first day of the year filter(date == .year) # Dwellings (points) of the selected year BBR_year &lt;- res_units_sf %&gt;% filter(year == .year) %&gt;% select(geometry) # Calculate occupancy rate (&quot;OR&quot;) of the residential units in each municipality in a year OR &lt;- pop_year %&gt;% # number of units per municipality mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # mean population per unit in each parish mutate(across(starts_with(&quot;pop&quot;), ~ . / n_units)) %&gt;% # output as table as_tibble() %&gt;% select(-n_units, -geometry) # Get only the grids with residential units on them gru &lt;- grids100m$data_poly[[1]] %&gt;% # Number of residential units per grid mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # Get grids with residential buildings filter(n_units &gt; 0) %&gt;% # Add date mutate(date = .year) # Detect to what area belong the grid gru_muni &lt;- gru %&gt;% st_intersection(., cph_muni) %&gt;% # Remove parish area select(-area_km2, -muni_name) # Population density by grids pop_grids &lt;- gru_muni %&gt;% # convert to table as_tibble() %&gt;% select(-geometry) %&gt;% # Merge OR per area left_join(OR, by = &quot;muni_id&quot;) %&gt;% # recalculate population by grid mutate(across(starts_with(&quot;pop&quot;), ~ . * n_units)) %&gt;% # sum population of each municipality of the grid group_by(grid_ID) %&gt;% summarise(pop_total = sum(pop_total), n_units = sum(n_units)) %&gt;% ungroup() # Add spatial information gru %&gt;% select(-n_units) %&gt;% left_join(pop_grids, by = &quot;grid_ID&quot;) %&gt;% # Area of the grid mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # Remove polygons with 0 population filter(pop_total_km2 &gt; 0) } # List of years with BBR data (2004-2019) and population data (2008-2019) years_pd &lt;- seq(2004, 2019, 1) # Increase future maximum allowed size of global variables options(future.globals.maxSize = 8000 * 1024^2) # Population density plan(multisession, workers = 7) pop_g100m &lt;- future_map_dfr(.x = years_pd, .f = f_pd_grids) plan(&quot;default&quot;) # Default value options(future.globals.maxSize = 500 * 1024^2) # Add breaks brks &lt;- c(min(pop_g100m$pop_total_km2), 1, 2, 3, 4, 5, 10, 15, 20, 30, ceiling(max(pop_g100m$pop_total_km2))) pop_g100m &lt;- pop_g100m %&gt;% mutate(pop_total_km2_cut = cut(pop_total_km2, breaks = brks, include.lowest = TRUE)) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = pop_total_km2), color = NA) + # geom_sf(data = cph_muni, fill = NA, color = &quot;grey50&quot;, size = 0.1) + scale_fill_viridis(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), option = &quot;turbo&quot;, limits = c(0.2, 174), trans = &quot;log10&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$date, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- pop_g100m %&gt;% group_split(date) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 4.2: Population density by grid cells of 100m x 100m ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = pop_g100m, aes(fill = pop_total_km2), color = NA) + scale_fill_viridis(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), option = &quot;turbo&quot;, trans = &quot;log10&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap(~date) Figure 4.3: Population density by grid cells of 100m x 100m 4.2 House prices by grid cells of 100m x 100m However, for housing prices we focus our analysis to the main building types in the City of Copenhagen (Figure 4.4), which are in this order: i) multi-storey residential buildings (code 140), ii) detached single-family houses (codes 120, 121, 122), iii) colleges (code 150), and iv) semi-detached houses (codes 130, 131, 132). # Aux. function for plotting 2D kernel density maps: f &lt;- function(.data) { .data %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_point(aes(X, Y), size = 0.02, shape = 16) + stat_density_2d(aes(X, Y, fill = ..level..), alpha = 0.5, h = 700, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = .data$type, x = &quot;&quot;, y = &quot;&quot;) } # Plots p &lt;- res_units_sf %&gt;% filter(year == 2019) %&gt;% # Reorder type factors by the frequency they appear mutate(type = fct_infreq(type)) %&gt;% # Split by house type group_split(type) %&gt;% map( ~ f(.)) wrap_plots(p) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(0.70, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) + plot_annotation(title = &quot;Residential units in 2019&quot;, theme = theme(plot.title = element_text(size = 14, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), plot.caption = element_text(size = 9, colour = &quot;grey25&quot;) ) ) Figure 4.4: 2D kernel density map # Detect to what grid belongs a house plan(multisession, workers = 7) res_units_oft_g100m &lt;- res_units_oft %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = 25832) %&gt;% group_split(year) %&gt;% future_map_dfr(., ~st_intersection(., grids100m$data_poly[[1]])) plan(&quot;default&quot;) # Add population data of the grid cells res_units_oft_g100m &lt;- res_units_oft_g100m %&gt;% as_tibble() %&gt;% left_join(pop_g100m %&gt;% rename(year = date), by = c(&quot;year&quot;, &quot;grid_ID&quot;)) # Summary house prices by grid cells of 100m x 100m sum_runits_prices &lt;- res_units_oft_g100m %&gt;% group_by(year, grid_ID, pop_total_km2, n_units) %&gt;% summarise(n_runits_oft = n(), mean_2019_kDKK_m2 = mean(price_2019_kDKK_m2, na.rm = TRUE), median_2019_kDKK_m2 = median(price_2019_kDKK_m2, na.rm = TRUE)) %&gt;% ungroup() # Link with population data by grids of 100m x 100m prices_g100m &lt;- sum_runits_prices %&gt;% left_join(grids100m$data_poly[[1]], by = &quot;grid_ID&quot;) %&gt;% st_sf() # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = cut(median_2019_kDKK_m2, breaks = quantile(prices_g100m$median_2019_kDKK_m2, seq(0, 1, 0.1)), include.lowest = TRUE, right = TRUE, dig.lab = 0, ordered_result = TRUE)), color = NA) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;turbo&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- prices_g100m %&gt;% group_split(year) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 4.5: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = prices_g100m, aes(fill = cut_number(median_2019_kDKK_m2, n = 10, ordered_result = TRUE, dig.lab = 0)), color = NA) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;turbo&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~year) Figure 4.6: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m 4.3 Population density and house prices ggplot(data = filter(prices_g100m, n_runits_oft &gt;= 5, median_2019_kDKK_m2 &gt; 1), aes(x = pop_total_km2, y = median_2019_kDKK_m2, colour = factor(year))) + geom_point() + scale_x_log10() + scale_y_log10() + theme_bw() Bivariate map: # Aux. function for plotting bivariate map for each year f_bi_map &lt;- function(df) { # create classes bi_data &lt;- bi_class(df, x = pop_total_km2, y = median_2019_kDKK_m2, style = &quot;quantile&quot;, dim = 3) # create map p_map &lt;- ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), color = NA, size = 0.1, show.legend = FALSE) + bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + labs(title = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) + bi_theme() + theme(plot.title = element_text(size = 10, hjust = 0, colour = &quot;grey25&quot;)) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;ppl/km2&quot;, ylab = &quot;kDKK/m2&quot;, size = 8) # combine map with legend p_map + inset_element(p_legend, left = 0, bottom = 0, right = 0.25, top = 0.25, align_to = &#39;full&#39;) } # Plot each year plan(multisession, workers = 7) plts &lt;- prices_g100m %&gt;% group_split(year) %&gt;% future_map(., .f = f_bi_map) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 4.7: Population density and house prices in the ordinary free trade # Create classes bi_data &lt;- prices_g100m %&gt;% group_by(year) %&gt;% bi_class(x = pop_total_km2, y = median_2019_kDKK_m2, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() # Create map p1 &lt;- ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), color = NA, size = 0.1, show.legend = FALSE) + bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;ppl/km2&quot;, ylab = &quot;kDKK/m2&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 4.8: Population density and house prices in the ordinary free trade "]]
