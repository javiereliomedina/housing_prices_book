[["level-parish.html", "Chapter 3 Capital region 3.1 Population data 3.2 House prices at parish level", " Chapter 3 Capital region Migration in the capital region. Spatial patterns ((Georgati2021?)) and links with house prices. # Communes polygons of Denmark, and select those in the study area dk_country &lt;- st_union(dk_muni) # Codes of the communes under study capital_region_muni &lt;- c(&quot;København&quot;, &quot;Frederiksberg&quot;, &quot;Albertslund&quot;, &quot;Ballerup&quot;, &quot;Brøndby&quot;, &quot;Dragør&quot;, &quot;Gentofte&quot;, &quot;Gladsaxe&quot;, &quot;Glostrup&quot;, &quot;Herlev&quot;, &quot;Høje-Taastrup&quot;, &quot;Hvidovre&quot;, &quot;Ishøj&quot;, &quot;Lyngby-Taarbæk&quot;, &quot;Rødovre&quot;, &quot;Tårnby&quot;, &quot;Vallensbæk&quot;) # Select municipalities under study capital_muni &lt;- dk_muni %&gt;% filter(muni_name %in% capital_region_muni) dk_country_crop &lt;- st_crop(dk_country, capital_muni) # Parishes polygons of Denmark, and select those in the study area prsh_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_prsh &lt;- read_sf(prsh_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the capital region dk_prsh_cent &lt;- st_centroid(dk_prsh) capital_prsh_cent &lt;- st_intersection(dk_prsh_cent, capital_muni) capital_prsh &lt;- dk_prsh %&gt;% # Get parishes in the capital region filter(SOGNEKODE %in% capital_prsh_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Translate column names rename(prsh_id = SOGNEKODE, prsh_name = SOGNENAVN) # Contour of the capital region (merge the parishes in one polygon): capital_area &lt;- capital_prsh %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) ggplot() + geom_sf(data = capital_prsh, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = capital_muni, fill = NA, color = &quot;black&quot;, size = 0.5) + my_theme_map() + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(2, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) Figure 3.1: Parishes in the Capital region 3.1 Population data Population data at parish level was uploaded from Denmark Statistics: Tables: KMSTA001: Population 1. January by parish, ancestry and National Church. KMSTA003: Summary vital statistics by parish and movements. ## Auxiliary functions for reading the data with the package *danstat* # Loop by year for getting DST data steps &lt;- function(year){ var_values &lt;- list(id_region, id_ancestry, year) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Function for removing punctuation, lowercase, stem, stopwords, and collapse strings rm_words &lt;- function(x, stopwords) { x %&gt;% strsplit(&quot; &quot;, fixed = TRUE) %&gt;% lapply(tm::removePunctuation) %&gt;% lapply(tolower) %&gt;% lapply(SnowballC::wordStem) %&gt;% lapply(function(x) x[!x %in% stopwords]) %&gt;% vapply(function(x) paste(x , collapse = &quot;_&quot;), character(1)) } ## Read and clean table KMSTA001 # Table id_table &lt;- &quot;KMSTA001&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;HERKOMST&quot;, &quot;Tid&quot;) # Values for var_input # Region: parishes of the study area (i.e. capital_parish) id_region &lt;- capital_prsh$prsh_id # Ancestry id_ancestry &lt;- NA # Quarters id_year &lt;- var_pop$values[[4]]$id[1:12] # Select 2008-2019 # Read data (n parallel) plan(multisession, workers = 7) capital_prsh_ancestry_read &lt;- id_year %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean data capital_prsh_ancestry &lt;- capital_prsh_ancestry_read %&gt;% # Translate column names into English rename(parish = SOGN, ancestry = HERKOMST, year = TID, value = INDHOLD) %&gt;% # Get parish codes, names, and municipality names separate(parish, c(&quot;prsh_id&quot;, &quot;prsh_name&quot;, &quot;muni_name&quot;), sep = &quot; &quot;, extra = &quot;drop&quot;) %&gt;% mutate(muni_name = gsub(&quot;\\\\(&quot;, &quot;&quot;, muni_name)) %&gt;% # Make shorter names in ancestry mutate(ancestry = case_when( ancestry == &quot;Persons of Danish origin&quot; ~ &quot;pop_dan&quot;, ancestry == &quot;Immigrants from western countries&quot; ~ &quot;pop_mi_wst&quot;, ancestry == &quot;Immigrants from non-western countries&quot; ~ &quot;pop_mi_nwst&quot;, ancestry == &quot;Descendants from western countries&quot; ~ &quot;pop_de_wst&quot;, ancestry == &quot;Descendants from non-western countries&quot; ~ &quot;pop_de_nwst&quot;), ancestry = factor(ancestry)) %&gt;% # Pivot (one row for peach parish and year) pivot_wider(names_from = ancestry, values_from = value) %&gt;% # Merge immigrants and their descendants (i.e. foreigners) mutate(pop_frgn_wst = pop_mi_wst + pop_de_wst, pop_frgn_nwst = pop_mi_nwst + pop_de_nwst) %&gt;% select(-c(pop_mi_wst, pop_de_wst, pop_mi_nwst, pop_de_nwst)) %&gt;% # Add column with total population mutate(pop_total = select(., starts_with(&quot;pop_&quot;)) %&gt;% rowSums()) %&gt;% # Put NA when pop_* is 0 mutate(across(starts_with(&quot;pop&quot;), ~ifelse(.x == 0, NA, .x))) # Add the spatial information: capital_prsh_ancestry_sf &lt;- capital_prsh %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(capital_prsh_ancestry, by = c(&quot;prsh_id&quot;)) %&gt;% # Population density mutate(across(starts_with(&quot;pop&quot;), ~.x/prsh_area_km2, .names = &quot;{.col}_km2&quot;)) ## Read and clean table KMSTA003 # Table id_table &lt;- &quot;KMSTA003&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;KIRKEBEV&quot;, &quot;Tid&quot;) # Values for var_input # Region: all parish id_region &lt;- capital_prsh$prsh_id # Ancestry id_movements &lt;- NA # Quarters id_year &lt;- var_pop$values[[3]]$id[1:5] # data from 2015 to 2019 # Read data plan(multisession, workers = 7) capital_prsh_stats_read &lt;- id_year %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean data capital_prsh_stats &lt;- capital_prsh_stats_read %&gt;% # Translate column names into English rename(parish = SOGN, movements = KIRKEBEV, year = TID, value = INDHOLD) %&gt;% # Get parish codes, names, and municipality names separate(parish, c(&quot;prsh_id&quot;, &quot;prsh_name&quot;, &quot;muni_name&quot;), sep = &quot; &quot;, extra = &quot;drop&quot;) %&gt;% mutate(muni_name = gsub(&quot;\\\\(&quot;, &quot;&quot;, muni_name)) %&gt;% # Clean arguments in movements (remove punctuation, stop-words, stem, and collapse) mutate(movements = rm_words(movements, c(&quot;in&quot;, &quot;the&quot;, &quot;of&quot;))) %&gt;% # Pivot (one row for each parish and year) pivot_wider(names_from = movements, values_from = value) ## Merge both datasets in one capital_prsh_pop &lt;- capital_prsh_ancestry %&gt;% full_join(capital_prsh_stats) %&gt;% # remove rows with NAs drop_na() ## Add the spatial information: capital_prsh_pop_sf &lt;- capital_prsh %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(capital_prsh_pop, by = c(&quot;prsh_id&quot;)) Where people live in the capital region (by parish), and their change from 2008 to 2019: # Estimate percentage over the total target pop (dan, nwst, wst) in a year capital_prsh_ancestry_sf &lt;- capital_prsh_ancestry_sf %&gt;% group_by(year) %&gt;% mutate(across(.cols = c(pop_dan, pop_frgn_wst, pop_frgn_nwst, pop_total), .fns = ~ 100 * .x / sum(.x, na.rm = TRUE), .names = &quot;{.col}_pct&quot;)) %&gt;% ungroup() # Aux. function for plotting plot_ppl_pct &lt;- function(pop) { capital_prsh_ancestry_sf %&gt;% ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(aes(fill = {{ pop }} ), color = &quot;grey&quot;, size = 0.05) + scale_fill_viridis(name = &quot;Percentage&quot;, option = &quot;magma&quot;, direction = -1, limits = c(0, 5.5)) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1) + my_theme_map() + facet_wrap( ~year, ncol = 3) } plot_ppl_pct(pop_total_pct) Figure 3.2: Total population density plot_ppl_pct(pop_dan_pct) Figure 3.3: Population distribution of Danes plot_ppl_pct(pop_frgn_nwst_pct) Figure 3.4: Population distribution of non-Western residents plot_ppl_pct(pop_frgn_wst_pct) Figure 3.5: Population distribution of Western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_dan_pct, y = pop_frgn_nwst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Danes\\n(%)&quot;, ylab = &quot;Non-wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.6: Population distribution of Danes vs. Non-western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_dan_pct, y = pop_frgn_wst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Danes\\n(%)&quot;, ylab = &quot;Wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.7: Population distribution of Danes vs. Western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_frgn_nwst_pct, y = pop_frgn_wst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Non-wst\\n(%)&quot;, ylab = &quot;Wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.8: Population distribution of Non-Western vs. Western residents There are missing data form some parishes (i.e. mainly in Copenhagen City and from 2011-2015; Figure 3.2). (TRYE to estimate values in this parishes?? e.g. base on the population at municipality and the total number of residential dwellings in each parish..??) # population at municipality level (at the first day of the year) capital_muni_pop_sf &lt;- dk_muni_pop %&gt;% # Get population at the first day of the year filter(muni_name %in% capital_region_muni) %&gt;% separate(date, c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;)) %&gt;% filter(month == &quot;01&quot;) capital_muni_pop_sf %&gt;% filter(ancestry == &quot;Total&quot;) %&gt;% ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(aes(fill = pop_km2)) + scale_fill_viridis(name = &quot;ppl/km2&quot;, option = &quot;magma&quot;, direction = -1, trans = &quot;log10&quot;) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + my_theme_map() + facet_wrap( ~year, ncol = 3) Figure 3.9: Population density at municipality level Ternary plots: ggtern::ggtern(data = capital_prsh_ancestry_sf, aes(x = pop_dan, y = pop_frgn_wst, z = pop_frgn_nwst, colour = factor(year) ) ) + scale_color_viridis_d() + geom_point() + ggtern::theme_rgbw() + ggtern::theme_hidetitles() Figure 3.10: ternary plot by year ggtern::ggtern(data = capital_prsh_ancestry_sf, aes(x = pop_dan, y = pop_frgn_wst, z = pop_frgn_nwst, colour = prsh_name)) + geom_point() + facet_wrap( ~year, ncol = 3) + ggtern::theme_rgbw() + ggtern::theme_hidetitles() + theme(legend.position = &quot;bottom&quot;) + guides(colour = guide_legend(title.position = &quot;top&quot;)) Figure 3.11: Ternary plots by parish Ternary maps: center over the compositional mean of 2019 (i.e. Danes ~ 80.3%; non-wst ~ 12.3; and wst ~ 7.4%). f_tern_map &lt;- function(df) { # Make colours tric &lt;- tricolore::Tricolore(df, p1 = &quot;pop_dan&quot;, p2 = &quot;pop_frgn_wst&quot;, p3 = &quot;pop_frgn_nwst&quot;, breaks = Inf, show_data = FALSE, center = c(0.803, 0.074, 0.123), hue = 2/12, lightness = 1, chroma = 1 ) # legend p_legend &lt;- tric$key + labs(L = &quot;% Danes&quot;, T = &quot;% Wst&quot;, R = &quot;% Non-wst&quot;) + theme(axis.title = element_text(size = 5, face = &quot;bold&quot;), axis.text = element_text(size = 5)) # Add columns with colours df &lt;- df %&gt;% mutate(pop_rgb = tric$rgb) # Map ggplot() + geom_sf(data = dk_country_crop, aes(geometry = geometry), fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = pop_rgb, geometry = geometry), size = 0.05) + scale_fill_identity() + geom_sf(data = capital_muni, aes(geometry = geometry), fill = NA, color = &quot;white&quot;, size = 0.5)+ labs(title = df$year) + theme_void() + annotation_custom( ggtern::ggplotGrob(p_legend) , xmin = 730000, xmax = 742000, ymin = 6178000, ymax = 6190000 ) } plts &lt;- capital_prsh_ancestry_sf %&gt;% group_split(year) %&gt;% map(. , .f = f_tern_map) wrap_plots(plts, ncol = 3) Figure 3.12: Population distribution plts[[11]] Figure 3.13: Population distribution in 2018 3.2 House prices at parish level W have used all residences for year-round living (ENH_ANVEND_KODE) (i.e. from the Building and Dwelling Register - BBR. We remove from the dataset, however, those dwellings that are not actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig) and dwellings with a size lower than that 10 \\(m^2\\). We also focus our analysis to the main building types in the City of Copenhagen, which are in this order: i) multi-storey residential buildings (code 140), ii) detached single-family houses (codes 120, 121, 122), and iii) semi-detached houses (codes 130, 131, 132). Colleges were excluded from the data analysis since they are a special type of buildings dedicated to students residences mainly outside of the free marked. We also select from the main residential buildings those that are on the ordinary free trade (OVERDRAGELSES_KODE == 1 - Almindelig frit salg) or public sales (OVERDRAGELSES_KODE == 3 - Auktion), since these values represent what people are willing to pay for own a property. Finally, we adjusted the housing prices to 2019 prices and estimated the price per square meter (\\(kDDK/m^2\\)) by dividing the 2019 adjusted prices and the size of the dwelling (BEBO_ARL). Inconsistent values have been removed; i.e. 2019 adjusted prices = 0 kDKK. # Buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Function for reading residential units in the study area from a BBR files (.csv): f_runits_oft_capital &lt;- function(.file, .muni = study_area_codes) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # Format KomKode and select municipalities of the study area mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% filter.(KomKode %in% .muni) %&gt;% # Remove residential units not used for for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() %&gt;% # ordinary free trade or auction filter.(OVERDRAGELSES_KODE == &quot;1&quot; | OVERDRAGELSES_KODE == &quot;3&quot;) %&gt;% # Remove prices &gt; 0 kDKK filter.(price_kDKK &gt; 0) %&gt;% # 2019 adjusted house prices left_join.(price_index, by = c(&quot;year&quot; = &quot;index_year&quot;)) %&gt;% mutate.(index_2019 = price_index_2019$index_value, price_2019_kDKK = (price_kDKK * index_2019 / index_value), price_2019_kDKK_m2 = price_2019_kDKK / BEBO_ARL) } # Load residential units (from .csv files) # NOTE: you may need to change the path to your file on &quot;OneDrive - Aalborg Universitet&quot; csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) study_area_codes &lt;- capital_muni$muni_id plan(multisession, workers = 7) runits_oft_capital_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_runits_oft_capital) plan(&quot;default&quot;) # Clean dataset runits_oft_capital &lt;- runits_oft_capital_read %&gt;% # Input empty cells (buildings with only one floor) in Etagebetegn as &quot;st&quot; mutate.(Etagebetegn = fifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn)) %&gt;% # Etagebetegn as ordered factor mutate.(Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE)) %&gt;% # Group floor levels with 5 or more mutate.(floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join.(res_codes, by = &quot;ENH_ANVEND_KODE&quot;) %&gt;% # Convert columns with codes (*_KODE) to character mutate.(across.(ends_with(&quot;KODE&quot;), ~as.character(.))) # Convert to sf objects and add population data by ancestry plan(multisession, workers = 7) runits_oft_capital_sf &lt;- runits_oft_capital %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) %&gt;% # Detect to what parish belongs a house group_split(year) %&gt;% future_map_dfr(., ~st_intersection(., capital_prsh, tolerance = 50), .options = furrr_options(seed = 123)) plan(&quot;default&quot;) The total number of residential units used for the analysis is therefore 323243 (Table 3.1). # Table with Number of residential units runits_oft_capital_sf %&gt;% as_tibble() %&gt;% # Summarize by type or residency and year group_by(type, year) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Arrange and add row with totals arrange(year, desc(n)) %&gt;% # Pivot pivot_wider(names_from = year, values_from = n) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% kbl(caption = &quot;Number of residential dwellings in the free trade by year&quot;) %&gt;% kable_paper() %&gt;% row_spec(4, bold = TRUE) %&gt;% scroll_box(width = &quot;100%&quot;) Table 3.1: Number of residential dwellings in the free trade by year type 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 Multi-storey 16314 19448 17940 15528 9168 6634 18887 11025 13820 13146 15475 17109 15330 16663 15680 16243 Single-family house 3687 3672 2758 2818 2423 2138 3944 2735 3240 3191 3499 3958 3605 4000 3700 3780 Semi-detached house 1658 1786 1957 1784 1465 1019 2064 1567 1672 1695 1862 2318 2837 2921 2944 2136 Total 21659 24906 22655 20130 13056 9791 24895 15327 18732 18032 20836 23385 21772 23584 22324 22159 The summary descriptive statistics of the housing prices are: # Create variable labels of the variables to be printed in the table labelled::var_label(runits_oft_capital_sf$price_2019_kDKK) &lt;- &quot;Adjusted prices (kDKK)&quot; labelled::var_label(runits_oft_capital_sf$BEBO_ARL) &lt;- &quot;Dwelling size (m2)&quot; labelled::var_label(runits_oft_capital_sf$price_2019_kDKK_m2) &lt;- &quot;Adjusted prices per square meter (kDKK/m2)&quot; # Summary table temp &lt;- runits_oft_capital_sf %&gt;% as_tidytable() temp %&gt;% # Select variables of interest select(type, price_2019_kDKK, BEBO_ARL, price_2019_kDKK_m2) %&gt;% # Summary values tbl_summary(by = type, type = all_continuous() ~ &quot;continuous2&quot;, statistic = all_continuous() ~ c(&quot;{mean}&quot;, &quot;{median}&quot;, &quot;{p25} - {p75}&quot;, &quot;{min} - {max}&quot;), missing = &quot;no&quot;) %&gt;% add_overall() %&gt;% modify_spanning_header(c(&quot;stat_1&quot;, &quot;stat_2&quot;, &quot;stat_3&quot;) ~ &quot;**House type**&quot;) %&gt;% modify_footnote(update = everything() ~ NA) %&gt;% bold_labels() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #efoodfieex .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #efoodfieex .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #efoodfieex .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #efoodfieex .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #efoodfieex .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #efoodfieex .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #efoodfieex .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #efoodfieex .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #efoodfieex .gt_column_spanner_outer:first-child { padding-left: 0; } #efoodfieex .gt_column_spanner_outer:last-child { padding-right: 0; } #efoodfieex .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #efoodfieex .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #efoodfieex .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #efoodfieex .gt_from_md > :first-child { margin-top: 0; } #efoodfieex .gt_from_md > :last-child { margin-bottom: 0; } #efoodfieex .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #efoodfieex .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #efoodfieex .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #efoodfieex .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #efoodfieex .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #efoodfieex .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #efoodfieex .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #efoodfieex .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #efoodfieex .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #efoodfieex .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #efoodfieex .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #efoodfieex .gt_sourcenote { font-size: 90%; padding: 4px; } #efoodfieex .gt_left { text-align: left; } #efoodfieex .gt_center { text-align: center; } #efoodfieex .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #efoodfieex .gt_font_normal { font-weight: normal; } #efoodfieex .gt_font_bold { font-weight: bold; } #efoodfieex .gt_font_italic { font-style: italic; } #efoodfieex .gt_super { font-size: 65%; } #efoodfieex .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Overall, N = 323,243 House type Multi-storey, N = 238,410 Semi-detached house, N = 31,685 Single-family house, N = 53,148 Adjusted prices (kDKK) Mean 27,565 35,540 5,442 4,979 Median 3,337 3,153 3,283 3,750 IQR 2,075 - 6,537 1,838 - 10,689 2,548 - 4,300 2,957 - 5,147 Range 0 - 1,807,452 0 - 1,807,452 0 - 324,363 0 - 240,251 Dwelling size (m2) Mean 96 83 116 143 Median 88 76 113 137 IQR 64 - 118 58 - 99 96 - 130 112 - 165 Range 10 - 6,100 10 - 6,100 12 - 442 10 - 1,205 Adjusted prices per square meter (kDKK/m2) Mean 374 491 49 42 Median 34 37 29 29 IQR 26 - 52 27 - 136 24 - 38 23 - 38 Range 0 - 37,655 0 - 37,655 0 - 12,038 0 - 14,445 House prices by type (removing very low prices; i.e. &lt;1 kDKK/m2, n = 1232). ggplot(data = filter(runits_oft_capital_sf, price_2019_kDKK_m2 &gt; 1), aes(y = price_2019_kDKK_m2, x = factor(year), fill = type)) + geom_boxplot(show.legend = FALSE) + scale_y_log10() + labs(x = &quot;&quot;, y = &quot;kDKK/m2&quot;) + facet_wrap( ~ type) + theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) Figure 3.14: Boxplot of residential units in the open free trade by house typr (values have been truncated with house prices &gt;1 kDkk/m2) House prices parish (spatial distribution) # Summary house prices by parish sum_runits_oft_prices &lt;- runits_oft_capital_sf %&gt;% as.data.table() %&gt;% summarise.(n_runits_oft = n(), mean_2019_kDKK_m2 = mean(price_2019_kDKK_m2, na.rm = TRUE), median_2019_kDKK_m2 = median(price_2019_kDKK_m2, na.rm = TRUE), .by = c(year, prsh_id)) %&gt;% # Link with population data by ancestry left_join.(capital_prsh_ancestry_sf) %&gt;% st_sf() %&gt;% # Data from 2008 filter(year &gt;= 2008) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = cut(median_2019_kDKK_m2, breaks = quantile(sum_runits_oft_prices$median_2019_kDKK_m2, seq(0, 1, 0.1)), include.lowest = TRUE, right = TRUE, dig.lab = 0, ordered_result = TRUE)), color = NA) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;magma&quot;, direction = -1) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- sum_runits_oft_prices %&gt;% group_split(year) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation years_pd &lt;- seq(2008, 2019, 1) for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 3.15: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = sum_runits_oft_prices, aes(fill = cut_number(median_2019_kDKK_m2, n = 10, ordered_result = TRUE, dig.lab = 0)), color = NA) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;magma&quot;, direction = -1) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~year, ncol = 3) Figure 3.16: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m "]]
