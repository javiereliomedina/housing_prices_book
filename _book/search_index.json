[["level-parish.html", "Chapter 3 Capital region 3.1 Population data 3.2 House prices at parish level 3.3 Compositional data analysis", " Chapter 3 Capital region Migration in the capital region. Spatial patterns (Georgati and Keßler (2021)) and links with house prices. # Communes polygons of Denmark, and select those in the study area dk_country &lt;- st_union(dk_muni) # Codes of the communes under study capital_region_muni &lt;- c(&quot;København&quot;, &quot;Frederiksberg&quot;, &quot;Albertslund&quot;, &quot;Ballerup&quot;, &quot;Brøndby&quot;, &quot;Dragør&quot;, &quot;Gentofte&quot;, &quot;Gladsaxe&quot;, &quot;Glostrup&quot;, &quot;Herlev&quot;, &quot;Høje-Taastrup&quot;, &quot;Hvidovre&quot;, &quot;Ishøj&quot;, &quot;Lyngby-Taarbæk&quot;, &quot;Rødovre&quot;, &quot;Tårnby&quot;, &quot;Vallensbæk&quot;) # Select municipalities under study capital_muni &lt;- dk_muni %&gt;% filter(muni_name %in% capital_region_muni) dk_country_crop &lt;- st_crop(dk_country, capital_muni) # Parishes polygons of Denmark, and select those in the study area prsh_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_prsh &lt;- read_sf(prsh_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the capital region dk_prsh_cent &lt;- st_centroid(dk_prsh) capital_prsh_cent &lt;- st_intersection(dk_prsh_cent, capital_muni) capital_prsh &lt;- dk_prsh %&gt;% # Get parishes in the capital region filter(SOGNEKODE %in% capital_prsh_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Translate column names rename(prsh_id = SOGNEKODE, prsh_name = SOGNENAVN) # Contour of the capital region (merge the parishes in one polygon): capital_area &lt;- capital_prsh %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) ggplot() + geom_sf(data = capital_prsh, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = capital_muni, fill = NA, color = &quot;black&quot;, size = 0.5) + my_theme_map() + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(2, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) Figure 3.1: Parishes in the Capital region 3.1 Population data Population data at parish level was uploaded from Denmark Statistics: Tables: KMSTA001: Population 1. January by parish, ancestry and National Church. KMSTA003: Summary vital statistics by parish and movements. ## Auxiliary functions for reading the data with the package *danstat* # Loop by year for getting DST data steps &lt;- function(year){ var_values &lt;- list(id_region, id_ancestry, year) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Function for removing punctuation, lowercase, stem, stopwords, and collapse strings rm_words &lt;- function(x, stopwords) { x %&gt;% strsplit(&quot; &quot;, fixed = TRUE) %&gt;% lapply(tm::removePunctuation) %&gt;% lapply(tolower) %&gt;% lapply(SnowballC::wordStem) %&gt;% lapply(function(x) x[!x %in% stopwords]) %&gt;% vapply(function(x) paste(x , collapse = &quot;_&quot;), character(1)) } ## Read and clean table KMSTA001 # Table id_table &lt;- &quot;KMSTA001&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;HERKOMST&quot;, &quot;Tid&quot;) # Values for var_input # Region: parishes of the study area (i.e. capital_parish) id_region &lt;- capital_prsh$prsh_id # Ancestry id_ancestry &lt;- NA # Quarters id_year &lt;- var_pop$values[[4]]$id[1:12] # Select 2008-2019 # Read data (n parallel) plan(multisession, workers = 7) capital_prsh_ancestry_read &lt;- id_year %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean data capital_prsh_ancestry &lt;- capital_prsh_ancestry_read %&gt;% # Translate column names into English rename(parish = SOGN, ancestry = HERKOMST, year = TID, value = INDHOLD) %&gt;% # Get parish codes, names, and municipality names separate(parish, c(&quot;prsh_id&quot;, &quot;prsh_name&quot;, &quot;muni_name&quot;), sep = &quot; &quot;, extra = &quot;drop&quot;) %&gt;% mutate(muni_name = gsub(&quot;\\\\(&quot;, &quot;&quot;, muni_name)) %&gt;% # Make shorter names in ancestry mutate(ancestry = case_when( ancestry == &quot;Persons of Danish origin&quot; ~ &quot;pop_dan&quot;, ancestry == &quot;Immigrants from western countries&quot; ~ &quot;pop_mi_wst&quot;, ancestry == &quot;Immigrants from non-western countries&quot; ~ &quot;pop_mi_nwst&quot;, ancestry == &quot;Descendants from western countries&quot; ~ &quot;pop_de_wst&quot;, ancestry == &quot;Descendants from non-western countries&quot; ~ &quot;pop_de_nwst&quot;), ancestry = factor(ancestry)) %&gt;% # Pivot (one row for peach parish and year) pivot_wider(names_from = ancestry, values_from = value) %&gt;% # Merge immigrants and their descendants (i.e. foreigners) mutate(pop_frgn_wst = pop_mi_wst + pop_de_wst, pop_frgn_nwst = pop_mi_nwst + pop_de_nwst) %&gt;% select(-c(pop_mi_wst, pop_de_wst, pop_mi_nwst, pop_de_nwst)) %&gt;% # Add column with total population mutate(pop_total = select(., starts_with(&quot;pop_&quot;)) %&gt;% rowSums()) %&gt;% # Put NA when pop_* is 0 mutate(across(starts_with(&quot;pop&quot;), ~ifelse(.x == 0, NA, .x))) # Add the spatial information: capital_prsh_ancestry_sf &lt;- capital_prsh %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(capital_prsh_ancestry, by = c(&quot;prsh_id&quot;)) %&gt;% # Population density mutate(across(starts_with(&quot;pop&quot;), ~.x/prsh_area_km2, .names = &quot;{.col}_km2&quot;)) ## Read and clean table KMSTA003 # Table id_table &lt;- &quot;KMSTA003&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;KIRKEBEV&quot;, &quot;Tid&quot;) # Values for var_input # Region: all parish id_region &lt;- capital_prsh$prsh_id # Ancestry id_movements &lt;- NA # Quarters id_year &lt;- var_pop$values[[3]]$id[1:5] # data from 2015 to 2019 # Read data plan(multisession, workers = 7) capital_prsh_stats_read &lt;- id_year %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean data capital_prsh_stats &lt;- capital_prsh_stats_read %&gt;% # Translate column names into English rename(parish = SOGN, movements = KIRKEBEV, year = TID, value = INDHOLD) %&gt;% # Get parish codes, names, and municipality names separate(parish, c(&quot;prsh_id&quot;, &quot;prsh_name&quot;, &quot;muni_name&quot;), sep = &quot; &quot;, extra = &quot;drop&quot;) %&gt;% mutate(muni_name = gsub(&quot;\\\\(&quot;, &quot;&quot;, muni_name)) %&gt;% # Clean arguments in movements (remove punctuation, stop-words, stem, and collapse) mutate(movements = rm_words(movements, c(&quot;in&quot;, &quot;the&quot;, &quot;of&quot;))) %&gt;% # Pivot (one row for each parish and year) pivot_wider(names_from = movements, values_from = value) ## Merge both datasets in one capital_prsh_pop &lt;- capital_prsh_ancestry %&gt;% full_join(capital_prsh_stats) %&gt;% # remove rows with NAs drop_na() ## Add the spatial information: capital_prsh_pop_sf &lt;- capital_prsh %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(capital_prsh_pop, by = c(&quot;prsh_id&quot;)) 3.1.1 Spatial distribution Where people live in the capital region (by parish), and their change from 2008 to 2019: # Estimate population in percentage capital_prsh_ancestry_sf &lt;- capital_prsh_ancestry_sf %&gt;% group_by(year) %&gt;% mutate(across(.cols = c(pop_dan, pop_frgn_wst, pop_frgn_nwst, pop_total), .fns = ~ 100 * .x / pop_total, .names = &quot;{.col}_pct&quot;)) %&gt;% ungroup() # Aux. function for plotting plot_ppl_pct &lt;- function(pop) { capital_prsh_ancestry_sf %&gt;% ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(aes(fill = {{ pop }} ), color = &quot;grey&quot;, size = 0.05) + scale_fill_viridis(name = &quot;Percentage&quot;, option = &quot;magma&quot;, direction = -1, limits = c(0, 100) ) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1) + my_theme_map() + facet_wrap( ~year, ncol = 3) } plot_ppl_pct(pop_dan_pct) Figure 3.2: Population distribution of Danes plot_ppl_pct(pop_frgn_nwst_pct) Figure 3.3: Population distribution of non-Western residents plot_ppl_pct(pop_frgn_wst_pct) Figure 3.4: Population distribution of Western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_dan_pct, y = pop_frgn_nwst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Danes\\n(%)&quot;, ylab = &quot;Non-wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.5: Population distribution of Danes vs. Non-western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_dan_pct, y = pop_frgn_wst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Danes\\n(%)&quot;, ylab = &quot;Wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.6: Population distribution of Danes vs. Western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_frgn_nwst_pct, y = pop_frgn_wst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Non-wst\\n(%)&quot;, ylab = &quot;Wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.7: Population distribution of Non-Western vs. Western residents There are missing data form some parishes (i.e. mainly in Copenhagen City and from 2011-2015; Figure ??). (TRYE to estimate values in this parishes?? e.g. base on the population at municipality and the total number of residential dwellings in each parish..??) # population at municipality level (at the first day of the year) capital_muni_pop_sf &lt;- dk_muni_pop %&gt;% # Get population at the first day of the year filter(muni_name %in% capital_region_muni) %&gt;% separate(date, c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;)) %&gt;% filter(month == &quot;01&quot;) capital_muni_pop_sf %&gt;% filter(ancestry == &quot;Total&quot;) %&gt;% ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(aes(fill = pop_km2)) + scale_fill_viridis(name = &quot;ppl/km2&quot;, option = &quot;magma&quot;, direction = -1, trans = &quot;log10&quot;) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + my_theme_map() + facet_wrap( ~year, ncol = 3) Figure 3.8: Population density at municipality level 3.1.2 Autocorrelation (Moran I) Local spatial autocorrelation. Define neighbours polygons and weights: # Based on: # https://mgimond.github.io/simple_moransI_example/ # https://rpubs.com/quarcs-lab/spatial-autocorrelation library(spdep) # Local Moran index f_local_moran &lt;- function(year, variable, df = capital_prsh_ancestry_sf, signif = 0.15) { # Polygons s &lt;- df %&gt;% # Select filter(year == {{ year }}) %&gt;% drop_na() %&gt;% st_sf() # Variable x &lt;- s %&gt;% # Variable pull( {{ variable }}) # Plot MI xp &lt;- x %&gt;% # Local Index localmoran_perm(listw = nb2listw(poly2nb(s, queen = TRUE), style = &quot;W&quot;, zero.policy = TRUE), nsim = 999) %&gt;% as_tibble() %&gt;% dplyr::rename(p.value = `Pr(z &gt; 0)`) %&gt;% # binds results to our polygon shapefile cbind(s) %&gt;% st_sf() %&gt;% # center the variable of interest around its mean mutate(m_qualification = x - mean( x ), m_local = Ii - mean(Ii)) %&gt;% # Build quadrant mutate(quadrant = case_when(m_qualification &gt; 0 &amp; m_local &gt; 0 ~ 4, m_qualification &lt; 0 &amp; m_local &lt; 0 ~ 1, m_qualification &lt; 0 &amp; m_local &gt; 0 ~ 2, m_qualification &gt; 0 &amp; m_local &lt; 0 ~ 3), quadrant = ifelse(p.value &gt; signif, 0, quadrant)) %&gt;% mutate(quadrant = factor(quadrant, levels = c(0, 1, 2, 3, 4), labels = c(&quot;Insignificant&quot;, &quot;Low-Low&quot;, &quot;Low-High&quot;, &quot;High-Low&quot;, &quot;High-High&quot;))) xp %&gt;% # Plot quadrants (LISA) ggplot() + geom_sf(data = capital_prsh, fill = &quot;black&quot;) + geom_sf(aes(fill = quadrant), color = &quot;grey&quot;, size = 0.05) + scale_fill_manual(name = &quot;Quadrant&quot; , values = c(&quot;lightgrey&quot;, &quot;#0000FF&quot;, &quot;#A2A2FF&quot;, &quot;#FFA2A2&quot;, &quot;#FF0000&quot;), drop = FALSE) + labs(title = {{ year }}, subtitle = {{ variable }}) + my_theme_map() } # Plot maps p &lt;- map2(.x = rep(2008:2019, times = 1, each = 3), .y = rep(c(&quot;pop_dan_pct&quot;, &quot;pop_frgn_wst_pct&quot;, &quot;pop_frgn_nwst_pct&quot;), 12), ~f_local_moran(.x, .y)) wrap_plots(p, ncol = 3) + plot_layout(guides = &quot;collect&quot;) Figure 3.9: Local Moran index (p-value &lt; 0.15) 3.1.3 Ternary plots There are some issues with ggtern and the new version of ggplot2 (v. 3.3.5). Therefore, we have made the ternary plots with older versions in a separate project (here), and here we have plotted the results. Population structure by year, with all the data together in the same diagram. knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-year-1.png&quot;) Figure 3.10: Ternary plot by year Separate plots by year and add the parishes in the legend. knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-year-prsh-1.png&quot;) Figure 3.11: Ternary plots by parish Links with house prices (zoom the figure to the parishes with median values). knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-price-all-1.png&quot;) Figure 3.12: Median housing prices and popupation distribution by parish (all data) knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-year-prsh-1.png&quot;) Figure 3.13: Median housing prices and popupation distribution by parish and year maps Center over the compositional mean of 2019 (i.e. Danes ~ 80.3%; non-wst ~ 12.3; and wst ~ 7.4%). knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-map-1.png&quot;) Figure 3.14: Population distribution Only for 2020. knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-map-2020-1.png&quot;) Figure 3.15: Population distribution in 2020 3.2 House prices at parish level W have used all residences for year-round living (ENH_ANVEND_KODE) (i.e. from the Building and Dwelling Register - BBR. We remove from the dataset, however, those dwellings that are not actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig) and dwellings with a size lower than that 10 \\(m^2\\). We also focus our analysis to the main building types in the City of Copenhagen, which are in this order: i) multi-storey residential buildings (code 140), ii) detached single-family houses (codes 120, 121, 122), and iii) semi-detached houses (codes 130, 131, 132). Colleges were excluded from the data analysis since they are a special type of buildings dedicated to students residences mainly outside of the free marked. We also select from the main residential buildings those that are on the ordinary free trade (OVERDRAGELSES_KODE == 1 - Almindelig frit salg) or public sales (OVERDRAGELSES_KODE == 3 - Auktion), since these values represent what people are willing to pay for own a property. Finally, we adjusted the housing prices to 2019 prices and estimated the price per square meter (\\(kDDK/m^2\\)) by dividing the 2019 adjusted prices and the size of the dwelling (BEBO_ARL). Inconsistent values have been removed; i.e. 2019 adjusted prices = 0 kDKK. # Buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Function for reading residential units in the study area from a BBR files (.csv): f_runits_oft_capital &lt;- function(.file, .muni = study_area_codes) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # Format KomKode and select municipalities of the study area mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% filter.(KomKode %in% .muni) %&gt;% # Remove residential units not used for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() %&gt;% # ordinary free trade or auction filter.(OVERDRAGELSES_KODE == &quot;1&quot; | OVERDRAGELSES_KODE == &quot;3&quot;) %&gt;% # Remove prices &gt; 0 kDKK filter.(price_kDKK &gt; 0) %&gt;% # 2019 adjusted house prices left_join.(price_index, by = c(&quot;year&quot; = &quot;index_year&quot;)) %&gt;% mutate.(index_2019 = price_index_2019$index_value, price_2019_kDKK = (price_kDKK * index_2019 / index_value), price_2019_kDKK_m2 = price_2019_kDKK / BEBO_ARL) } # Load residential units (from .csv files) # NOTE: you may need to change the path to your file on &quot;OneDrive - Aalborg Universitet&quot; csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) study_area_codes &lt;- capital_muni$muni_id plan(multisession, workers = 7) runits_oft_capital_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_runits_oft_capital) plan(&quot;default&quot;) # Clean dataset runits_oft_capital &lt;- runits_oft_capital_read %&gt;% # Input empty cells in Etagebetegn (buildings with only one floor) as &quot;st&quot; mutate.(Etagebetegn = fifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn)) %&gt;% # Etagebetegn as ordered factor mutate.(Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE)) %&gt;% # Group floor levels with 5 or more mutate.(floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join.(res_codes, by = &quot;ENH_ANVEND_KODE&quot;) %&gt;% # Convert columns with codes (*_KODE) to character mutate.(across.(ends_with(&quot;KODE&quot;), ~as.character(.))) # Convert to sf objects and add population data by ancestry plan(multisession, workers = 7) runits_oft_capital_sf &lt;- runits_oft_capital %&gt;% # Convert to sf object st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) %&gt;% # Detect to what parish belongs a house group_split(year) %&gt;% future_map_dfr(., ~st_join(., capital_prsh, join = st_nearest_feature), .options = furrr_options(seed = 123)) plan(&quot;default&quot;) The total number of residential units used for the analysis is therefore 342227 (Table 3.1). # Table with Number of residential units runits_oft_capital_sf %&gt;% as_tibble() %&gt;% # Summarize by type or residency and year group_by(type, year) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Arrange and add row with totals arrange(year, desc(n)) %&gt;% # Pivot pivot_wider(names_from = year, values_from = n) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% kbl(caption = &quot;Number of residential dwellings in the free trade by year&quot;) %&gt;% kable_paper() %&gt;% row_spec(4, bold = TRUE) %&gt;% scroll_box(width = &quot;100%&quot;) Table 3.1: Number of residential dwellings in the free trade by year type 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 Multi-storey 16314 19448 17940 15528 9168 6634 18887 11025 13820 13146 15475 17109 15330 16754 15720 16328 12628 Single-family house 3687 3672 2758 2818 2423 2138 3944 2735 3240 3191 3499 3958 3605 4000 3700 3780 3849 Semi-detached house 1658 1786 1957 1784 1465 1019 2064 1567 1672 1695 1862 2318 2837 2921 2944 2140 2287 Total 21659 24906 22655 20130 13056 9791 24895 15327 18732 18032 20836 23385 21772 23675 22364 22248 18764 The summary descriptive statistics of the housing prices are: # Create variable labels of the variables to be printed in the table labelled::var_label(runits_oft_capital_sf$price_2019_kDKK) &lt;- &quot;Adjusted prices (kDKK)&quot; labelled::var_label(runits_oft_capital_sf$BEBO_ARL) &lt;- &quot;Dwelling size (m2)&quot; labelled::var_label(runits_oft_capital_sf$price_2019_kDKK_m2) &lt;- &quot;Adjusted prices per square meter (kDKK/m2)&quot; library(tidyverse) library(gtsummary) # Summary table temp &lt;- as_tibble(runits_oft_capital_sf) temp %&gt;% # Select variables of interest select(type, price_2019_kDKK, BEBO_ARL, price_2019_kDKK_m2) %&gt;% # Summary values tbl_summary(by = type, type = all_continuous() ~ &quot;continuous2&quot;, statistic = all_continuous() ~ c(&quot;{mean}&quot;, &quot;{median}&quot;, &quot;{p25} - {p75}&quot;, &quot;{min} - {max}&quot;), missing = &quot;no&quot;) %&gt;% add_overall() %&gt;% modify_spanning_header(c(&quot;stat_1&quot;, &quot;stat_2&quot;, &quot;stat_3&quot;) ~ &quot;**House type**&quot;) %&gt;% modify_footnote(update = everything() ~ NA) %&gt;% bold_labels() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #qcqjnvrmtp .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #qcqjnvrmtp .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #qcqjnvrmtp .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #qcqjnvrmtp .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #qcqjnvrmtp .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #qcqjnvrmtp .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #qcqjnvrmtp .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #qcqjnvrmtp .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #qcqjnvrmtp .gt_column_spanner_outer:first-child { padding-left: 0; } #qcqjnvrmtp .gt_column_spanner_outer:last-child { padding-right: 0; } #qcqjnvrmtp .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #qcqjnvrmtp .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #qcqjnvrmtp .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #qcqjnvrmtp .gt_from_md > :first-child { margin-top: 0; } #qcqjnvrmtp .gt_from_md > :last-child { margin-bottom: 0; } #qcqjnvrmtp .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #qcqjnvrmtp .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #qcqjnvrmtp .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #qcqjnvrmtp .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #qcqjnvrmtp .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #qcqjnvrmtp .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #qcqjnvrmtp .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #qcqjnvrmtp .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #qcqjnvrmtp .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #qcqjnvrmtp .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #qcqjnvrmtp .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #qcqjnvrmtp .gt_sourcenote { font-size: 90%; padding: 4px; } #qcqjnvrmtp .gt_left { text-align: left; } #qcqjnvrmtp .gt_center { text-align: center; } #qcqjnvrmtp .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #qcqjnvrmtp .gt_font_normal { font-weight: normal; } #qcqjnvrmtp .gt_font_bold { font-weight: bold; } #qcqjnvrmtp .gt_font_italic { font-style: italic; } #qcqjnvrmtp .gt_super { font-size: 65%; } #qcqjnvrmtp .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Overall, N = 342,227 House type Multi-storey, N = 251,254 Semi-detached house, N = 33,976 Single-family house, N = 56,997 Adjusted prices (kDKK) Mean 27,550 35,513 5,443 4,979 Median 3,342 3,155 3,283 3,750 IQR 2,075 - 6,539 1,838 - 10,637 2,548 - 4,300 2,957 - 5,147 Range 0 - 1,807,452 0 - 1,807,452 0 - 324,363 0 - 240,251 Dwelling size (m2) Mean 96 83 116 144 Median 88 76 112 137 IQR 64 - 118 58 - 99 96 - 130 112 - 165 Range 10 - 6,100 10 - 6,100 12 - 442 10 - 1,205 Adjusted prices per square meter (kDKK/m2) Mean 373 490 49 42 Median 34 37 29 29 IQR 26 - 52 27 - 135 24 - 38 23 - 38 Range 0 - 37,655 0 - 37,655 0 - 12,038 0 - 14,445 House prices by type (removing very low prices; i.e. &lt;1 kDKK/m2, n = 1232). ggplot(data = filter(runits_oft_capital_sf, price_2019_kDKK_m2 &gt; 1), aes(y = price_2019_kDKK_m2, x = factor(year), fill = type)) + geom_boxplot(show.legend = FALSE) + scale_y_log10() + labs(x = &quot;&quot;, y = &quot;kDKK/m2&quot;) + facet_wrap( ~ type) + theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) Figure 3.16: Boxplot of residential units in the open free trade by house typr (values have been truncated with house prices &gt;1 kDkk/m2) House prices parish (spatial distribution) # Summary house prices by parish sum_runits_oft_prices &lt;- runits_oft_capital_sf %&gt;% as.data.table() %&gt;% summarise.(n_runits_oft = n(), mean_2019_kDKK_m2 = mean(price_2019_kDKK_m2, na.rm = TRUE), median_2019_kDKK_m2 = median(price_2019_kDKK_m2, na.rm = TRUE), .by = c(year, prsh_id)) %&gt;% # Link with population data by ancestry left_join.(capital_prsh_ancestry_sf) %&gt;% st_sf() %&gt;% # Data from 2008 filter(year &gt;= 2008) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = cut(median_2019_kDKK_m2, breaks = quantile(sum_runits_oft_prices$median_2019_kDKK_m2, seq(0, 1, 0.1), na.rm = TRUE), include.lowest = TRUE, right = TRUE, dig.lab = 0, ordered_result = TRUE)), color = NA) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;magma&quot;, direction = -1) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- sum_runits_oft_prices %&gt;% group_split(year) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation years_pd &lt;- seq(2008, 2019, 1) for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 3.17: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = sum_runits_oft_prices, aes(fill = cut_number(median_2019_kDKK_m2, n = 10, ordered_result = TRUE, dig.lab = 0)), color = NA) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;magma&quot;, direction = -1) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~year, ncol = 3) Figure 3.18: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m remove one parish with non-western migrants up to 80% (NAME). There were not house prices in the ordinary free sale (only for one year); WHY? 3.3 Compositional data analysis Migration data usually reflected a percentage over the total population, which make them close data. We need to applu therefore CoDa framework. Types of transformation worr working with these data (i.e. alr, clr, ilr). We can use standart statistics over these lorg-rations, mainly with ilr transformations (Lloyd, Pawlowsky-Glahn, and Egozcue (2012)) balances - concept and aplications. How to obtain the best transformation (based on expert knowlegde of the data- PCA). library(compositions) # CoDa (2019) x &lt;- capital_prsh_ancestry_sf %&gt;% filter(year == 2019) %&gt;% select(prsh_id, pop_dan, pop_frgn_nwst, pop_frgn_wst) %&gt;% rename(dan = pop_dan, nwst = pop_frgn_nwst, wst = pop_frgn_wst) %&gt;% as_tibble() %&gt;% drop_na() %&gt;% select(-geometry) xc &lt;- x %&gt;% clo(parts = c(&quot;dan&quot;, &quot;nwst&quot;, &quot;wst&quot;), total = 100) %&gt;% acomp() PCA (with clr transformations). Helps to identifythe variables taht most accoutn for the variability of the results and chose the balance. . par(mfrow = c(1, 2)) # PCA pc &lt;- princomp(xc) # summary(pc) coloredBiplot(x = pc, pc.biplot = T, xlabs.pc = c(1, 2, 3), xlabs.col = 2:4, col = &quot;black&quot;, xlab = &quot;Comp. 1 (73%)&quot;, ylab = &quot;Comp. 1 (27%)&quot;) # Dendrogram balances signary &lt;- t(matrix( c(1, -1, 1, 1, 0, -1), ncol = 3, nrow = 2, byrow = TRUE)) CoDaDendrogram(X = xc, signary = signary, col = &quot;black&quot;, range = c(-8,8), # type = &quot;l&quot;, main = &quot;CoDa Dendrogram&quot;) Figure 3.19: Biplot of clr transfomation and balance dendrogram In our cases, with only three variables, our balances are: \\[ b_1 = \\sqrt{\\frac{2}{3}} * ln(\\frac{x_1 x_2}{x_3^2}) \\] \\[ b_2 = \\sqrt{\\frac{1}{2}} * ln(\\frac{x_1}{x_2}) \\] Where \\(x_1\\), \\(x_2\\), \\(x_3\\) are the Danes, Western, and Non-wester population in the parish. # bal &lt;- balance(xc, ~pop_dan/pop_frgn_wst/pop_frgn_nwst) bal_sf &lt;- capital_prsh_ancestry_sf %&gt;% filter(year == 2019) %&gt;% mutate(b1 = sqrt(2/3) * log( ((pop_dan * pop_frgn_wst)^0.5) / (pop_frgn_nwst)), b2 = sqrt(1/2) * log(pop_dan / pop_frgn_wst)) We can therefore analyse the spatial autocorrelation of the balances: # Moran nb &lt;- poly2nb(bal_sf, queen = TRUE) wts &lt;- nb2listw(nb, style = &quot;W&quot;, zero.policy = TRUE) # Global index GMI_b1 &lt;- moran.test(bal_sf$b1, listw = wts) %&gt;% tidy() %&gt;% mutate(balance = &quot;b1&quot;) %&gt;% select(balance, everything()) %&gt;% rename(moran_I = estimate1, expectation = estimate2, variance = estimate3) GMI_b2 &lt;- moran.test(bal_sf$b2, listw = wts) %&gt;% tidy() %&gt;% mutate(balance = &quot;b2&quot;) %&gt;% select(balance, everything()) %&gt;% rename(moran_I = estimate1, expectation = estimate2, variance = estimate3) GMI &lt;- bind_rows(GMI_b1, GMI_b2) %&gt;% print() # # A tibble: 2 x 8 # balance moran_I expectation variance statistic p.value method alternative # &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; # 1 b1 0.471 -0.00794 0.00312 8.57 5.06e-18 Moran I test under randomisati~ greater # 2 b2 0.554 -0.00794 0.00312 10.1 4.33e-24 Moran I test under randomisati~ greater f_local_moran(df = bal_sf, year = 2019, variable = &quot;b1&quot;, signif = 0.1) f_local_moran(df = bal_sf, year = 2019, variable = &quot;b2&quot;, signif = 0.1) Spatial clusters (k-means cluster) with balances: separate Non-western from Danes and Western citizens. # based on https://www.tidymodels.org/learn/statistics/k-means/ # Select the optimal number of clusters dat_cluster &lt;- bal_sf %&gt;% select(b1, b2) %&gt;% as_tibble() %&gt;% select(-geometry) kclusts &lt;- tibble(k = 1:9) %&gt;% mutate( kclust = map(k, ~kmeans(dat_cluster, .x)), tidied = map(kclust, tidy), glanced = map(kclust, glance), augmented = map(kclust, augment, bal_sf) ) # Plot total within sum of squares clusterings &lt;- kclusts %&gt;% unnest(cols = c(glanced)) ggplot(clusterings, aes(k, tot.withinss)) + geom_line() + geom_point() + theme_bw() assignments &lt;- kclusts %&gt;% unnest(cols = c(augmented)) %&gt;% st_sf() # plot k = 4 assignments %&gt;% filter(k == 4) %&gt;% ggplot() + geom_sf(aes(fill = .cluster)) assignments %&gt;% filter(k == 4 ) %&gt;% group_by(.cluster) %&gt;% summarise(across(.cols = ends_with(&quot;pct&quot;), .fns = median)) %&gt;% as_tibble() %&gt;% select(-geometry) # # A tibble: 4 x 5 # .cluster pop_dan_pct pop_frgn_wst_pct pop_frgn_nwst_pct pop_total_pct # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 1 84.5 4.40 10.6 100 # 2 2 82.6 9.57 6.80 100 # 3 3 76.1 8.86 14.9 100 # 4 4 66.7 6.76 26.8 100 assignments %&gt;% filter(k == 4 ) %&gt;% select(.cluster, pop_dan_pct, pop_frgn_nwst_pct, pop_frgn_wst_pct) %&gt;% as_tibble() %&gt;% pivot_longer(!c(.cluster, geometry), names_to = &quot;name&quot;, values_to = &quot;value&quot;) %&gt;% mutate(name = gsub(&quot;pop_&quot;, &quot;&quot;, name), name = gsub(&quot;_pct&quot;, &quot;&quot;, name), name = gsub(&quot;frgn_&quot;, &quot;&quot;, name)) %&gt;% ggplot() + geom_boxplot(aes(y = value, x = name), fill = &quot;red&quot;) + labs(x = &quot;&quot;, y = &quot;Percentage [%]&quot;) + facet_grid(~.cluster) + theme_bw() Figure 3.20: Cluster characteristics # Model prices # m1 &lt;- lm(log10(median_2019_kDKK_m2) ~ b1 + b2, data = bal_sf) # summary(m1) # # bal_sf$pred1 &lt;- predict(m1) # plot(log10(median_2019_kDKK_m2) ~ pred1, bal_sf) # abline(0, 1, col = &quot;blue&quot;) # lmp1 &lt;- lm(log10(median_2019_kDKK_m2) ~ pred1, bal_sf) # abline(lmp1, col = &quot;red&quot;) # summary(lmp1) # # # # m2 &lt;- lm(log10(median_2019_kDKK_m2) ~ log10(pop_total_km2) + b1 + b2, bal_sf) # summary(m2) # bal_sf$pred2 &lt;- predict(m2) # plot(log10(median_2019_kDKK_m2) ~ pred2, bal_sf) # abline(0, 1, col = &quot;blue&quot;) # lmp2 &lt;- lm(log10(median_2019_kDKK_m2) ~ pred2, bal_sf) # abline(lmp2, col = &quot;red&quot;) # # ANOVA unbalance datasets # car::Anova(m2, type=&quot;III&quot;) # # m4 &lt;- lm(log10(median_2019_kDKK_m2) ~ log10(pop_total_km2), bal_sf) # bal_sf$pred4 &lt;- predict(m4) # plot(log10(median_2019_kDKK_m2) ~ pred4, bal_sf) # abline(0, 1, col = &quot;blue&quot;) # lmp4 &lt;- lm(log10(median_2019_kDKK_m2) ~ pred4, bal_sf) # abline(lmp4, col = &quot;red&quot;) # summary(lmp4) # # ANOVA unbalance datasets # car::Anova(m4, type=&quot;III&quot;) References "]]
