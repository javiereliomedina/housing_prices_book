[["index.html", "Housing prices Copenhagen Prerequisites Create data and results folders Ggplot themes Download data from kortforsyningen R session", " Housing prices Copenhagen Javier Elío, Henning S. Hansen, Carsten Keßler 2021-04-10 Prerequisites The data have been analysed with R (version 4.0.4) and Rstudio (versio 1.4.1106), and the book has been created with bookdown package. The required packages are automatically checked and installed if needed from CRAN. # Create an auxiliary function for checking if a package is installed, # install it if it is not, and load the package # (based on https://gist.github.com/stevenworthington/3178163) ipak &lt;- function(pkg){ new_pkg &lt;- pkg[!(pkg %in% installed.packages()[, &quot;Package&quot;])] if (length(new_pkg)) install.packages(new_pkg, dependencies = TRUE, repos = &quot;http://cran.us.r-project.org&quot;) sapply(pkg, require, character.only = TRUE) } # List of packages pkg &lt;- c( &quot;bit64&quot;, &quot;bookdown&quot;, &quot;data.table&quot;, &quot;danstat&quot;, &quot;forcats&quot;, &quot;furrr&quot;, &quot;ggspatial&quot;, &quot;giscoR&quot;, &quot;janitor&quot;, &quot;kableExtra&quot;, &quot;knitr&quot;, &quot;latex2exp&quot;, &quot;osmdata&quot;, &quot;patchwork&quot;, &quot;potential&quot;, &quot;rmarkdown&quot;, &quot;remotes&quot;, &quot;RColorBrewer&quot;, &quot;sf&quot;, &quot;stringr&quot;, &quot;SnowballC&quot;, &quot;units&quot;, &quot;tidyverse&quot;, &quot;tidytext&quot;, &quot;tm&quot;, &quot;tools&quot;) # Check and install ipak(pkg) Create data and results folders Save important data and results in their respective folders dir.create(&quot;data&quot;) dir.create(&quot;results&quot;) Ggplot themes Create our own theme for plotting maps in ggplot2. my_theme_map &lt;- function() { theme_void() + theme( # Title and captions plot.title = element_text(size = 14, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), plot.caption = element_text(size = 10, colour = &quot;grey25&quot;), # Legend legend.title = element_text(size = 10, face = &quot;bold&quot;), legend.text = element_text(size = 10), # Facets strip.text = element_text(size = 12, color = &quot;black&quot;, face = &quot;italic&quot;) ) } Download data from kortforsyningen We have create our own package for downloading the data to a local repository (i.e. dangeo. Although the data are free, we need to create a username and a password for getting access to kortforsyningen. By default dangeo looks for credentials on .Renviron (kortforsyningen_id = username and kortforsyningen_pwd = password). We also need to define the local directory where the data are downloaded (i.e. dangeo_set_param()). The first time we download a file it may be time consuming; however, a file will not be downloaded if it is already in the local directory. # Install package from GitHub if (!require(&quot;dangeo&quot;)) remotes::install_github(&quot;javiereliomedina/dangeo&quot;) library(dangeo) # Set username and password # usethis::edit_r_environ() # Open .Renviron file, and save the username (kortforsyningen_id = &quot;username&quot;) and password (kortforsyningen_pwd = &quot;password&quot;) # Set local repository dangeo_set_param() # loc_dir # Check path to local repository CORINE dangeo_get_data(ftp_folder = &quot;CORINE&quot;, zip_name = &quot;DK_CORINE_SHP_UTM32-WGS84.zip&quot;) DAGI (scale 1:10000) dangeo_get_data(ftp_folder = &quot;landinddelinger/dagi/SHAPE&quot;, zip_name = &quot;DAGIREF_SHAPE_UTM32-EUREF89.zip&quot;) Inspire_railway-transport-network dangeo_get_data( ftp_folder = &quot;grundlaeggende_landkortdata/inspire_railway-transport-network&quot;, zip_name = &quot;DK_RailwayTransportNetwork_GML_UTM32-EUREF89.zip&quot;) GeoDanmark dangeo_get_data(ftp_folder = &quot;grundlaeggende_landkortdata/fot/SHAPE&quot;, zip_name = &quot;DK_SHAPE_UTM32-EUREF89.zip&quot;) R session #&gt; R version 4.0.4 (2021-02-15) #&gt; Platform: x86_64-w64-mingw32/x64 (64-bit) #&gt; Running under: Windows 10 x64 (build 17763) #&gt; #&gt; Matrix products: default #&gt; #&gt; locale: #&gt; [1] LC_COLLATE=English_United Kingdom.1252 LC_CTYPE=English_United Kingdom.1252 #&gt; [3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C #&gt; [5] LC_TIME=English_United Kingdom.1252 #&gt; #&gt; attached base packages: #&gt; [1] tools stats graphics grDevices utils datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] tictoc_1.0 dangeo_0.0.0.9000 tm_0.7-8 NLP_0.2-1 #&gt; [5] tidytext_0.3.0 dplyr_1.0.5 purrr_0.3.4 readr_1.4.0 #&gt; [9] tidyr_1.1.3 tibble_3.1.0 ggplot2_3.3.3 tidyverse_1.3.0 #&gt; [13] units_0.7-1 SnowballC_0.7.0 stringr_1.4.0 sf_0.9-8 #&gt; [17] RColorBrewer_1.1-2 remotes_2.2.0 rmarkdown_2.7 potential_0.1.0 #&gt; [21] patchwork_1.1.1 osmdata_0.1.5 latex2exp_0.5.0 knitr_1.31 #&gt; [25] kableExtra_1.3.4 janitor_2.1.0 giscoR_0.2.2 ggspatial_1.1.5 #&gt; [29] furrr_0.2.2 future_1.21.0 forcats_0.5.1 danstat_0.1.0 #&gt; [33] data.table_1.14.0 bookdown_0.21 bit64_4.0.5 bit_4.0.4 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] fs_1.5.0 lubridate_1.7.9.2 webshot_0.5.2 httr_1.4.2 #&gt; [5] bslib_0.2.4 backports_1.2.1 utf8_1.2.1 R6_2.5.0 #&gt; [9] KernSmooth_2.23-18 DBI_1.1.1 colorspace_2.0-0 withr_2.4.1 #&gt; [13] sp_1.4-5 tidyselect_1.1.0 curl_4.3 compiler_4.0.4 #&gt; [17] cli_2.3.1 rvest_1.0.0 xml2_1.3.2 isoband_0.2.4 #&gt; [21] sass_0.3.1 slam_0.1-48 scales_1.1.1 classInt_0.4-3 #&gt; [25] proxy_0.4-25 rappdirs_0.3.3 systemfonts_1.0.1 digest_0.6.27 #&gt; [29] svglite_2.0.0 pkgconfig_2.0.3 htmltools_0.5.1.1 parallelly_1.24.0 #&gt; [33] dbplyr_2.1.0 rlang_0.4.10 readxl_1.3.1 rstudioapi_0.13 #&gt; [37] jquerylib_0.1.3 generics_0.1.0 jsonlite_1.7.2 tokenizers_0.2.1 #&gt; [41] magrittr_2.0.1 Matrix_1.3-2 Rcpp_1.0.6 munsell_0.5.0 #&gt; [45] fansi_0.4.2 lifecycle_1.0.0 stringi_1.5.3 yaml_2.2.1 #&gt; [49] snakecase_0.11.0 grid_4.0.4 parallel_4.0.4 listenv_0.8.0 #&gt; [53] crayon_1.4.1 lattice_0.20-41 haven_2.3.1 hms_1.0.0 #&gt; [57] pillar_1.5.1 codetools_0.2-18 reprex_1.0.0 glue_1.4.2 #&gt; [61] evaluate_0.14 modelr_0.1.8 vctrs_0.3.6 cellranger_1.1.0 #&gt; [65] gtable_0.3.0 assertthat_0.2.1 xfun_0.22 broom_0.7.5 #&gt; [69] e1071_1.7-6 janeaustenr_0.1.5 class_7.3-18 viridisLite_0.3.0 #&gt; [73] globals_0.14.0 ellipsis_0.3.1 "],["introduction.html", "Chapter 1 Introduction 1.1 Hedonic price model", " Chapter 1 Introduction House prices can be modelled based on the structural characteristics of the house (e.g. age, size, building materials, floor level, etc.), their location (e.g. proximity to urban services, distance to Central Business District - CBD, accessibility, etc.), and the surrounding environment (e.g. neighbourhood services and socio-economic aspects of its inhabitants, leisure facilities, noise levels, etc.) (Chen and Hao (2008), Gultekin and Yamamura (2006)). We will focus our study in the socio-economic aspects of the neighbourhood and, in particular, in the migration structure (e.g. migration pressure, ethnic groups, ). 1.1 Hedonic price model The house prices can be defined by the following function (Chen and Hao (2008), Gultekin and Yamamura (2006)). \\[P_i = f(H_i, L_i, N_i) + \\epsilon \\] Where \\(f\\) represents the functional function in the hedonic model, P is the price of the house i, and \\(H_i\\), \\(L_i\\) and \\(N_i\\) are the vector of the structural characteristics, the location variables, and the neighbourhood characteristics of the house i, respectively. Finally, \\(\\epsilon\\) is the error term. 1.1.1 House characteristics We get the housing prices and the house properties from the Building and Dwelling Register (BBR). The dataset contains information about the building (e.g. building area, renovation year, etc.) and the residential unit (e.g. size, number of rooms, floor level, etc.). The data from residential units are unique for each dwelling, while some building characteristics are shared by several dwellings. We therefore merge both dataset for getting a dataset in which each row represents only one dwelling. There are data from 2006 to 2019. 1.1.2 Location characteristics OpenStreetMaps and kortforsyningen were used for getting the data about the urban services (e.g. public transport network, parks, ). Then, the interaction between those services and the house was modelled by potential models (Weber and Hirsch (2000), Gultekin and Yamamura (2006)), where the intensity of the interaction between the elements and the house is inversely proportional to the distance between them (Giraud and Commenges (2020)). \\[ p_i = \\sum_{j = i}^{n} M_i \\cdot f(d_{ij}) \\] Where \\(p_i\\) is the potential of the housing unit, \\(M_j\\) the mass of the service, and \\(f(d_{ij})\\) the negative function of the distance between the dwelling i and the service j. 1.1.3 Neighbourhood characteristics We have used the smallest administrative area of Denmark (i.e. parish) for evaluating the influence of the neighbourhoog characteristics on housing prices (Use also potential model here -&gt; e.g. locate the stock of migrant population on the centroid of each parish and get the interaction intensity in each house??). The following tables from the Denmark Statistics were used: SOGN10B: Disposable income for households by parish, price unit and income. SOGN05: Population (end November) by parish, socioeconomic status and sex SOGN07: Households disposal of vehicles by parish and use of cars (do you think it could be relevant? Do people think on parking issues when they buy a house?) KMSTA003: Summary vital statistics by parish and movements KMSTA001: Population 1. January by parish, ancestry and member of the National Church. VAN1AAR: Immigration (yearly) by municipality, sex, age, country of origin and citizenship Can we also have this dataset at parish level? "],["data.html", "Chapter 2 Data 2.1 Administrative units 2.2 BBR data 2.3 Population data 2.4 CORINE land use", " Chapter 2 Data 2.1 Administrative units The Denmarks Administrative Geographical Division (DAGI) has been used for obtaining the administrative boundaries of Denmark. In this sense, the country is divided in approx. 2200 parishes, 98 municipalities, 5 regions, 22 judicial districts, 12 police districts, 92 constituencies and approx. 1100 postcodes. However, we focused our study in the Copenhagen (KOMKODE = 0101) and Frederiksberg (KOMKODE = 0147) communes, and we get the statistics for neighbourhood characteristics from data at at parish level. ## Codes of the comunes under study (KOMKODE) study_area_codes &lt;- c(&quot;0101&quot;, &quot;0147&quot;) ## Communes polygons of Denmark, and select those in the study area commune_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;KOMMUNE.shp&quot;, sep = &quot;/&quot;) dk_commune &lt;- read_sf(commune_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) cph_commune &lt;- filter(dk_commune, KOMKODE %in% study_area_codes) ## Parishes polygons of Denmark, and select those in the study area parish_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_parish &lt;- read_sf(parish_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the study area dk_parish_cent &lt;- st_centroid(dk_parish) cph_parish_cent &lt;- st_intersection(dk_parish_cent, cph_commune) cph_parish &lt;- filter(dk_parish, SOGNEKODE %in% cph_parish_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) ## Contour of the study area (merge the parishes in one polygon): study_area &lt;- cph_parish %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) Some data have been aggregated to gird cells of 100 m x 100 m (i.e. population density), and thus we need to generate a grids over the study area: grids100m &lt;- study_area %&gt;% # Make regular grids (100m x 100m) st_make_grid(cellsize = 100) %&gt;% st_sf() %&gt;% # Name grids as &quot;g001&quot;, &quot;g002&quot;, ... mutate(grid_ID = paste0(&quot;g&quot;, stringr::str_pad(seq(1, nrow(.), 1), 3, pad = &quot;0&quot;))) 2.2 BBR data From the BBR dataset, we load all buildings for year-round living (BYG_ANVEND_KODE): 110 = Farmhouse for agricultural property. 120, 121, 122 = Detached single-family house (detached house). 130, 131, 132 = Townhouse, chain, or semi-detached house (vertical separation between the units). 140 = Multi-storey residential building (multi-family house, including two-family house (horizontal separation between the units). 150 = College. 160 = Residential building for residential institution. 190 = Second building for year-round living (NOT USED - VERY LOW NUMBER) ## Buildings for year round living res_codes &lt;- tribble (~BYG_ANVEND_KODE, ~type, 110, &quot;Farmhouse&quot;, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;, 150, &quot;College&quot;, 160, &quot;Residential institution&quot;, 190, &quot;Second building&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) ## Function for reading residential units from a csv file: # Read residential units from BBR data # Get read residential units in an area # @param file Link to OneDrive with the data (.csv format) # @param area Area where we would get the data (default = study_area) f_res_units &lt;- function(.file, .area = study_area) { fread(.file) %&gt;% # Convert to tibble as_tibble() %&gt;% # Select only Residential houses - Buildings for year-round living filter(ENH_ANVEND_KODE %in% res_codes$BYG_ANVEND_KODE) %&gt;% # Input empty cells (buildings with only one floor) in Etagebetegn as &quot;st&quot; mutate(Etagebetegn = ifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn), # Etagebetegn as ordened factor Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE), # Group floor levels with 5 or more floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join(res_codes, by = c(&quot;ENH_ANVEND_KODE&quot; = &quot;BYG_ANVEND_KODE&quot;)) %&gt;% # Convert to sf objects st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) %&gt;% # Get only points in the study area mutate(int = st_intersects(., .area) %&gt;% lengths &gt; 0) %&gt;% filter(int == TRUE) %&gt;% # Add year of the BBR dataset mutate(BBR_year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) } ## Load all csv files (one file for each year) in the same tibble with a column indicating the year of the dataset: # Load residential units # NOTE: you may need to change the path to OneDrive - Aalborg Universitet # Read all the data together OneDrive_link &lt;- &quot;C:/Users/FU53VP/OneDrive - Aalborg Universitet/BBR_2021/csv/&quot; csv_files_link &lt;- list.files(path = OneDrive_link, pattern = &quot;*.csv&quot;, full.names = TRUE) plan(multisession, workers = 3) res_units &lt;- future_map_dfr(.x = csv_files_link, .f = f_res_units) plan(&quot;default&quot;) 2.3 Population data Population data at parish level have been retrieved from Statistics Denmark using the R-package danstat. We have uploaded the following tables: KMSTA001: Population 1. January by parish, ancestry and National Church KMSTA003: Summary vital statistics by parish and movements We have created two auxiliary function for reading the data. steps loops by year for getting small pieces of information from the DST API and then putting all together in a data frame. In this sense, we overcome the limitation of the number of rows we can retrieve from the API (i.e. if we call a large dataset we get the error: Error: API did not return text/csv). Then, rm_words is used in the cleaning process for simplifying the description of some variables we would like to use as columns names. # Loop by year for getting DST data steps &lt;- function(year){ var_values &lt;- list(id_region, id_ancestry, year) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Remove punctuation, lowercase, stem, stopwords, and collapse strings rm_words &lt;- function(x, stopwords) { x %&gt;% strsplit(&quot; &quot;, fixed = TRUE) %&gt;% lapply(tm::removePunctuation) %&gt;% lapply(tolower) %&gt;% lapply(SnowballC::wordStem) %&gt;% lapply(function(x) x[!x %in% stopwords]) %&gt;% vapply(function(x) paste(x , collapse = &quot;_&quot;), character(1)) } The code needed for loading the tables are therefore: KMSTA001: id_table &lt;- &quot;KMSTA001&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;HERKOMST&quot;, &quot;Tid&quot;) # Values for var_input # Region: parishes of the study area (i.e. cph_parish) id_region &lt;- cph_parish$SOGNEKODE # Ancestry id_ancestry &lt;- NA # Quarters id_year &lt;- var_pop$values[[4]]$id # Select all years # Read data prsh_ances_dst &lt;- id_year %&gt;% future_map(steps) %&gt;% bind_rows() plan(&quot;default&quot;) # Clean data prsh_ances &lt;- prsh_ances_dst %&gt;% # Translate column names into English rename(parish = SOGN, ancestry = HERKOMST, date = TID, value = INDHOLD) %&gt;% # Get parish codes (first number of the string) mutate(prsh_id = stringr::str_extract(parish, &quot;[[:alnum:]]*&quot;)) %&gt;% # Remove the code from the string (prsh) mutate(parish = sub(&quot;[[:alnum:]]* &quot;, &quot;&quot;, parish)) %&gt;% # Get municipality (info inside the parenthesis) mutate(prsh_muni = stringr::str_extract(parish, &quot;(?&lt;=\\\\().*(?=\\\\))&quot;), prsh_muni = gsub(&quot; Municipality&quot;, &quot;&quot;, prsh_muni), # removes white space from start and end of string prsh_muni = stringr::str_trim(prsh_muni)) %&gt;% # Get parish name (outside parenthesis) mutate(prsh_name = stringr::str_extract(parish, &quot;(.*(?=\\\\())&quot;), prsh_name = stringr::str_trim(prsh_name)) %&gt;% # Remove duplicate info and order columns select(prsh_id, prsh_name, prsh_muni, date, ancestry, value) %&gt;% # Make shorter names in ancestry mutate(ancestry = case_when( ancestry == &quot;Persons of Danish origin&quot; ~ &quot;pop_dan&quot;, ancestry == &quot;Immigrants from western countries&quot; ~ &quot;pop_mi_wst&quot;, ancestry == &quot;Immigrants from non-western countries&quot; ~ &quot;pop_mi_nwst&quot;, ancestry == &quot;Descendants from western countries&quot; ~ &quot;pop_de_wst&quot;, ancestry == &quot;Descendants from non-western countries&quot; ~ &quot;pop_de_nwst&quot;), ancestry = factor(ancestry)) %&gt;% # Pivot (one row for peach parish and year) pivot_wider(names_from = ancestry, values_from = value) %&gt;% # Merge immigrants and their descendants (i.e. foreigners) mutate(pop_frgn_wst = pop_mi_wst + pop_de_wst, pop_frgn_nwst = pop_mi_nwst + pop_de_nwst) %&gt;% select(-c(pop_mi_wst, pop_de_wst, pop_mi_nwst, pop_de_nwst)) %&gt;% # Add column with total population mutate(pop_total = select(., starts_with(&quot;pop_&quot;)) %&gt;% rowSums()) KMSTA003: id_table &lt;- &quot;KMSTA003&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;KIRKEBEV&quot;, &quot;Tid&quot;) # Values for var_input # Region: all parish id_region &lt;- cph_parish$SOGNEKODE # Ancestry id_movements &lt;- NA # Quarters id_year &lt;- var_pop$values[[3]]$id # Select all years # Read data plan(multisession) prsh_stats_dst &lt;- id_year %&gt;% future_map(steps) %&gt;% bind_rows() plan(&quot;default&quot;) # Clean data prsh_stats &lt;- prsh_stats_dst %&gt;% # Translate column names into English rename(parish = SOGN, movements = KIRKEBEV, date = TID, value = INDHOLD) %&gt;% # Get parish codes (first number of the string) mutate(prsh_id = stringr::str_extract(parish, &quot;[[:alnum:]]*&quot;)) %&gt;% # Remove the code from the string (prsh) mutate(parish = sub(&quot;[[:alnum:]]* &quot;, &quot;&quot;, parish)) %&gt;% # Get municipality (info inside the parenthesis) mutate(prsh_muni = stringr::str_extract(parish, &quot;(?&lt;=\\\\().*(?=\\\\))&quot;), prsh_muni = gsub(&quot; Municipality&quot;, &quot;&quot;, prsh_muni), # removes white space from start and end of string prsh_muni = stringr::str_trim(prsh_muni)) %&gt;% # Get parish name (outside parenthesis) mutate(prsh_name = stringr::str_extract(parish, &quot;(.*(?=\\\\())&quot;), prsh_name = stringr::str_trim(prsh_name)) %&gt;% # remove duplicate info and order columns select(prsh_id, prsh_name, prsh_muni, date, movements, value) %&gt;% # Clean arguments in movements (remove punctuation, stop-words, stem, and collapse) mutate(movements = rm_words(movements, c(&quot;in&quot;, &quot;the&quot;, &quot;of&quot;))) %&gt;% # Pivot (one row for each parish and year) pivot_wider(names_from = movements, values_from = value) One we have the data we merge both dataset and add the spatial information (note that there are only summary statistics from 2015): ## Merge both tables in one: prsh_pop &lt;- prsh_ances %&gt;% full_join(prsh_stats) %&gt;% # remove rows with no summary data (summary data only from 2015 to 2020) filter(date &gt;= 2015, date &lt;= 2020) ## Add the spatial information: prsh_pop_sf &lt;- cph_parish %&gt;% rename(prsh_id = SOGNEKODE) %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(prsh_pop, by = c(&quot;prsh_id&quot;)) 2.4 CORINE land use Land use have been obtained from CORINE. We downloaded the data from kortforsyningen and used the data from 2010 (CLC12_DK.shp). ## Create a table with the CORINE land use codes from the EEA corine_code_link &lt;- &quot;https://www.eea.europa.eu/data-and-maps/data/corine-land-cover-2000-clc2000-250-m-version-9-2007/corine-land-cover-2000-classes-and-rgb-color-codes/clc2000legend.csv/at_download/file&quot; corine_code &lt;- read_csv(corine_code_link) %&gt;% mutate_if(is.numeric, as.character) ## Load shape fine dangeo_set_param() # Get local directory corine_link &lt;- paste(loc_dir, &quot;DK_CORINE_SHP_UTM32-WGS84&quot;, &quot;CLC12_DK.shp&quot;, sep = &quot;/&quot;) dk_corine &lt;- read_sf(corine_link) %&gt;% # Drop z dimension st_zm() %&gt;% # Transform coordinates st_transform(crs = &quot;EPSG:25832&quot;) %&gt;% # Add code description left_join(corine_code, by = c(&quot;CODE_12&quot; = &quot;CLC_CODE&quot;)) ## Select study area cph_corine &lt;- st_intersection(dk_corine, study_area) %&gt;% select(CODE_12, LABEL1, LABEL2, LABEL3 , RGB) %&gt;% janitor::clean_names() %&gt;% separate(rgb, c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;), sep = &quot;-&quot;) %&gt;% mutate(code_12 = as.numeric(code_12), hex_col = grDevices::rgb(red, green, blue, max = 255), hex_col = fct_reorder(hex_col, code_12), label3 = fct_reorder(label3, code_12)) %&gt;% st_sf() "],["exploratory-data-analysis.html", "Chapter 3 Exploratory Data Analysis 3.1 Residential units 3.2 Spatial distribution of residential units 3.3 Population density", " Chapter 3 Exploratory Data Analysis 3.1 Residential units We focused our study in residential dwellings and thus we selected the following building types from the BBS dataset (i.e. BYG_ANVEND_KODE): 120 - Fritliggende enfamiliehus (Detached single-family house); 121 - Sammenbygget enfamiliehus (Combined single-family house); 122 - Fritliggende enfamiliehus i tæt-lav bebyggelse (Detached single-family house in dense-low-rise buildings); 130 - (UDFASES) Række-, kæde-, eller dobbelthus (lodret adskillelse mellem enhederne) ((PHASE OUT) Row, chain, or semi-detached house (vertical separation between the units)); 131 - Række-, kæde- og klyngehus (Row, chain and cluster housing); 132 - Dobbelthus (Semi-detached house); 140 - Etagebolig-bygning, flerfamiliehus eller to-familiehus (Multi-storey residential building, multi-family house or two-family house); 190 - Anden bygning til helårsbeboelse (Second building for year-round living). Estimate the number of residential units in the study area. res_units %&gt;% # Convert to tibble as_tibble() %&gt;% # Summarize by type or residency and year group_by(type, BBR_year) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Arrange and add row with totals arrange(BBR_year, desc(n)) %&gt;% # Pivot pivot_wider(names_from = BBR_year, values_from = n) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% kbl() %&gt;% kable_paper(&quot;hover&quot;, full_width = F) type 2006 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 Multi-storey 342039 339414 339026 346921 337604 348503 366397 346650 345710 345296 342844 347799 353472 Single-family house 15403 15469 15480 15646 15771 15989 16064 15943 15842 15897 15914 15978 16042 College 12026 11388 11383 11306 11360 12977 12038 11921 11152 11175 11443 11446 11918 Semi-detached house 8625 8782 8612 8418 8959 8811 9771 9433 9649 10495 10531 10996 10440 Residential institution 404 517 405 397 551 451 455 482 453 479 415 435 458 Second building 334 376 337 382 342 409 339 335 340 333 329 329 326 Farmhouse 1 1 1 1 1 1 1 1 1 1 1 1 1 Total 378832 375947 375244 383071 374588 387141 405065 384765 383147 383676 381477 386984 392657 Residential units by floor level KL - basement ST - groundfloor 1 - 1st floor 2 - 2nd floor 3 - 3rd floor 4 - 4th floor 5 or more = etc. res_units %&gt;% as_tibble() %&gt;% group_by(floor_level, type) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # in percentage [%] mutate(perc = 100 * n / sum(n)) %&gt;% # Reorder type levels for plotting multi-storey first mutate(type = factor(type)) %&gt;% ggplot() + geom_bar(aes(y = floor_level, x = perc, fill = type), stat = &quot;identity&quot;) + labs(title = &quot;Residential units distribution by floor level&quot;, y = &quot;&quot;, x = &quot;Percentage [%]&quot;) + theme_bw() + theme(legend.position = &quot;bottom&quot;, legend.title = element_blank()) + guides(fill = guide_legend(ncol = 2)) + scale_x_continuous(labels = scales::comma) + scale_fill_manual(values = c(&quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;)) ggsave(filename = &quot;results/floor_levels_res_units.png&quot;) knitr::include_graphics(&quot;results/floor_levels_res_units.png&quot;) Figure 3.1: Residential units by floor levels Dwelling type codes Egentlig beboelse = Actual residence Blandet erhverv og beboelse = Mixed occupations and housing Enkeltværelse = Single room E. Andet (bl.a. institutioner og erhverv) = Other (including institutions and professions) res_units %&gt;% as_tibble() %&gt;% group_by(BOLIGTYPE_KODE, type) %&gt;% summarise(n = n()) #&gt; # A tibble: 24 x 3 #&gt; # Groups: BOLIGTYPE_KODE [6] #&gt; BOLIGTYPE_KODE type n #&gt; &lt;chr&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 &quot;&quot; Multi-storey 4 #&gt; 2 &quot;1&quot; College 68245 #&gt; 3 &quot;1&quot; Farmhouse 13 #&gt; 4 &quot;1&quot; Multi-storey 4411330 #&gt; 5 &quot;1&quot; Residential institution 52 #&gt; 6 &quot;1&quot; Second building 2534 #&gt; 7 &quot;1&quot; Semi-detached house 121853 #&gt; 8 &quot;1&quot; Single-family house 199739 #&gt; 9 &quot;2&quot; Multi-storey 14830 #&gt; 10 &quot;2&quot; Residential institution 11 #&gt; # ... with 14 more rows Unit area res_units %&gt;% as_tibble() %&gt;% filter(BEBO_ARL &lt; 0) #&gt; # A tibble: 131 x 42 #&gt; VEJ_NAVN HUS_NR Etagebetegn SIDE_DOERNR PostNr KomKode ESREjdNr Landsejerlavkode #&gt; &lt;chr&gt; &lt;chr&gt; &lt;ord&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Haregade 1 st &quot;&quot; 1320 101 8983 2000166 #&gt; 2 Ãlekistevej 221 st &quot;&quot; 2720 101 686264 2000177 #&gt; 3 Ãster Voldgade 12 3 &quot;&quot; 1350 101 671909 2000166 #&gt; 4 Humlehaven 64 st &quot;&quot; 2500 101 243540 2000180 #&gt; 5 SÃ¦byholmsvej 23 st &quot;&quot; 2500 101 553027 2000180 #&gt; 6 SolvÃ¦nget 10 st &quot;&quot; 2100 101 514862 2000173 #&gt; 7 Otto Busses Vej 12 st &quot;&quot; 2450 101 952940 2000174 #&gt; 8 Otto Busses Vej 10 st &quot;&quot; 2450 101 952940 2000174 #&gt; 9 Ãgerupvej 58 st &quot;&quot; 2700 101 678644 2000159 #&gt; 10 Herlufsholmvej 3 st &quot;&quot; 2720 101 221202 2000177 #&gt; # ... with 121 more rows, and 34 more variables: KomEjerlavKode &lt;int&gt;, MatrNr &lt;chr&gt;, #&gt; # BYG_ANVEND_KODE &lt;int&gt;, OPFOERELSE_AAR &lt;int&gt;, OMBYG_AAR &lt;int&gt;, YDERVAEG_KODE &lt;int&gt;, #&gt; # TAG_KODE &lt;int&gt;, BYG_ARL_SAML &lt;int&gt;, BYG_BOLIG_ARL_SAML &lt;int&gt;, ERHV_ARL_SAML &lt;int&gt;, #&gt; # BYG_BEBYG_ARL &lt;int&gt;, ETAGER_ANT &lt;int&gt;, ENH_ANVEND_KODE &lt;dbl&gt;, BOLIGTYPE_KODE &lt;chr&gt;, #&gt; # ENH_ARL_SAML &lt;int&gt;, BEBO_ARL &lt;int&gt;, ENH_ERHV_ARL &lt;int&gt;, VAERELSE_ANT &lt;int&gt;, #&gt; # ENERGI_KODE &lt;int&gt;, VAER_ERHV_ANT &lt;int&gt;, VARMEINSTAL_KODE &lt;int&gt;, OPVARMNING_KODE &lt;dbl&gt;, #&gt; # VARME_SUPPL_KODE &lt;int&gt;, EJD_VAERDI &lt;int64&gt;, GRUND_VAERDI &lt;int64&gt;, STUEHUS_VAERDI &lt;int&gt;, #&gt; # KONTANT_KOEBESUM &lt;int64&gt;, OVERDRAGELSES_KODE &lt;int&gt;, SKOEDE_DATO &lt;date&gt;, #&gt; # geometry &lt;POINT [m]&gt;, floor_level &lt;ord&gt;, type &lt;fct&gt;, int &lt;lgl&gt;, BBR_year &lt;dbl&gt; res_units %&gt;% as_tibble() %&gt;% filter(BEBO_ARL == 0) #&gt; # A tibble: 233 x 42 #&gt; VEJ_NAVN HUS_NR Etagebetegn SIDE_DOERNR PostNr KomKode ESREjdNr Landsejerlavkode #&gt; &lt;chr&gt; &lt;chr&gt; &lt;ord&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Olufsvej 6B 1 &quot;th&quot; 2100 101 420132 2000173 #&gt; 2 Betty Nansens Al~ 53 6 &quot;613&quot; 2000 147 241801 10051 #&gt; 3 Betty Nansens Al~ 53 7 &quot;713&quot; 2000 147 241801 10051 #&gt; 4 George Marshalls~ 13 st &quot;&quot; 2450 101 19878 2000174 #&gt; 5 H.C. Andersens B~ 13 3 &quot;tv&quot; 1553 101 24474 2000179 #&gt; 6 Falkoner Alle 114A st &quot;th&quot; 2000 147 31076 10051 #&gt; 7 Harrestrup AllÃ© 3 st &quot;&quot; 2500 101 210324 2000180 #&gt; 8 DybbÃ¸lsgade 49 2 &quot;&quot; 1721 101 414337 2000174 #&gt; 9 Sankt Hans Gade 19 1 &quot;tv&quot; 2200 101 485404 2000173 #&gt; 10 SakskÃ¸bingvej 8 st &quot;&quot; 2500 101 481905 2000180 #&gt; # ... with 223 more rows, and 34 more variables: KomEjerlavKode &lt;int&gt;, MatrNr &lt;chr&gt;, #&gt; # BYG_ANVEND_KODE &lt;int&gt;, OPFOERELSE_AAR &lt;int&gt;, OMBYG_AAR &lt;int&gt;, YDERVAEG_KODE &lt;int&gt;, #&gt; # TAG_KODE &lt;int&gt;, BYG_ARL_SAML &lt;int&gt;, BYG_BOLIG_ARL_SAML &lt;int&gt;, ERHV_ARL_SAML &lt;int&gt;, #&gt; # BYG_BEBYG_ARL &lt;int&gt;, ETAGER_ANT &lt;int&gt;, ENH_ANVEND_KODE &lt;dbl&gt;, BOLIGTYPE_KODE &lt;chr&gt;, #&gt; # ENH_ARL_SAML &lt;int&gt;, BEBO_ARL &lt;int&gt;, ENH_ERHV_ARL &lt;int&gt;, VAERELSE_ANT &lt;int&gt;, #&gt; # ENERGI_KODE &lt;int&gt;, VAER_ERHV_ANT &lt;int&gt;, VARMEINSTAL_KODE &lt;int&gt;, OPVARMNING_KODE &lt;dbl&gt;, #&gt; # VARME_SUPPL_KODE &lt;int&gt;, EJD_VAERDI &lt;int64&gt;, GRUND_VAERDI &lt;int64&gt;, STUEHUS_VAERDI &lt;int&gt;, #&gt; # KONTANT_KOEBESUM &lt;int64&gt;, OVERDRAGELSES_KODE &lt;int&gt;, SKOEDE_DATO &lt;date&gt;, #&gt; # geometry &lt;POINT [m]&gt;, floor_level &lt;ord&gt;, type &lt;fct&gt;, int &lt;lgl&gt;, BBR_year &lt;dbl&gt; res_units %&gt;% as_tibble() %&gt;% filter(BEBO_ARL &gt; 1000) #&gt; # A tibble: 321 x 42 #&gt; VEJ_NAVN HUS_NR Etagebetegn SIDE_DOERNR PostNr KomKode ESREjdNr Landsejerlavkode #&gt; &lt;chr&gt; &lt;chr&gt; &lt;ord&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Amalienborg Slot~ 7 st &quot;&quot; 1257 101 23028 2000167 #&gt; 2 Ottiliavej 3 1 &quot;&quot; 2500 101 173666 2000176 #&gt; 3 Rymarksvej 1 st &quot;&quot; 2900 101 474402 2000173 #&gt; 4 Ottiliavej 1 1 &quot;&quot; 2500 101 173666 2000176 #&gt; 5 HillerÃ¸dgade 64 st &quot;&quot; 2200 101 390594 2000175 #&gt; 6 Emdrupvej 138 st &quot;&quot; 2400 101 117707 2000156 #&gt; 7 Stockflethsvej 4 st &quot;&quot; 2000 147 116853 10051 #&gt; 8 Holmbladsgade 120 st &quot;&quot; 2300 101 403130 2000172 #&gt; 9 Sundholmsvej 20 st &quot;&quot; 2300 101 545334 2000155 #&gt; 10 Tuborgvej 181 st &quot;&quot; 2400 101 582825 2000156 #&gt; # ... with 311 more rows, and 34 more variables: KomEjerlavKode &lt;int&gt;, MatrNr &lt;chr&gt;, #&gt; # BYG_ANVEND_KODE &lt;int&gt;, OPFOERELSE_AAR &lt;int&gt;, OMBYG_AAR &lt;int&gt;, YDERVAEG_KODE &lt;int&gt;, #&gt; # TAG_KODE &lt;int&gt;, BYG_ARL_SAML &lt;int&gt;, BYG_BOLIG_ARL_SAML &lt;int&gt;, ERHV_ARL_SAML &lt;int&gt;, #&gt; # BYG_BEBYG_ARL &lt;int&gt;, ETAGER_ANT &lt;int&gt;, ENH_ANVEND_KODE &lt;dbl&gt;, BOLIGTYPE_KODE &lt;chr&gt;, #&gt; # ENH_ARL_SAML &lt;int&gt;, BEBO_ARL &lt;int&gt;, ENH_ERHV_ARL &lt;int&gt;, VAERELSE_ANT &lt;int&gt;, #&gt; # ENERGI_KODE &lt;int&gt;, VAER_ERHV_ANT &lt;int&gt;, VARMEINSTAL_KODE &lt;int&gt;, OPVARMNING_KODE &lt;dbl&gt;, #&gt; # VARME_SUPPL_KODE &lt;int&gt;, EJD_VAERDI &lt;int64&gt;, GRUND_VAERDI &lt;int64&gt;, STUEHUS_VAERDI &lt;int&gt;, #&gt; # KONTANT_KOEBESUM &lt;int64&gt;, OVERDRAGELSES_KODE &lt;int&gt;, SKOEDE_DATO &lt;date&gt;, #&gt; # geometry &lt;POINT [m]&gt;, floor_level &lt;ord&gt;, type &lt;fct&gt;, int &lt;lgl&gt;, BBR_year &lt;dbl&gt; 3.2 Spatial distribution of residential units Create a function for ploting 2D kernel density maps: f &lt;- function(.data) { .data %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_point(aes(X, Y), size = 0.02, shape = 16) + stat_density_2d(aes(X, Y, fill = ..level..), alpha = 0.5, h = 700, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = .data$type, x = &quot;&quot;, y = &quot;&quot;) } Plot of spatial distribution of residential units by type of use in 2019: p &lt;- res_units %&gt;% filter(BBR_year == 2019) %&gt;% group_split(type) %&gt;% map( ~ f(.)) wrap_plots(p) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(1.00, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) + plot_annotation(title = &quot;Residential units in 2019&quot;, theme = theme(plot.title = element_text(size = 14, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), plot.caption = element_text(size = 9, colour = &quot;grey25&quot;) ) ) ggsave(filename = &quot;results/Kernel_maps_builds_type_2021.png&quot;, width = 25, height = 20, units = &quot;cm&quot;) knitr::include_graphics(&quot;results/Kernel_maps_builds_type_2021.png&quot;) Figure 3.2: 2D kernel density map 3.3 Population density BBR data represent the situation at the begining of the given year. Therefore, when we link the BBR data with the population data, which also represent the situation at the first day of the year, we use the population of the same year (e.g. BBR data from 2019 and population data from 2019). 3.3.1 Choropleth by ancestry Plot population density at the last day of 2019 (first of 2010) by parish and ancestry. col &lt;- brewer.pal(9, &quot;YlGnBu&quot;) pal &lt;- colorRampPalette(col) my_pallette &lt;- pal(10) pop_dens_choropleth &lt;- prsh_pop_sf %&gt;% select(prsh_id, prsh_name, prsh_area_km2, date, pop_total, pop_dan, pop_frgn_wst, pop_frgn_nwst) %&gt;% filter(date == 2019) %&gt;% # Calulate population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * prsh_area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% as_tibble() %&gt;% pivot_longer(starts_with(&quot;pop_&quot;)) %&gt;% st_as_sf() %&gt;% mutate(name = factor(name, levels = c(&quot;pop_total_km2&quot;, &quot;pop_dan_km2&quot;, &quot;pop_frgn_wst_km2&quot;, &quot;pop_frgn_nwst_km2&quot;), labels = c(&quot;Total&quot;, &quot;Danish origin&quot;, &quot;Immigrants and their descendants from western countries&quot;, &quot;Immigrants and their descendants from non-western countries&quot;))) brks_c &lt;- c(min(pop_dens_choropleth$value), 1, 2, 4, 8, 12, 16, 20, 25, 30, ceiling(max(pop_dens_choropleth$value))) pop_dens_choropleth %&gt;% ggplot() + geom_sf(aes(fill = cut(value, breaks = brks_c, include.lowest = T)), color = &quot;grey50&quot;, size = 0.05) + scale_fill_manual(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), values = my_pallette, drop = FALSE, guide = guide_legend(reverse=TRUE)) + my_theme_map() + theme(plot.title = element_text(size = 12, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), strip.text = element_text(size = 9, color = &quot;black&quot;, face = &quot;italic&quot;)) + labs(title = &quot;Population density at the first dat of 2019&quot;, x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~ name) ggsave(filename = &quot;results/pop_density_2019_choropleth.png&quot;, width = 25, height = 20, units = &quot;cm&quot;) knitr::include_graphics(&quot;results/pop_density_2019_choropleth.png&quot;) Figure 3.3: Population density by parish (choropleth) 3.3.2 Disaggregating population data We disaggregate the population data at Parish level to grid cells of 100m x 100m using residential buildings as ancillary data. The procedure is as follow: We calculate the occupancy rate (OR) for the residential units of each parish (j): \\[OR_{j} = \\frac{pop_{j}}{N_{j}}\\] We make grid cells of 100m x 100m over the study area We select only the grids with residential units Detect to what parish (j) belong each grid (i). (Note that one grids may be in more that one parish) Calculate the number of dwellings per grid and parish (\\(N_{ij}\\)) Estimate the population in each grid (i) base the occupancy rate by parish (j): \\[pop_{gi} = \\sum_{j = 1}^{n}(OR_{j} \\cdot N_{ij})\\] Population density: \\[PD_{i} = \\frac{pop_{i}}{A_{i}}\\] Therefore we create the following function: #&#39; Calculate the population density in the grids created by f_grids #&#39; @param .pop POLYGONS with the population data (i.e. prsh_pop_sf) #&#39; @param .parish POLYGONS where the number of units will be calculated #&#39; @param .res_points POINTS with the residential units (e.g. res_units) #&#39; @param .grids Grid cells generated by f_grids #&#39; @param .year Year of the analysis f_pd_grids &lt;- function(.pop, .parish, .res_points, .grids, .year) { # Population at the last day of the year (.year) pop_year &lt;- .pop %&gt;% # Select population data at the first day of the quarter select(prsh_id, prsh_name, prsh_area_km2, date, pop_total, pop_dan, pop_frgn_wst, pop_frgn_nwst) %&gt;% # select the data at the end of the year (first dat of the next year) filter(date == (.year)) # BBR of the selected year (represent the last day of the year) BBR_year &lt;- filter(.res_points, BBR_year == .year) # Calculate occupancy rate (&quot;OR&quot;) of the residential units in each parish in a year OR &lt;- pop_year %&gt;% # number of units per parish mutate(n_units = st_intersects(., BBR_year, dist = 10) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # mean population per unit in each parish mutate(across(starts_with(&quot;pop&quot;), ~ . / n_units)) %&gt;% rename_with(~paste(.x, &quot;or&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # output as table as_tibble() %&gt;% select(-n_units, -geometry) # Get only the grids with residential units on them gru &lt;- .grids %&gt;% # Number of residential units per grid mutate(n_units = st_intersects(., BBR_year , dist = 10) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # Get grids with residential buildings filter(n_units &gt; 0) %&gt;% # Detect to what parish belong the grid st_intersection(., .parish ) %&gt;% # Remove parish area select(-prsh_area_km2, -SOGNENAVN) %&gt;% # convert to table as_tibble() # Population density by grids gru %&gt;% # Merge OR per parish left_join(OR, by = c(&quot;SOGNEKODE&quot; = &quot;prsh_id&quot;)) %&gt;% st_sf() %&gt;% # recalculate population by grid mutate(across(starts_with(&quot;pop&quot;), ~ . * n_units)) %&gt;% rename_with(~gsub(&quot;_or&quot;, &quot;&quot;, .), .col = starts_with(&quot;pop&quot;)) %&gt;% # sum population of each parish of the grid group_by(grid_ID) %&gt;% summarise(pop_total = sum(pop_total), pop_dan = sum(pop_dan), pop_frgn_wst = sum(pop_frgn_wst), pop_frgn_nwst = sum(pop_frgn_nwst), n_units = sum(n_units)) %&gt;% ungroup() %&gt;% # Area of the grid mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # Pivot longer as_tibble() %&gt;% pivot_longer(starts_with(&quot;pop_&quot;)) %&gt;% st_as_sf() %&gt;% # Remove polygons with 0 population filter(value &gt; 0) } Population in 2019 (at the first dat of the year) by grid cells of 100m x 100m and ancestry. pop_2019_g100m &lt;- f_pd_grids(.pop = prsh_pop_sf, .parish = cph_parish, .res_points = res_units, .grids = grids100m, .year = 2019) brks &lt;- c(min(pop_2019_g100m$value), 1, 2, 4, 8, 12, 16, 20, 25, 30, ceiling(max(pop_2019_g100m$value))) pop_2019_g100m %&gt;% mutate(name = factor(name, levels = c(&quot;pop_total_km2&quot;, &quot;pop_dan_km2&quot;, &quot;pop_frgn_wst_km2&quot;, &quot;pop_frgn_nwst_km2&quot;), labels = c(&quot;Total&quot;, &quot;Danish origin&quot;, &quot;Immigrants and their descendants from western countries&quot;, &quot;Immigrants and their descendants from non-western countries&quot;))) %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(aes(fill = cut(value, breaks = brks, include.lowest = T)), color = NA) + scale_fill_manual(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), values = my_pallette, drop = FALSE, guide = guide_legend(reverse = TRUE)) + my_theme_map() + theme(plot.title = element_text(size = 12, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), strip.text = element_text(size = 9, color = &quot;black&quot;, face = &quot;italic&quot;)) + labs(title = &quot;Population density at the first day of 2019&quot;, x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~ name) ggsave(filename = &quot;results/pop_dens_2019_grids_100m.png&quot;, width = 25, height = 20, units = &quot;cm&quot;) knitr::include_graphics(&quot;results/pop_dens_2019_grids_100m.png&quot;) Figure 3.4: Population density by grid cells of 100m x 100m 3.3.3 Population density WorldPop We can compare our results with the WorldPop total population estimation per grid-cell of 3 arc (approx. gri cells of 100m x 100m): dnk_ppp_2019_link &lt;- &quot;https://data.worldpop.org/GIS/Population/Global_2000_2020/2019/DNK/dnk_ppp_2019.tif&quot; dir.create(&quot;data&quot;) download.file(dnk_ppp_2019_link, &quot;data/dnk_ppp_2019.tif&quot;, method = &quot;curl&quot;) library(stars) library(tidyverse) dnk_ppp_2019 &lt;- read_stars(.x = &quot;data/dnk_ppp_2019.tif&quot;, proxy = TRUE) bbox &lt;- study_area %&gt;% st_transform(crs = st_crs(dnk_ppp_2019)) cph_ppp_2019 &lt;- st_crop(dnk_ppp_2019, bbox) %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) col &lt;- brewer.pal(9, &quot;YlGnBu&quot;) pal &lt;- colorRampPalette(col) my_pallette &lt;- pal(10) brks &lt;- c(min(cph_ppp_2019$dnk_ppp_2019.tif, na.rm = TRUE), 1, 2, 4, 8, 12, 16, 20, 25, 30, max(cph_ppp_2019$dnk_ppp_2019.tif, na.rm = TRUE)) cph_ppp_2019 &lt;- cph_ppp_2019 %&gt;% mutate( pop_cuts = cut(dnk_ppp_2019.tif, breaks = brks, include.lowest = T)) ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_stars(data = cph_ppp_2019, aes(fill = pop_cuts)) + scale_fill_manual(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), values = my_pallette, drop = FALSE, guide = guide_legend(reverse=TRUE)) + labs(title = &quot;Estimated total number of people per grid-cell of 3 arc&quot;, caption = &quot;Source: WorlpPop (https://data.worldpop.org)&quot;) + my_theme_map() ggsave(filename = &quot;results/pop_dens_2019_worldpop_100m.png&quot;, width = 20, height = 15, units = &quot;cm&quot;) knitr::include_graphics(&quot;results/pop_dens_2019_worldpop_100m.png&quot;) Figure 3.5: worldpop total population density estimations in 2019 3.3.4 Land use and residential units (CORINE) ggplot() + geom_sf(data = cph_corine, aes(fill = label3), color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = res_units, size = 0.02, shape = 16) + scale_fill_manual(name = &quot;Land use&quot;, values = levels(cph_corine$hex_col), drop = TRUE) + my_theme_map() + labs(title = &quot;Residential units and land use&quot;, x = &quot;&quot;, y = &quot;&quot;) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(1.80, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) ggsave(filename = &quot;results/land_use_corine.png&quot;, width = 25, height = 15, units = &quot;cm&quot;) knitr::include_graphics(&quot;results/land_use_corine.png&quot;) Figure 3.6: CORINE land use and residential units "],["references.html", "References", " References Chen, Jie, and Qianjin Hao. 2008. The impacts of distance to CBD on housing prices in Shanghai: a hedonic analysis. Journal of Chinese Economic and Business Studies 6 (3): 291302. https://doi.org/10.1080/14765280802283584. Giraud, Timothée, and Hadrien Commenges. 2020. potential: Implementation of the Potential Model. R Package Version 0.1.0. https://cran.r-project.org/package=potential. Gultekin, Bahadir, and Etsuo Yamamura. 2006. Potential and Network Analysis Application of Estimating Housing Prices in Northern District of Sapporo. Studies in Regional Science 35 (4): 1097107. https://doi.org/10.2457/srs.35.1097. Weber, Christiane, and Jacky Hirsch. 2000. Potential model application and planning issues. Cybergeo, no. 1995 (March). https://doi.org/10.4000/cybergeo.889. "]]
