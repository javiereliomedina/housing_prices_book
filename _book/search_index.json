[["index.html", "Housing prices Copenhagen Prerequisite Acknowledgements R session", " Housing prices Copenhagen Javier Elío, Marina Georgati, Henning S. Hansen, Frederik S. Hass, Carsten Keßler 2021-07-23 Prerequisite The data have been analysed with R (version 4.1.0) and Rstudio (version 1.4.1717), and the book has been created with bookdown package. The required packages are automatically checked and installed if needed from CRAN. # Create an auxiliary function for checking if a package is installed, # install it if it is not, and load the package # (based on https://gist.github.com/stevenworthington/3178163) ipak &lt;- function(pkg){ new_pkg &lt;- pkg[!(pkg %in% installed.packages()[, &quot;Package&quot;])] if (length(new_pkg)) install.packages(new_pkg, dependencies = TRUE, repos = &quot;http://cran.us.r-project.org&quot;) sapply(pkg, require, character.only = TRUE) } # List of packages pkg &lt;- c(&quot;animation&quot;, &quot;biscale&quot;, &quot;bit64&quot;, &quot;bookdown&quot;, &quot;data.table&quot;, &quot;danstat&quot;, &quot;dint&quot;, &quot;forcats&quot;, &quot;furrr&quot;, &quot;ggspatial&quot;, &quot;giscoR&quot;, &quot;gtsummary&quot;, &quot;gganimate&quot;, &quot;gifski&quot;, &quot;ggforce&quot;, &quot;janitor&quot;, &quot;kableExtra&quot;, &quot;knitr&quot;, &quot;latex2exp&quot;, &quot;mapview&quot;, &quot;osmextract&quot;, &quot;osrm&quot;, &quot;opentripplanner&quot;, &quot;patchwork&quot;, &quot;potential&quot;, &quot;rmarkdown&quot;, &quot;remotes&quot;, &quot;RColorBrewer&quot;, &quot;rappdirs&quot;, &quot;sf&quot;, &quot;stringr&quot;, &quot;SnowballC&quot;, &quot;stars&quot;, &quot;units&quot;, &quot;viridis&quot;, &quot;table1&quot;, &quot;tidyverse&quot;, &quot;tidytext&quot;, &quot;tidytable&quot;, &quot;tm&quot;, &quot;tools&quot;) # Check and install ipak(pkg) Furthermore, we have created our own package for downloading kortforsyningen data to a local repository directly from R (i.e. dangeo). The package can be downloaded from GitHub: # Install packages from GitHub if(!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) if (!require(&quot;dangeo&quot;)) remotes::install_github(&quot;javiereliomedina/dangeo&quot;) library(dangeo) if(!require(&quot;ggsflabel&quot;)) devtools::install_github(&quot;yutannihilation/ggsflabel&quot;) library(ggsflabel) if(!require(&quot;ggpyramid&quot;)) remotes::install_github(&quot;javiereliomedina/ggpyramid&quot;) library(ggpyramid) Although the kortforsyningen data are free, we would need to create a username and a password for getting access to them (you can make it here: Opret ny bruger). By default dangeo looks for credentials on .Renviron as: kortforsyningen_id = \"username\" and kortforsyningen_pwd = \"password\". You would need to save them with usethis::edit_r_environ(): # Set username and password # usethis::edit_r_environ() # Open .Renviron file, and save the username (kortforsyningen_id = &quot;your_username&quot;) and password (kortforsyningen_pwd = &quot;your_password&quot;) You would also need to define with dangeo_set_param() the local directory where the data are downloaded (loc_dir). It is defined as loc_dir = rappdirs::user_cache_dir(), although it can be changed loc_dir = ./your/local/path. The first time a file is downloaded with dangeo_get_data(), the process can be time consuming (there are some very big files). However, it will not be downloaded in subsequent calls if the files is already in the local directory (the dataset can be overwritten be setting overwrite = TRUE on dangeo_get_data()). Once we have our username and password, and we have define the local repository for the data, we can set them on our R-session: # Set local repository and password to kortforsyningen dangeo_set_param() Finally, the BBR data are storage in a OneDrive folder. You would need to have access to that folder, and save the path on .Renviron with usethis::edit_r_environ(). It has to be saved as OneDrive_BBR_path = \"your/OneDrive/BBR/path\". Acknowledgements This work has been financed by Aalborg University - AAU (Project: Global flows of migrants and their impact on north European welfare states - FLOW). The sole responsibility of this publication lies with the authors. AAU is not responsible for any use that may be made of the information contained therein. R session # R version 4.1.0 (2021-05-18) # Platform: x86_64-w64-mingw32/x64 (64-bit) # Running under: Windows 10 x64 (build 19042) # # Matrix products: default # # locale: # [1] LC_COLLATE=English_United Kingdom.1252 LC_CTYPE=English_United Kingdom.1252 # [3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C # [5] LC_TIME=English_United Kingdom.1252 # # attached base packages: # [1] tools stats graphics grDevices utils datasets methods base # # other attached packages: # [1] ggpyramid_0.0.0.9000 ggsflabel_0.0.1 dangeo_0.0.0.9000 # [4] devtools_2.4.2 usethis_2.0.1 tm_0.7-8 # [7] NLP_0.2-1 tidytable_0.6.3 tidytext_0.3.1 # [10] table1_1.4.2 viridis_0.6.1 viridisLite_0.4.0 # [13] units_0.7-2 stars_0.5-3 abind_1.4-5 # [16] SnowballC_0.7.0 rappdirs_0.3.3 RColorBrewer_1.1-2 # [19] remotes_2.4.0 rmarkdown_2.9 potential_0.1.0 # [22] patchwork_1.1.1 opentripplanner_0.3.1 osrm_3.4.1 # [25] osmextract_0.3.0 mapview_2.10.0 latex2exp_0.5.0 # [28] knitr_1.33 kableExtra_1.3.4 janitor_2.1.0 # [31] ggforce_0.3.3 gifski_1.4.3-1 gganimate_1.0.7 # [34] gtsummary_1.4.2 giscoR_0.2.4 ggspatial_1.1.5 # [37] furrr_0.2.3 future_1.21.0 dint_2.1.3 # [40] danstat_0.1.0 data.table_1.14.0 bookdown_0.22 # [43] bit64_4.0.5 bit_4.0.4 biscale_0.2.0 # [46] animation_2.6 sf_1.0-1 forcats_0.5.1 # [49] stringr_1.4.0 dplyr_1.0.7 purrr_0.3.4 # [52] readr_1.4.0 tidyr_1.1.3 tibble_3.1.2 # [55] ggplot2_3.3.5 tidyverse_1.3.0 # # loaded via a namespace (and not attached): # [1] readxl_1.3.1 backports_1.2.1 systemfonts_1.0.2 lwgeom_0.2-6 # [5] sp_1.4-5 splines_4.1.0 crosstalk_1.1.1 listenv_0.8.0 # [9] leaflet_2.0.4.1 digest_0.6.27 htmltools_0.5.1.1 fansi_0.5.0 # [13] memoise_2.0.0 magrittr_2.0.1 globals_0.14.0 modelr_0.1.8 # [17] matrixStats_0.59.0 svglite_2.0.0 prettyunits_1.1.1 colorspace_2.0-2 # [21] rvest_1.0.0 ggrepel_0.9.1 haven_2.4.1 xfun_0.24 # [25] leafem_0.1.6 callr_3.7.0 crayon_1.4.1 jsonlite_1.7.2 # [29] survival_3.2-11 glue_1.4.2 polyclip_1.10-0 gtable_0.3.0 # [33] webshot_0.5.2 pkgbuild_1.2.0 scales_1.1.1 DBI_1.1.1 # [37] Rcpp_1.0.7 isoband_0.2.5 progress_1.2.2 proxy_0.4-26 # [41] Formula_1.2-4 stats4_4.1.0 htmlwidgets_1.5.3 httr_1.4.2 # [45] ellipsis_0.3.2 pkgconfig_2.0.3 farver_2.1.0 sass_0.4.0 # [49] dbplyr_2.1.1 utf8_1.2.1 tidyselect_1.1.1 rlang_0.4.11 # [53] cachem_1.0.5 munsell_0.5.0 cellranger_1.1.0 cli_3.0.1 # [57] generics_0.1.0 broom_0.7.8 fastmap_1.1.0 evaluate_0.14 # [61] yaml_2.2.1 processx_3.5.2 fs_1.5.0 satellite_1.0.2 # [65] slam_0.1-48 xml2_1.3.2 tokenizers_0.2.1 compiler_4.1.0 # [69] rstudioapi_0.13 png_0.1-7 testthat_3.0.4 e1071_1.7-7 # [73] gt_0.3.0 reprex_2.0.0 broom.helpers_1.3.0 tweenr_1.0.2 # [77] bslib_0.2.5.1 stringi_1.6.2 ps_1.6.0 desc_1.3.0 # [81] lattice_0.20-44 Matrix_1.3-4 classInt_0.4-3 vctrs_0.3.8 # [85] pillar_1.6.1 lifecycle_1.0.0 jquerylib_0.1.4 raster_3.4-13 # [89] R6_2.5.0 KernSmooth_2.23-20 gridExtra_2.3 janeaustenr_0.1.5 # [93] parallelly_1.27.0 sessioninfo_1.1.1 codetools_0.2-18 pkgload_1.2.1 # [97] MASS_7.3-54 assertthat_0.2.1 rprojroot_2.0.2 withr_2.4.2 # [101] parallel_4.1.0 hms_1.1.0 grid_4.1.0 class_7.3-19 # [105] snakecase_0.11.0 lubridate_1.7.10 base64enc_0.1-3 "],["intro.html", "Chapter 1 Population growth, migration and house prices", " Chapter 1 Population growth, migration and house prices Migration and housing prices are closely related with profound implications on urban planning. In this sense, there is a two-way causal relationship between migration and house prices (e.g. Lin et al. (2018), Jeanty, Partridge, and Irwin (2010)). On the one hand, a rise on house prices will increase households housing equity and, therefore, homeowners would have a higher financial flexibility for purchasing a new house. On the other hand, high housing prices can make the house unaffordable. Prices differences between the region where migrants live and regions where they intend to move may also affect in- and out- migration rates. Finally, the expectation of future house prices also plays an important role in the decision to move (Peng and Tsai (2019)). Furthermore, migration increases the housing demand and, as a consequence, the prices (Wang, Hui, and Sun (2017)). An example of this effect has been found in Sweden where a 1% increase in the foreign-born population results in a 0.8% increase in house prices, which increases to 1.2% if internal migration is also accounted for (Tyrcha and Abreu (2019)). We analyse therefore housing prices, population and migration patterns in Denmark, evaluating the influence of housing prices on migration (and vice versa). Specific questions we will respond are, among others: How have housing prices changed over time in Denmark? How does it affect mobility and the population of a region? What is the effect of immigration on housing prices? What is the percentage of immigrants that own/rent a property? Is there racial segregation of immigrants? How does it affect mobility? Do the developments of housing prices in areas with significantly higher (or lower) representation of immigrants differ from the developments in nearby areas? If there is an effect, does it differ depending on the immigrants country of origin? References "],["level-muni.html", "Chapter 2 Analysis at national level (municipalities) 2.1 Population growth 2.2 Housing prices level", " Chapter 2 Analysis at national level (municipalities) 2.1 Population growth Danish population has growth over the last decade from 5.47 million (2008-Q1) to 5.82 million (2020-Q3). However, this increase is mainly due to foreign population. In this sense, the foreigners have raised from 0.30 million to 0.53 million (80%) while Danish citizens has growth from 5.18 million to 5.29 million (2.5%). Therefore, from the increase of almost 350,000 inhabitants over the last decade approximately 66% are immigrants. The population is also getting older with an increase of both the mean and median age of the population. However, there is a significant difference between the mean and median ages of Danish and Foreign citizens, with these values around 40-42 years and 32-34 years respectively. Furthermore, these values have raised for the Danish population but not for foreigners. Another consideration is that the mean age for Danish citizens is less than the median, which indicates that the distribution is skewed to the left (i.e. more elderly people), However, for the foreign population it is the other way around (i.e. the majority are young people). start_year &lt;- 2004 # First year with BBR data end_year &lt;- 2020 # Last year with BBR data # Load population data by citizenship and age (208Q1 - [end_year]Q1) # Metadata table of interest (e.g. KMSTA001) var_pop &lt;- get_table_metadata(table_id = &quot;FOLK1D&quot;, variables_only = TRUE) # Variables we would like to get data years_val &lt;- paste0(rep(seq(2008, end_year, 1), each = 4), paste0(&quot;K&quot;, 1:4)) var_input &lt;- list(list(code = &quot;OMRÅDE&quot;, values = &quot;000&quot;), list(code = &quot;KØN&quot;, values = c(1,2)), list(code = &quot;ALDER&quot;, values = seq(0, 125, 1)), list(code = &quot;STATSB&quot;, values = c(&quot;DANSK&quot;, &quot;UDLAND&quot;)), list(code = &quot;tid&quot;, values = years_val)) # Get data pop_ctzn_age &lt;- get_data(&quot;FOLK1D&quot;, variables = var_input) %&gt;% rename(Country = OMRÅDE, Gender = KØN, Age = ALDER, Citizen = STATSB, Year = TID, Pop = INDHOLD) %&gt;% mutate(Country = &quot;Denmark&quot;, Citizen = case_when(Citizen == &quot;Danish citizen&quot; ~ &quot;Danish&quot;, Citizen == &quot;Foreign citizen&quot; ~ &quot;Foreign&quot;), Date = gsub(&quot;Q&quot;, &quot;&quot;, Year), Date = as.integer(Date), Date = as_date_yq(Date), Date = first_of_quarter(Date)) %&gt;% separate(Year, c(&quot;Year&quot;, &quot;Quarter&quot;), sep = &quot;Q&quot;) %&gt;% mutate(Year = as.integer(Year), Quarter = as.integer(Quarter)) %&gt;% mutate(Age = parse_number(Age), Age = as.integer(Age)) %&gt;% # Add rows with total pop by age pivot_wider(names_from = &quot;Citizen&quot;, values_from = c(&quot;Pop&quot;)) %&gt;% mutate(Total = Danish + Foreign) %&gt;% pivot_longer(cols = c(Danish, Foreign, Total), names_to = &quot;Citizen&quot;, values_to = &quot;Pop&quot;) %&gt;% # Add population in percentage (%) group_by(Date) %&gt;% mutate(Pop_per = 100 * Pop / sum(Pop)) %&gt;% ungroup() # Total population by quarter and citizenship pop_ctzn_ttl_quarter &lt;- pop_ctzn_age %&gt;% group_by(Date, Citizen) %&gt;% # Add summary statistics (mean and median age) summarise(Pop_total = sum(Pop), Age_mean = weighted.mean(Age, Pop), Age_median = matrixStats::weightedMedian(Age, Pop)) %&gt;% ungroup() %&gt;% # Standardize it to % change with 2008-Q1 as baseline group_by(Citizen) %&gt;% arrange(Date, Citizen) %&gt;% mutate(pct_change_2008 = (Pop_total/first(Pop_total) - 1) * 100) %&gt;% ungroup() # Plot p1 &lt;- ggplot() + geom_line(data = pop_ctzn_ttl_quarter, aes(x = Date, y = Pop_total/1000, col = Citizen)) + labs(title = &quot;Danish population (2008 - 2020)&quot;, subtitle = &quot;Total population&quot;, y = &quot;x1000&quot;) + theme_bw() p2 &lt;- ggplot() + geom_line(data = pop_ctzn_ttl_quarter, aes(x = Date, y = pct_change_2008, col = Citizen)) + labs(title = &quot;&quot;, subtitle = &quot;Percentage of change&quot;, y = &quot;%&quot;) + theme_bw() p3 &lt;- ggplot() + geom_line(data = pop_ctzn_ttl_quarter, aes(x = Date, y = Age_median, colour = Citizen, linetype = &quot;Median&quot;)) + geom_line(data = pop_ctzn_ttl_quarter, aes(x = Date, y = Age_mean, colour = Citizen, linetype = &quot;Mean&quot;)) + scale_linetype_discrete(name = &quot;Age&quot;) + labs(title = &quot;&quot;, subtitle = &quot;Age variation&quot;, y = &quot;Age&quot;) + theme_bw() p1 + p2 + p3 Figure 2.1: Danish population from 2008-2020 The population pyramid also confirms this tendency (figure 2.2). We can see an increase of the percentage of the old dependency people (i.e. &gt; 65 years old), while the percentages of young people (&lt;18 years) has been reduced (lower birth rate with time). Foreign citizens have also increases, with the majority in the economically active region (i.e. 25-35 years old). The bulge in this region may indicate a period of immigration and/or a baby boom years before. The number of young people in this population has also increased, in comparison to the first day of 2008 (Is it due to a high birth rate among foreigner and/or because migrants came to Denmark with their family/children?). However, we see a narrow shape at the top of the curve, which indicate that low proportion of foreigners get older in Denmark. A narrow shape usually means high death rates in the population; however, it is not plausible in Denmark and it may be more reasonable to think that migrants return to their countries after retirement. # Load population data by ancestry and age (5 years) in DK # Metadata table of interest (e.g. FOLK1C) id_table &lt;- &quot;FOLK1C&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Loop by quarter for getting the data steps &lt;- function(quarter){ var_values &lt;- list(id_region, id_gender, id_age, id_ancestry, id_citizen, quarter) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Codes for var_input var_codes &lt;- c(&quot;OMRÅDE&quot;, &quot;KØN&quot;, &quot;ALDER&quot;, &quot;HERKOMST&quot;, &quot;IELAND&quot;, &quot;Tid&quot;) # Values for var_input ## All regions id_region &lt;- &quot;000&quot; ## Gender: Men/Women id_gender &lt;- c(1, 2) ## Age (remove total) id_age &lt;- subset(var_pop$values[[3]], id != &quot;IALT&quot;)$id ## Ancestry id_ancestry &lt;- c(5, 4, 3) ## country of origin (remove total) id_citizen &lt;- as.numeric(var_pop$values[[5]]$id) id_citizen &lt;- id_citizen[id_citizen &gt; 0] ## Quarters (e.g. 2008-Q1 and 2019-Q1) id_quarter &lt;- years_val # Get data (in parallel) plan(multisession, workers = 7) pop_DK &lt;- id_quarter %&gt;% future_map_dfr(steps) %&gt;% filter(INDHOLD &gt; 0) %&gt;% # Translate column names to English rename(region = OMRÅDE, gender = KØN, age = ALDER, ancestry = HERKOMST, origin = IELAND, date = TID, pop = INDHOLD) %&gt;% # First day of the quarter mutate(date = gsub(&quot;Q&quot;, &quot;&quot;, date), date = as_date_yq(as.integer(date)), date = first_of_quarter(date)) %&gt;% mutate(region = ifelse(region == &quot;All Denmark&quot;, &quot;Denmark&quot;, NA)) %&gt;% # Format ancestry mutate(ancestry = ifelse(ancestry == &quot;Persons of Danish origin&quot;, &quot;Danish&quot;, ancestry), ancestry = factor(ancestry), ancestry = fct_relevel(ancestry, &quot;Immigrants&quot;, after = 1)) %&gt;% # Format &quot;age&quot; mutate(age = ifelse(age == &quot;100 years and over&quot;, &quot;100OV&quot;, age), age = gsub(&quot; years&quot;, &quot;&quot;, age), age = factor(age, levels = id_age)) %&gt;% # Calculate population in percentage group_by(date) %&gt;% mutate(pop_per = 100 * pop / sum(pop)) %&gt;% ungroup() plan(&quot;default&quot;) # Plot population pyramid brks_y &lt;- seq(-4, 4, 1) lmts_y = c(min(brks_y), max(brks_y)) lbls_y &lt;- paste0(as.character(abs(brks_y)), &quot;%&quot;) pop_DK %&gt;% filter(date == &quot;2008-01-01&quot; | date == last(pop_DK$date)) %&gt;% ggpyramid(values = pop_per, fill = ancestry) + scale_fill_manual(name = &quot;Ancestry&quot;, values = c(&quot;#0072B2&quot;, &quot;#F0E442&quot;, &quot;#D55E00&quot;)) + scale_y_continuous(name = NULL, breaks = brks_y, labels = lbls_y, limits = lmts_y) + labs(caption = &quot;Source: Statistics Denmark&quot;) + geom_segment(data = filter(pop_DK, date == &quot;2008-01-01&quot; | date == last(pop_DK$date)), aes(x = 4, xend = 4, y = -4, yend = 4), linetype = &quot;dashed&quot;) + geom_segment(data = filter(pop_DK, date == &quot;2008-01-01&quot; | date == last(pop_DK$date)), aes(x = 13.5, xend = 13.5, y = -4, yend = 4), linetype = &quot;dashed&quot;) + ggplot2::annotate(geom = &quot;text&quot;, y = c(2 , 2), x = 20.5, label = &quot;Women&quot;, fontface = &quot;bold&quot;, size = 3) + ggplot2:::annotate(geom = &quot;text&quot;, y = c(-2,-2), x = 20.5, label = &quot;Men&quot;, fontface = &quot;bold&quot;, size = 3) + facet_wrap(~date) + theme_bw() Figure 2.2: Population pyramith of Denmark The urban areas (e.g. Copenhagn, Aalborg, Aarhus, Odese) have gained population from 2008 to 2020, while the rural regions have loss them (e.g. Lolland, Lemvig). It seems also that there are some influence from big cities, and people are moving from the rural areas into (or close to) the cities (figure 2.3). However, we do not see the same patter between the Danes and Immigrants and the number of immigrants and their descendants has increased all aver the country (figure 2.4), alleviating the population loss on rural areas. To what degree migrants and their descendants make up for the population loss in Danes without a migrant background over time? e.g. Do the Danes leave first and the migrants fill the gap? The majority of immigrants however live in big cities (Figure 5). Are there differences between migrants in urban-rural areas (e.g. skilled/non-skilled migrants due to job marked)? Are the Danish people in rural areas (red areas) older (e.g. young people are moving to the cities but elderly people stay there)? Are immigrants however young workers? Are these areas loosing population because low birth rates/high death? Low in-migration? # Download DAGI (scale 1:10000) dangeo_get_data(ftp_folder = &quot;landinddelinger/dagi/SHAPE&quot;, zip_name = &quot;DAGIREF_SHAPE_UTM32-EUREF89.zip&quot;) # Municipalities (get from DAGI) muni_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;KOMMUNE.shp&quot;, sep = &quot;/&quot;) dk_muni &lt;- read_sf(muni_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) %&gt;% select(KOMKODE, KOMNAVN) %&gt;% rename(muni_id = KOMKODE, muni_name = KOMNAVN) %&gt;% group_by(muni_id, muni_name) %&gt;% summarise(geometry = sf::st_union(geometry)) %&gt;% ungroup() %&gt;% # Calculate the area of each municipalitie (km2) mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) # Big cities/urban areas big_cities &lt;- c(&quot;København&quot;, &quot;Aarhus&quot;, &quot;Odense&quot;, &quot;Aalborg&quot;) big_cities &lt;- dk_muni %&gt;% filter(muni_name %in% big_cities) # Load population data by ancestry and municipalities # Metadata table of interest (e.g. FOLK1C) id_table &lt;- &quot;FOLK1C&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # loop by quarter for getting the data steps &lt;- function(quarter){ var_values &lt;- list(id_region, id_ancestry, quarter) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Codes for var_input var_codes &lt;- c(&quot;OMRÅDE&quot;, &quot;HERKOMST&quot;, &quot;Tid&quot;) # Values for var_input ## Region: Denmark id_region &lt;- as.numeric(var_pop$values[[1]]$id) id_region &lt;- id_region[id_region &gt; 100] ## Ancestry id_ancestry &lt;- NA ## Quarters id_quarter &lt;- years_val # Select all quarters # Parallel process with {future} plan(multisession) pop_muni &lt;- id_quarter %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean column names and format some data pop_muni &lt;- pop_muni %&gt;% # Translate column names into English rename(muni_name = OMRÅDE, ancestry = HERKOMST, date = TID, pop = INDHOLD) %&gt;% # First day of the quarter mutate(date = gsub(&quot;Q&quot;, &quot;&quot;, date), date = as_date_yq(as.integer(date)), date = first_of_quarter(date)) %&gt;% # Translate København (muni_name) and short Danes in ancestry mutate(muni_name = gsub(&quot;Copenhagen&quot;, &quot;København&quot;, muni_name), ancestry = ifelse(ancestry == &quot;Persons of Danish origin&quot;, &quot;Danish&quot;, ancestry)) %&gt;% # Short municipalities by Total population in 20208-Q1 pivot_wider(c(muni_name, date), names_from = ancestry, values_from = pop) %&gt;% mutate(muni_name = factor(muni_name), muni_name = fct_reorder2(muni_name, date, Total, .fun = first2)) %&gt;% pivot_longer(cols = c(Total, Danish, Immigrants, Descendant), names_to = &quot;ancestry&quot;, values_to = &quot;pop&quot;) %&gt;% # Merge Immigrants and Descendants pivot_wider(names_from = ancestry, values_from = pop) %&gt;% mutate(Foreign = Immigrants + Descendant) %&gt;% select(-Immigrants, -Descendant) %&gt;% pivot_longer(-c(muni_name, date), names_to = &quot;ancestry&quot;, values_to = &quot;pop&quot;) %&gt;% # Sort ancestry mutate(ancestry = factor(ancestry, levels = c(&quot;Danish&quot;, &quot;Foreign&quot;, &quot;Total&quot;), labels = c(&quot;Danish&quot;, &quot;Foreign&quot;, &quot;Total&quot;))) %&gt;% # Population growth (inhabitant and percentage) using 2008-Q1 as baseline group_by(muni_name, ancestry) %&gt;% arrange(muni_name, date) %&gt;% mutate(pop_dif_2008 = pop - first(pop), pop_pct_2008 = (pop/first(pop) - 1) * 100) %&gt;% ungroup() # Link population and municipalities dk_muni_pop &lt;- dk_muni %&gt;% left_join(pop_muni, by = &quot;muni_name&quot;) %&gt;% st_as_sf() %&gt;% mutate(date = as.Date(date)) %&gt;% # population density mutate(pop_km2 = pop/area_km2) ggplot() + geom_sf(data = filter(dk_muni_pop, date == as.Date(last(dk_muni_pop$date)), ancestry == &quot;Total&quot;), aes(fill = pop_pct_2008), color = &quot;grey50&quot;, size = 0.05) + scale_fill_gradient2(name = &quot;Change [%]&quot;, low = &quot;blue&quot;, mid = &quot;white&quot;, high = &quot;red&quot;, midpoint = 0) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_void() + # ylim(54.50, 58.0) + geom_sf_label_repel(data = big_cities, aes(label = muni_name), nudge_y = 100000, nudge_x = 80000) Figure 2.3: Total population growth from 2008 to 2020 dk_muni_pop_last &lt;- dk_muni_pop %&gt;% filter(date == as.Date(last(dk_muni_pop$date)), ancestry != &quot;Total&quot;) # Transform Percentage of change to factor pct_breaks &lt;- c(floor(min(dk_muni_pop_last$pop_pct_2008)), -10, -5, 0, 5, 10, 20, 30, 50, 100, 150, max(dk_muni_pop_last$pop_pct_2008)) dk_muni_pop_last &lt;- dk_muni_pop_last %&gt;% mutate(pop_pct_2008_brk = cut(dk_muni_pop_last$pop_pct_2008, breaks = pct_breaks)) # Colour palette myPalette &lt;- c(rev(brewer.pal(3, &quot;Blues&quot;)), brewer.pal(9, &quot;YlOrRd&quot;)) # Plot by ancestry ggplot() + geom_sf(data = dk_muni_pop_last, aes(fill = pop_pct_2008_brk), color = NA) + scale_fill_manual(name = &quot;Percentage&quot;, values = myPalette, drop = FALSE) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_void() + facet_wrap( ~ ancestry, ncol = 2) Figure 2.4: Population growth from 2008 to 2019 by ancestry Population change pop_muni %&gt;% ggplot(aes(x = date, y = pop_dif_2008/1000, colour = ancestry)) + geom_line( ) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;, color = &quot;grey&quot;, size = 0.5) + facet_wrap(~muni_name, ncol = 6, scale = &quot;free&quot;) + theme_bw() + theme(legend.position = &quot;bottom&quot;, axis.text = element_text(size = 10), axis.title = element_text(size = 14), legend.text = element_text(size = 14), legend.title = element_text(size = 14, face = &quot;bold&quot;), plot.title = element_text(size = 14, face = &quot;bold&quot;), title = element_text(size = 14)) + scale_y_continuous(name = &quot;[x1000]&quot;) + scale_x_date(name = &quot;&quot;, date_breaks = &quot;3 year&quot;, date_labels = &quot;%y&quot;) + scale_colour_manual(name = &quot;Ancestry&quot;, values = c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#000000&quot;)) Figure 2.5: Population change from 2008 (municipalitiess are shorted by the total population in 2020) The total number of immigrants and their descendants living in Denmark at the first day of the four quarter of 2020 is 814.5k. From them, Copenhagen accounts for approximately 20% (164k), and then another 20% lives in Aarhus (60k), Odense (34k), Aalborg (24k), Frederiksberg (20k), and Vejle (15.7k). # Load data ---- #&#39; Data from Statistic Denmark: https://www.statbank.dk/10021 #&#39; Table: FOLK1C #&#39; Population at the first day of the quarter by region, ancestry, and country of origin #&#39; Subjects of interest: population and elections (02) #&#39; Immigrants and their descendants (2402) id_table &lt;- &quot;FOLK1C&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # loop by quarter for getting the data steps &lt;- function(quarter){ var_values &lt;- list(id_region, id_ancestry, id_citizen, quarter) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Codes for var_input var_codes &lt;- c(&quot;OMRÅDE&quot;, &quot;HERKOMST&quot;, &quot;IELAND&quot;, &quot;Tid&quot;) # Values for var_input ## Region: Denmark id_region &lt;- NA ## Ancestry (Immigrants and Descendant) id_ancestry &lt;- c(4, 3) ## Country of origin (remove total) id_citizen &lt;- as.numeric(var_pop$values[[5]]$id) id_citizen &lt;- id_citizen[id_citizen &gt; 0] ## Quarters id_quarter &lt;- years_val # Parallel process with {future} plan(multisession) pop_migr &lt;- id_quarter %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean column names and format some data pop_migr &lt;- pop_migr %&gt;% # Translate column names into English rename(muni_name = OMRÅDE, ancestry = HERKOMST, origin = IELAND, date = TID, pop = INDHOLD) %&gt;% # Translate Copenhagen mutate(muni_name = gsub(&quot;Copenhagen&quot;, &quot;København&quot;, muni_name)) %&gt;% # First day of the quarter mutate(date = gsub(&quot;Q&quot;, &quot;&quot;, date), date = as_date_yq(as.integer(date)), date = first_of_quarter(date)) %&gt;% # Total Immigrants and Descendants by muni_name, date, and country of origin pivot_wider(c(muni_name, origin, date), names_from = ancestry, values_from = pop) %&gt;% mutate(Total = Immigrants + Descendant) %&gt;% pivot_longer(cols = c(Immigrants, Descendant, Total), values_to = &quot;pop&quot;, names_to = &quot;ancestry&quot;) # Top 10 origin countries in Denmark (in 2020) pop_migr_top10_last &lt;- pop_migr %&gt;% filter(muni_name == &quot;All Denmark&quot;, date == as.Date(last(pop_migr$date)), ancestry == &quot;Total&quot;) %&gt;% slice_max(pop, n = 10) # Evolution of the top 10 countries over the years (since 2008) pop_migr_top10 &lt;- pop_migr %&gt;% filter(muni_name == &quot;All Denmark&quot;, origin %in% pop_migr_top10_last$origin) %&gt;% # Reorder factors (shorted by Total population in 2019-q1) pivot_wider(c(origin, date), names_from = ancestry, values_from = pop) %&gt;% mutate(origin = factor(origin), origin = fct_reorder2(origin, date, Total)) %&gt;% # Long format pivot_longer(cols = c(Immigrants, Descendant, Total), names_to = &quot;ancestry&quot;, values_to = &quot;pop&quot;) # Total p1 &lt;- pop_migr_top10 %&gt;% filter(ancestry == &quot;Total&quot;) %&gt;% ggplot() + geom_line(aes(x = date, y = pop/1000, colour = origin)) + theme_bw() + labs(subtitle = &quot;Totan population&quot;, y = &quot;Pop [x1000]&quot;, x = &quot;&quot;) + scale_color_brewer(name = &quot;Country of\\norigin&quot;, palette = &quot;Paired&quot;) # Immigrants and Descendants p2 &lt;- pop_migr_top10 %&gt;% filter(ancestry != &quot;Total&quot;) %&gt;% mutate(ancestry = factor(ancestry, levels = c(&quot;Immigrants&quot;,&quot;Descendant&quot;))) %&gt;% ggplot() + geom_line(aes(x = date, y = pop/1000, colour = origin)) + facet_grid(~ancestry) + theme_bw() + labs(subtitle = &quot;Divided by immigrants and their descendants&quot;, y = &quot;Pop [x1000]&quot;, x = &quot;&quot;) + scale_color_brewer(name = &quot;Country of\\norigin&quot;, palette = &quot;Paired&quot;) p1 / p2 + plot_layout(guides = &quot;collect&quot;) Figure 2.6: Evolution of the immigration population from the top-10 countries of origin in 2020 # Plot spatial situation in 2020 pop_migr_muni_last &lt;- dk_muni %&gt;% left_join(filter(pop_migr, date == as.Date(last(pop_migr$date)), ancestry == &quot;Total&quot;), by = &quot;muni_name&quot;) %&gt;% st_as_sf() # Total foreign population by muni (and percentage over the total migrants) # Binds represent the same percentage of population (~20%) cumsum__breaks &lt;- c(0, 20, 40, 60, 80, 100) pop_migr_total &lt;- pop_migr_muni_last %&gt;% group_by(muni_name) %&gt;% summarize(pop = sum(pop, na.rm = TRUE)) %&gt;% arrange(-pop) %&gt;% ungroup() %&gt;% # Municipality grouped with the same percentage of migrants (~ 20%) mutate(pop_pct = 100 * pop/sum(pop)) %&gt;% mutate(pop_pct_cum = cumsum(pop_pct)) %&gt;% mutate(pop_pct_cum_brk = cut(pop_pct_cum, breaks = cumsum__breaks)) # Plot pop_migr_total %&gt;% ggplot() + geom_sf(aes(fill = pop_pct_cum_brk), color = &quot;grey&quot;, size = 0.05) + scale_fill_brewer(name = &quot;Cumulative [%]&quot;, palette = &quot;YlGnBu&quot;, direction = -1, drop = FALSE) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_void() + # ylim(54.50, 58.0) + geom_sf_label_repel(data = big_cities, aes(label = muni_name), nudge_y = 100000, nudge_x = 80000) Figure 2.7: Spatial distribution of immigrants and their descendants (Date: 2020-10-01) Spatial distribution: Turkish and Iraqi citizens are clustered over the big cities (why?): Historical reason? Do these countries have a long history of immigration into Denmark, and before the big cities where the main receptors of immigrants? Furthermore, since these people have been for a long time in Denmark they have a similar migration pattern than Danes (i.e. they have moved to big cities)? Are they supporting newcomers from these countries? Do they have support groups (religion,) in this municipalities, so newcomers prefer to stay in these cities? Links with country of origin? Polish, Romanian, and Syrian citizens settled all over Denmark, without a clear pattern. German citizens: in the big cities but the population is also important in the border region with Germany. ## Top 6 citizen groups (and percentage over the same country of origin) cumsum__breaks &lt;- c(0, 20, 40.0, 60.0, 80.0, 100) top_migr_groups &lt;- c(&quot;Turkey&quot;, &quot;Poland&quot;, &quot;Syria&quot;, &quot;Germany&quot;, &quot;Romania&quot;, &quot;Iraq&quot;) pop_migr_muni_last_top_groups &lt;- pop_migr_muni_last %&gt;% filter(origin %in% top_migr_groups) %&gt;% st_sf() %&gt;% group_by(origin) %&gt;% arrange(-pop) %&gt;% mutate(pop_pct = 100 * pop / sum(pop, na.rm = TRUE), pop_pct_cum = cumsum(pop_pct), pop_pct_cum_brk = cut(pop_pct_cum, breaks = cumsum__breaks)) %&gt;% select(muni_name, origin, pop, pop_pct, pop_pct_cum, pop_pct_cum_brk) # facet by top countries, adding the total number of immigrants/descendants sum_pop &lt;- function(country) { sum(pop_migr_muni_last_top_groups[pop_migr_muni_last_top_groups$origin == country, ]$pop, na.rm = T) } levels &lt;- top_migr_groups labels &lt;- c(paste(&quot;Turkish citizens\\n(&quot;, sum_pop(&quot;Turkey&quot;) , &quot; inhabitants)&quot;, sep = &quot;&quot;), paste(&quot;Polish citizens\\n(&quot;, sum_pop(&quot;Poland&quot;), &quot; inhabitants)&quot;, sep = &quot;&quot;), paste(&quot;Syrian citizens\\n(&quot;, sum_pop(&quot;Syria&quot;), &quot; inhabitants)&quot;, sep = &quot;&quot;), paste(&quot;German citizens\\n(&quot;, sum_pop(&quot;Germany&quot;), &quot; inhabitants)&quot;, sep = &quot;&quot;), paste(&quot;Romanian citizens\\n(&quot;, sum_pop(&quot;Romania&quot;), &quot; inhabitants)&quot;, sep = &quot;&quot;), paste(&quot;Iraqi citizens\\n(&quot;, sum_pop(&quot;Iraq&quot;), &quot; inhabitants)&quot;, sep = &quot;&quot;) ) pop_migr_muni_last_top_groups &lt;- pop_migr_muni_last_top_groups %&gt;% mutate(origin_num = factor(origin, levels = levels, labels = labels)) pop_migr_muni_last_top_groups %&gt;% ggplot() + geom_sf(aes(fill = pop_pct_cum_brk), color = &quot;grey&quot;, size = 0.05) + scale_fill_brewer(name = &quot;Cumulative [%]&quot;, palette = &quot;YlGnBu&quot;, direction = -1) + facet_wrap(~ origin_num, ncol = 2) + theme_void() Figure 2.8: Top countries of origin for immigrants and their descendants (Date: 2020-10-01) Definitions (from DST): Immigrant: An immigrant is defined as a person born abroad whose parents are both (or one of them if there is no available information on the other parent) foreign citizens or were both born abroad. If there is no available information on either of the parents and the person was born abroad, the person is also defined as an immigrant. Descendant: A descendant is defined as a person born in Denmark whose parents (or one of them if there is no available information on the other parent) are either immigrants or descendants with foreign citizenship. If there is no available information on either of the parents and the person in question is a foreign citizen, the person is also defined as a descendant. Person of Danish origin: A person  regardless place of birth  where at least one parent is Danish citizen and also born in Denmark. Country of origin: Country of origin is defined as following: When no parents are known, the country of origin is defined from the persons own information. If the person is an immigrant, its assumed that the country of origin is equal to the country of birth. If the person is a descendant, its assumed that the country of origin is equal to the country of citizenship. When only one parent is known, the country of origin is defined as the country of birth of the parent. If this is Denmark, the country of citizenship is used. When both parents are known, the country of origin is defined as the country of birth of the mother respectively country of citizenship. 2.2 Housing prices level We load all residences for year-round living (ENH_ANVEND_KODE) from the Building and Dwelling Register (BBR), and then we estimate the mean and median prices in each municipality. 110 = Farmhouse for agricultural property. 120, 121, 122 = Detached single-family house (detached house). 130, 131, 132 = Townhouse, chain, or semi-detached house (vertical separation between the units). 140 = Multi-storey residential building (multi-family house, including two-family house (horizontal separation between the units). 150 = College. 160 = Residential building for residential institution. 190 = Second building for year-round living. We selected from the main residential buildings those that are on the ordinary free trade (OVERDRAGELSES_KODE == 1 - Almindelig frit salg) or public sales (OVERDRAGELSES_KODE == 3 - Auktion). Furthermore, we filtered those dwellings that are actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig). Dwelling with a size lower that 10 \\(m^2\\) were removed from the analysis. Colleges and Residential building for residential institution were also excluded from the data analysis since they are a special type of buildings dedicated to students residences and housing for institutions, respectively, and they are mainly outside of the free marked. # Residential buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 110, &quot;Farmhouse&quot;, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;, 190, &quot;Second building&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Aux. function f_average_price_muni &lt;- function(.file) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # ordinary free trade or auction filter.(OVERDRAGELSES_KODE == &quot;1&quot; | OVERDRAGELSES_KODE == &quot;3&quot;) %&gt;% # Remove residential units not used for for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() } # Read in parallel csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) plan(multisession, workers = 7) res_prices_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_average_price_muni) %&gt;% # rename KomKode mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% rename.(muni_id = KomKode) plan(&quot;default&quot;) There are some unrealistic house prices in Kerteminde and Ringsted municipalities. In this sense, there are 499 houses with a value of 267000000 DKK in Kerteminde and 310 with a value of 375000000 DKK in Ringsted. We may expect few houses with very high prices in this areas but these numbers seem unlikely for small towns and oly for one year (2008 and 2011, respectively). Therefore, we have removed them from the datasets assuming there was a mistake in the data imputation and we do not have other criteria for assigning a realistic value. We also remove properties with no value (KONTANT_KOEBESUM = 0; there were 18,801 of 1,494,495 data) res_prices &lt;- res_prices_read %&gt;% filter(!(muni_id == &quot;0440&quot; &amp; year == 2008 &amp; KONTANT_KOEBESUM == 267000000)) %&gt;% filter(!(muni_id == &quot;0329&quot; &amp; year == 2011 &amp; KONTANT_KOEBESUM == 375000000)) %&gt;% filter(KONTANT_KOEBESUM &gt; 0) We adjusted the housing prices to 2020 prices. In this regard, we take into account the inflation and, therefore, prices from different years can be compared (Valtersdorf Møller (2020)). The adjusted price is obtained as follow: \\[ Pice_{2020} = Price_{i} \\cdot \\frac{Index_{2020}}{Index_{i}}\\] Where, \\(Price_{2020}\\) is the adjusted housing price for 2020, \\(Price_{i}\\) is the price of the respective year \\(i\\), and \\(Index_{i}\\) and \\(Index_{2020}\\) are the price indexes for the origin year \\({i}\\) and \\(2020\\), respectively. The indexes have been obtained from Statistic Denmark; i.e. table EJ6: Price index for sales property (2006=100) by category of real property and unit (Table 2.1). # DST table (PRIS112 - Consumer price index (2015=100) by main figures and time) id_table &lt;- &quot;EJ6&quot; dat_meta &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Values to retrieve variables &lt;- list( # Category of real property (i.e. One-family houses) list(code = &quot;EJENDOMSKATE&quot;, values = &quot;0111&quot;), # Index list(code = &quot;TAL&quot;, values = &quot;100&quot;), # From 2004 to 2019 list(code = &quot;Tid&quot;, values = seq(start_year, end_year, 1)) ) # Get index price_index &lt;- get_data(&quot;EJ6&quot;, variables) %&gt;% select(-TAL) %&gt;% # Translate into English rename(index_desc = EJENDOMSKATE, index_year = TID, index_value = INDHOLD) %&gt;% # Convert index tu numeric mutate(index_value = index_value/10) # Print price index table price_index %&gt;% # Wide format pivot_wider(names_from = index_year, values_from = index_value) %&gt;% kbl(caption = &quot;Price index for sale properties in Denmark&quot;) %&gt;% kable_paper() %&gt;% scroll_box(width = &quot;100%&quot;) Table 2.1: Price index for sale properties in Denmark index_desc 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 One-family houses 70.1 82.3 100 105 101 88.1 90.5 88.1 85.1 87.4 90.4 95.8 99.6 104 108 111 116 # Adjust housing prices price_index_2020 &lt;- price_index %&gt;% filter(index_year == 2020) # Add adjusted prices res_prices &lt;- res_prices %&gt;% # Add price index by year and category left_join.(price_index, by = c(&quot;year&quot; = &quot;index_year&quot;)) %&gt;% # Add columns with index_2019 mutate.(index_2020 = price_index_2020$index_value) %&gt;% # Calculate prices 2019 mutate.(price_2020_kDKK = (price_kDKK * index_2020 / index_value)) %&gt;% # Price per m2 mutate(price_2020_kDKK_m2 = price_2020_kDKK / BEBO_ARL) Prices change (median) from 2004 to 2020. # Summary statistics of 2020 adjusted housing prices by municipalities res_prices_muni &lt;- res_prices %&gt;% # 2008 - year we start to have population data filter.(year &gt;= 2008) %&gt;% # Estimate mean and median values (house prices) summarise.(num_res_units = n(), median_2020_kDKK_m2 = median(price_2020_kDKK_m2), .by = c(muni_id, year)) %&gt;% # Price change with 2008 as baseline arrange.(muni_id, year) %&gt;% mutate.( median_2020_kDKK_m2_dif = 100 * (median_2020_kDKK_m2 - first(median_2020_kDKK_m2)) / first(median_2020_kDKK_m2), .by = muni_id) # Link house prices (at the first day of the year) with population. dk_muni_prices &lt;- dk_muni_pop %&gt;% as_tibble() %&gt;% # Population at the first day of the year separate(date, c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep = &quot;-&quot;) %&gt;% filter(month == &quot;01&quot;) %&gt;% mutate(year = as.numeric(year)) %&gt;% # get only population data by municipality select(muni_id, muni_name, area_km2, year, ancestry, pop, pop_km2, geometry) %&gt;% # wide format pivot_wider(names_from = ancestry, values_from = c(pop, pop_km2)) %&gt;% # Add spatial residential prices left_join(res_prices_muni, by = c(&quot;muni_id&quot;, &quot;year&quot;)) %&gt;% st_sf() %&gt;% # Remove Christiansø (there is no residential houses) filter(muni_id != &quot;0411&quot;) dk_muni_prices %&gt;% filter(year == end_year) %&gt;% ggplot() + geom_sf(aes(fill = median_2020_kDKK_m2_dif), color = &quot;grey&quot;, size = 0.05) + scale_fill_gradient2(name = &quot;Change [%]&quot;, low = &quot;blue&quot;, mid = &quot;white&quot;, high = &quot;red&quot;, midpoint = 0) + theme_void() Figure 2.9: Adjusted 2020 housing prices variation from 2008 to 2020 Relationship between population density and house prices (median values) at municipality level. # Big cities/urban areas lbls &lt;- c(&quot;København&quot;, &quot;Aarhus&quot;, &quot;Odense&quot;, &quot;Aalborg&quot;, &quot;Frederiksberg&quot;, &quot;Tønder&quot;, &quot;Læsø&quot; ) dk_muni_prices_lbls &lt;- dk_muni_prices %&gt;% filter(muni_name %in% lbls) # Plot ggplot() + geom_point(data = dk_muni_prices, aes(x = pop_km2_Total, y = median_2020_kDKK_m2, colour = muni_name, shape = factor(year))) + scale_shape_manual(values = 1:nlevels(factor(dk_muni_prices$year))) + scale_x_log10() + geom_mark_ellipse(data = dk_muni_prices_lbls, aes(x = pop_km2_Total, y = median_2020_kDKK_m2, colour = muni_name, label = muni_name), label.fill = NA) + labs(title = &quot;&quot;, x = &quot;Population density [ppl/km2]&quot;, y = &quot;2019 adjusted median values [kDKK/m2]&quot;, colour = &quot;Municipality&quot;, shape = &quot;Year&quot;) + theme_bw() + theme(legend.position = &quot;bottom&quot;) + guides(shape = guide_legend(ncol = 2, title.position = &quot;top&quot;), colour = guide_legend(ncol = 7, title.position = &quot;top&quot;)) + geom_smooth(data = dk_muni_prices, aes(x = pop_km2_Total, y = median_2020_kDKK_m2), method = &quot;lm&quot;, se = F, colour = &quot;blue&quot;) Figure 2.10: Association between population density and median housing prices at municipality level Plots variation over time (adjusted prices). NOTE: Zoom up to 80% change # Short municipalities by total population density in 2008-Q1 dk_muni_prices &lt;- dk_muni_prices %&gt;% mutate(muni_name = fct_reorder2(muni_name, year, pop_km2_Total, .fun = last2)) # Plot ggplot(data = dk_muni_prices, aes(x = year, y = median_2020_kDKK_m2_dif)) + geom_point() + geom_smooth(method = &quot;loess&quot;, span = 0.75, se = FALSE) + geom_hline(yintercept = 0, linetype=&quot;dashed&quot;, color = &quot;grey&quot;, size = 0.5) + facet_wrap(~muni_name, ncol = 6) + theme_bw() + theme(legend.position = &quot;bottom&quot;, axis.text = element_text(size = 10), axis.title = element_text(size = 14), legend.text = element_text(size = 14), legend.title = element_text(size = 14, face = &quot;bold&quot;), plot.title = element_text(size = 14, face = &quot;bold&quot;), title = element_text(size = 14)) + scale_y_continuous(name = &quot;[%]&quot;) + coord_cartesian(ylim = c(-80, 80)) + scale_x_continuous(name = &quot;&quot;, breaks = seq(2008, 2019, 3)) Figure 2.11: Adjusted median house price (kDKK/m2) change from 2008 (municipalities shorted by population density in 2020) # Plot ggplot(data = dk_muni_prices, aes(x = pop_km2_Total, y = median_2020_kDKK_m2)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + scale_x_log10() + labs(title = &quot;&quot;, x = &quot;Population density [ppl/km2]&quot;, y = &quot;2020 adjusted median values [kDKK/m2]&quot;) + ggrepel::geom_text_repel(data = dk_muni_prices_lbls, aes(label = muni_name), nudge_y = 20, max.iter = 3e3) + facet_wrap(~year) + theme_bw() Figure 2.12: Association between population density and median housing prices at municipality level References "],["level-parish.html", "Chapter 3 Capital region 3.1 Population data 3.2 House prices at parish level 3.3 Compositional data analysis", " Chapter 3 Capital region Migration in the capital region. Spatial patterns (Georgati and Keßler (2021)) and links with house prices. # Communes polygons of Denmark, and select those in the study area dk_country &lt;- st_union(dk_muni) # Codes of the communes under study capital_region_muni &lt;- c(&quot;København&quot;, &quot;Frederiksberg&quot;, &quot;Albertslund&quot;, &quot;Ballerup&quot;, &quot;Brøndby&quot;, &quot;Dragør&quot;, &quot;Gentofte&quot;, &quot;Gladsaxe&quot;, &quot;Glostrup&quot;, &quot;Herlev&quot;, &quot;Høje-Taastrup&quot;, &quot;Hvidovre&quot;, &quot;Ishøj&quot;, &quot;Lyngby-Taarbæk&quot;, &quot;Rødovre&quot;, &quot;Tårnby&quot;, &quot;Vallensbæk&quot;) # Select municipalities under study capital_muni &lt;- dk_muni %&gt;% filter(muni_name %in% capital_region_muni) dk_country_crop &lt;- st_crop(dk_country, capital_muni) # Parishes polygons of Denmark, and select those in the study area prsh_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_prsh &lt;- read_sf(prsh_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the capital region dk_prsh_cent &lt;- st_centroid(dk_prsh) capital_prsh_cent &lt;- st_intersection(dk_prsh_cent, capital_muni) capital_prsh &lt;- dk_prsh %&gt;% # Get parishes in the capital region filter(SOGNEKODE %in% capital_prsh_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Translate column names rename(prsh_id = SOGNEKODE, prsh_name = SOGNENAVN) # Contour of the capital region (merge the parishes in one polygon): capital_area &lt;- capital_prsh %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) ggplot() + geom_sf(data = capital_prsh, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = capital_muni, fill = NA, color = &quot;black&quot;, size = 0.5) + my_theme_map() + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(2, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) Figure 3.1: Parishes in the Capital region 3.1 Population data Population data at parish level was uploaded from Denmark Statistics: Tables: KMSTA001: Population 1. January by parish, ancestry and National Church. KMSTA003: Summary vital statistics by parish and movements. ## Auxiliary functions for reading the data with the package *danstat* # Loop by year for getting DST data steps &lt;- function(year){ var_values &lt;- list(id_region, id_ancestry, year) var_input &lt;- purrr::map2(.x = var_codes, .y = var_values, .f = ~list(code = .x, values = .y)) get_data(id_table, variables = var_input) } # Function for removing punctuation, lowercase, stem, stopwords, and collapse strings rm_words &lt;- function(x, stopwords) { x %&gt;% strsplit(&quot; &quot;, fixed = TRUE) %&gt;% lapply(tm::removePunctuation) %&gt;% lapply(tolower) %&gt;% lapply(SnowballC::wordStem) %&gt;% lapply(function(x) x[!x %in% stopwords]) %&gt;% vapply(function(x) paste(x , collapse = &quot;_&quot;), character(1)) } ## Read and clean table KMSTA001 # Table id_table &lt;- &quot;KMSTA001&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;HERKOMST&quot;, &quot;Tid&quot;) # Values for var_input # Region: parishes of the study area (i.e. capital_parish) id_region &lt;- capital_prsh$prsh_id # Ancestry id_ancestry &lt;- NA # Quarters id_year &lt;- seq(2008, end_year, 1) # Select 2008-2020 # Read data (n parallel) plan(multisession, workers = 7) capital_prsh_ancestry_read &lt;- id_year %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean data capital_prsh_ancestry &lt;- capital_prsh_ancestry_read %&gt;% # Translate column names into English rename(parish = SOGN, ancestry = HERKOMST, year = TID, value = INDHOLD) %&gt;% # Get parish codes, names, and municipality names separate(parish, c(&quot;prsh_id&quot;, &quot;prsh_name&quot;, &quot;muni_name&quot;), sep = &quot; &quot;, extra = &quot;drop&quot;) %&gt;% mutate(muni_name = gsub(&quot;\\\\(&quot;, &quot;&quot;, muni_name)) %&gt;% # Make shorter names in ancestry mutate(ancestry = case_when( ancestry == &quot;Persons of Danish origin&quot; ~ &quot;pop_dan&quot;, ancestry == &quot;Immigrants from western countries&quot; ~ &quot;pop_mi_wst&quot;, ancestry == &quot;Immigrants from non-western countries&quot; ~ &quot;pop_mi_nwst&quot;, ancestry == &quot;Descendants from western countries&quot; ~ &quot;pop_de_wst&quot;, ancestry == &quot;Descendants from non-western countries&quot; ~ &quot;pop_de_nwst&quot;), ancestry = factor(ancestry)) %&gt;% # Pivot (one row for peach parish and year) pivot_wider(names_from = ancestry, values_from = value) %&gt;% # Merge immigrants and their descendants (i.e. foreigners) mutate(pop_frgn_wst = pop_mi_wst + pop_de_wst, pop_frgn_nwst = pop_mi_nwst + pop_de_nwst) %&gt;% select(-c(pop_mi_wst, pop_de_wst, pop_mi_nwst, pop_de_nwst)) %&gt;% # Add column with total population mutate(pop_total = select(., starts_with(&quot;pop_&quot;)) %&gt;% rowSums()) %&gt;% # Put NA when pop_* is 0 mutate(across(starts_with(&quot;pop&quot;), ~ifelse(.x == 0, NA, .x))) # Add the spatial information: capital_prsh_ancestry_sf &lt;- capital_prsh %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(capital_prsh_ancestry, by = c(&quot;prsh_id&quot;)) %&gt;% # Population density mutate(across(starts_with(&quot;pop&quot;), ~.x/prsh_area_km2, .names = &quot;{.col}_km2&quot;)) ## Read and clean table KMSTA003 # Table id_table &lt;- &quot;KMSTA003&quot; var_pop &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Codes for var_input var_codes &lt;- c(&quot;SOGN&quot;, &quot;KIRKEBEV&quot;, &quot;Tid&quot;) # Values for var_input # Region: all parish id_region &lt;- capital_prsh$prsh_id # Ancestry id_movements &lt;- NA # Quarters id_year &lt;- seq(2015, end_year, 1) # data from 2015 # Read data plan(multisession, workers = 7) capital_prsh_stats_read &lt;- id_year %&gt;% future_map_dfr(steps) plan(&quot;default&quot;) # Clean data capital_prsh_stats &lt;- capital_prsh_stats_read %&gt;% # Translate column names into English rename(parish = SOGN, movements = KIRKEBEV, year = TID, value = INDHOLD) %&gt;% # Get parish codes, names, and municipality names separate(parish, c(&quot;prsh_id&quot;, &quot;prsh_name&quot;, &quot;muni_name&quot;), sep = &quot; &quot;, extra = &quot;drop&quot;) %&gt;% mutate(muni_name = gsub(&quot;\\\\(&quot;, &quot;&quot;, muni_name)) %&gt;% # Clean arguments in movements (remove punctuation, stop-words, stem, and collapse) mutate(movements = rm_words(movements, c(&quot;in&quot;, &quot;the&quot;, &quot;of&quot;))) %&gt;% # Pivot (one row for each parish and year) pivot_wider(names_from = movements, values_from = value) ## Merge both datasets in one capital_prsh_pop &lt;- capital_prsh_ancestry %&gt;% full_join(capital_prsh_stats) %&gt;% # remove rows with NAs drop_na() ## Add the spatial information: capital_prsh_pop_sf &lt;- capital_prsh %&gt;% select(prsh_id, prsh_area_km2) %&gt;% left_join(capital_prsh_pop, by = c(&quot;prsh_id&quot;)) 3.1.1 Spatial distribution Where people live in the capital region (by parish), and their change from 2008 to 2020: # Estimate population in percentage capital_prsh_ancestry_sf &lt;- capital_prsh_ancestry_sf %&gt;% group_by(year) %&gt;% mutate(across(.cols = c(pop_dan, pop_frgn_wst, pop_frgn_nwst, pop_total), .fns = ~ 100 * .x / pop_total, .names = &quot;{.col}_pct&quot;)) %&gt;% ungroup() # Aux. function for plotting plot_ppl_pct &lt;- function(pop) { capital_prsh_ancestry_sf %&gt;% ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(aes(fill = {{ pop }} ), color = &quot;grey&quot;, size = 0.05) + scale_fill_viridis(name = &quot;Percentage&quot;, option = &quot;magma&quot;, direction = -1, limits = c(0, 100) ) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1) + my_theme_map() + facet_wrap( ~year, ncol = 3) } plot_ppl_pct(pop_dan_pct) Figure 3.2: Population distribution of Danes plot_ppl_pct(pop_frgn_nwst_pct) Figure 3.3: Population distribution of non-Western residents plot_ppl_pct(pop_frgn_wst_pct) Figure 3.4: Population distribution of Western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_dan_pct, y = pop_frgn_nwst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Danes\\n(%)&quot;, ylab = &quot;Non-wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.5: Population distribution of Danes vs. Non-western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_dan_pct, y = pop_frgn_wst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Danes\\n(%)&quot;, ylab = &quot;Wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.6: Population distribution of Danes vs. Western residents # Create classes bi_data &lt;- capital_prsh_ancestry_sf %&gt;% drop_na() %&gt;% group_by(year) %&gt;% bi_class(x = pop_frgn_nwst_pct, y = pop_frgn_wst_pct, style = &quot;quantile&quot;, dim = 3) %&gt;% ungroup() %&gt;% st_sf() # Create map p1 &lt;- ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = bi_data, mapping = aes(fill = bi_class), size = 0.05, show.legend = FALSE) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.1)+ bi_scale_fill(pal = &quot;DkBlue&quot;, dim = 3) + my_theme_map() + facet_wrap(~year, ncol= 3) # Create legend p_legend &lt;- bi_legend(pal = &quot;DkBlue&quot;, dim = 3, xlab = &quot;Non-wst\\n(%)&quot;, ylab = &quot;Wst\\n(%)&quot;, size = 8) # Plot layout &lt;- &quot; AAAAAA# AAAAAA# AAAAAA# AAAAAA# AAAAAAB &quot; p1 + p_legend + plot_layout(design = layout) Figure 3.7: Population distribution of Non-Western vs. Western residents There are missing data form some parishes (i.e. mainly in Copenhagen City and from 2011-2015; Figure ??). (TRYE to estimate values in this parishes?? e.g. base on the population at municipality and the total number of residential dwellings in each parish..??) # population at municipality level (at the first day of the year) capital_muni_pop_sf &lt;- dk_muni_pop %&gt;% # Get population at the first day of the year filter(muni_name %in% capital_region_muni) %&gt;% separate(date, c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;)) %&gt;% filter(month == &quot;01&quot;) capital_muni_pop_sf %&gt;% filter(ancestry == &quot;Total&quot;) %&gt;% ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(aes(fill = pop_km2)) + scale_fill_viridis(name = &quot;ppl/km2&quot;, option = &quot;magma&quot;, direction = -1, trans = &quot;log10&quot;) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + my_theme_map() + facet_wrap( ~year, ncol = 3) Figure 3.8: Population density at municipality level 3.1.2 Autocorrelation (Moran I) Local spatial autocorrelation. Define neighbours polygons and weights: # Based on: # https://mgimond.github.io/simple_moransI_example/ # https://rpubs.com/quarcs-lab/spatial-autocorrelation library(spdep) # Local Moran index f_local_moran &lt;- function(year, variable, df = capital_prsh_ancestry_sf, signif = 0.15) { # Polygons s &lt;- df %&gt;% # Select filter(year == {{ year }}) %&gt;% drop_na() %&gt;% st_sf() # Variable x &lt;- s %&gt;% # Variable pull( {{ variable }}) # Plot MI xp &lt;- x %&gt;% # Local Index localmoran_perm(listw = nb2listw(poly2nb(s, queen = TRUE), style = &quot;W&quot;, zero.policy = TRUE), nsim = 999) %&gt;% as_tibble() %&gt;% dplyr::rename(p.value = `Pr(z &gt; 0)`) %&gt;% # binds results to our polygon shapefile cbind(s) %&gt;% st_sf() %&gt;% # center the variable of interest around its mean mutate(m_qualification = x - mean( x ), m_local = Ii - mean(Ii)) %&gt;% # Build quadrant mutate(quadrant = case_when(m_qualification &gt; 0 &amp; m_local &gt; 0 ~ 4, m_qualification &lt; 0 &amp; m_local &lt; 0 ~ 1, m_qualification &lt; 0 &amp; m_local &gt; 0 ~ 2, m_qualification &gt; 0 &amp; m_local &lt; 0 ~ 3), quadrant = ifelse(p.value &gt; signif, 0, quadrant)) %&gt;% mutate(quadrant = factor(quadrant, levels = c(0, 1, 2, 3, 4), labels = c(&quot;Insignificant&quot;, &quot;Low-Low&quot;, &quot;Low-High&quot;, &quot;High-Low&quot;, &quot;High-High&quot;))) xp %&gt;% # Plot quadrants (LISA) ggplot() + geom_sf(data = capital_prsh, fill = &quot;black&quot;) + geom_sf(aes(fill = quadrant), color = &quot;grey&quot;, size = 0.05) + scale_fill_manual(name = &quot;Quadrant&quot; , values = c(&quot;lightgrey&quot;, &quot;#0000FF&quot;, &quot;#A2A2FF&quot;, &quot;#FFA2A2&quot;, &quot;#FF0000&quot;), drop = FALSE) + labs(title = {{ year }}, subtitle = {{ variable }}) + my_theme_map() } # Plot maps p &lt;- map2(.x = rep(2008:end_year, times = 1, each = 3), .y = rep(c(&quot;pop_dan_pct&quot;, &quot;pop_frgn_wst_pct&quot;, &quot;pop_frgn_nwst_pct&quot;), length(rep(2008:end_year, times = 1, each = 3))/3), ~f_local_moran(.x, .y)) wrap_plots(p, ncol = 3) + plot_layout(guides = &quot;collect&quot;) Figure 3.9: Local Moran index (p-value &lt; 0.15) 3.1.3 Ternary plots There are some issues with ggtern and the new version of ggplot2 (v. 3.3.5). Therefore, we have made the ternary plots with older versions in a separate project (here), and here we have plotted the results. Population structure by year, with all the data together in the same diagram. knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-year-1.png&quot;) Figure 3.10: Ternary plot by year Separate plots by year and add the parishes in the legend. knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-year-prsh-1.png&quot;) Figure 3.11: Ternary plots by parish maps Center over the compositional mean of 2019 (i.e. Danes ~ 80.3%; non-wst ~ 12.3; and wst ~ 7.4%). knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-map-1.png&quot;) Figure 3.12: Population distribution Only for 2020. knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-map-2020-1.png&quot;) Figure 3.13: Population distribution in 2020 3.2 House prices at parish level W have used all residences for year-round living (ENH_ANVEND_KODE) (i.e. from the Building and Dwelling Register - BBR. We remove from the dataset, however, those dwellings that are not actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig) and dwellings with a size lower than that 10 \\(m^2\\). We also focus our analysis to the main building types in the City of Copenhagen, which are in this order: i) multi-storey residential buildings (code 140), ii) detached single-family houses (codes 120, 121, 122), and iii) semi-detached houses (codes 130, 131, 132). Colleges were excluded from the data analysis since they are a special type of buildings dedicated to students residences mainly outside of the free marked. We also select from the main residential buildings those that are on the ordinary free trade (OVERDRAGELSES_KODE == 1 - Almindelig frit salg) or public sales (OVERDRAGELSES_KODE == 3 - Auktion), since these values represent what people are willing to pay for own a property. Finally, we adjusted the housing prices to 2019 prices and estimated the price per square meter (\\(kDDK/m^2\\)) by dividing the 2020 adjusted prices and the size of the dwelling (BEBO_ARL). Inconsistent values have been removed; i.e. 2019 adjusted prices = 0 kDKK. # Buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Function for reading residential units in the study area from a BBR files (.csv): f_runits_oft_capital &lt;- function(.file, .muni = study_area_codes) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # Format KomKode and select municipalities of the study area mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% filter.(KomKode %in% .muni) %&gt;% # Remove residential units not used for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() %&gt;% # ordinary free trade or auction filter.(OVERDRAGELSES_KODE == &quot;1&quot; | OVERDRAGELSES_KODE == &quot;3&quot;) %&gt;% # Remove prices &gt; 0 kDKK filter.(price_kDKK &gt; 0) %&gt;% # 2020 adjusted house prices left_join.(price_index, by = c(&quot;year&quot; = &quot;index_year&quot;)) %&gt;% mutate.(index_2020 = price_index_2020$index_value, price_2020_kDKK = (price_kDKK * index_2020 / index_value), price_2020_kDKK_m2 = price_2020_kDKK / BEBO_ARL) } # Load residential units (from .csv files) # NOTE: you may need to change the path to your file on &quot;OneDrive - Aalborg Universitet&quot; csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) study_area_codes &lt;- capital_muni$muni_id plan(multisession, workers = 7) runits_oft_capital_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_runits_oft_capital) plan(&quot;default&quot;) # Clean dataset runits_oft_capital &lt;- runits_oft_capital_read %&gt;% # Input empty cells in Etagebetegn (buildings with only one floor) as &quot;st&quot; mutate.(Etagebetegn = fifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn)) %&gt;% # Etagebetegn as ordered factor mutate.(Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE)) %&gt;% # Group floor levels with 5 or more mutate.(floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join.(res_codes, by = &quot;ENH_ANVEND_KODE&quot;) %&gt;% # Convert columns with codes (*_KODE) to character mutate.(across.(ends_with(&quot;KODE&quot;), ~as.character(.))) # Convert to sf objects and add population data by ancestry plan(multisession, workers = 7) runits_oft_capital_sf &lt;- runits_oft_capital %&gt;% # Convert to sf object st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) %&gt;% # Detect to what parish belongs a house group_split(year) %&gt;% future_map_dfr(., ~st_join(., capital_prsh, join = st_nearest_feature), .options = furrr_options(seed = 123)) plan(&quot;default&quot;) The total number of residential units used for the analysis is therefore 342227 (Table 3.1). # Table with Number of residential units runits_oft_capital_sf %&gt;% as_tibble() %&gt;% # Summarize by type or residency and year group_by(type, year) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Arrange and add row with totals arrange(year, desc(n)) %&gt;% # Pivot pivot_wider(names_from = year, values_from = n) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% kbl(caption = &quot;Number of residential dwellings in the free trade by year&quot;) %&gt;% kable_paper() %&gt;% row_spec(4, bold = TRUE) %&gt;% scroll_box(width = &quot;100%&quot;) Table 3.1: Number of residential dwellings in the free trade by year type 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 Multi-storey 16314 19448 17940 15528 9168 6634 18887 11025 13820 13146 15475 17109 15330 16754 15720 16328 12628 Single-family house 3687 3672 2758 2818 2423 2138 3944 2735 3240 3191 3499 3958 3605 4000 3700 3780 3849 Semi-detached house 1658 1786 1957 1784 1465 1019 2064 1567 1672 1695 1862 2318 2837 2921 2944 2140 2287 Total 21659 24906 22655 20130 13056 9791 24895 15327 18732 18032 20836 23385 21772 23675 22364 22248 18764 The summary descriptive statistics of the housing prices are: # Create variable labels of the variables to be printed in the table labelled::var_label(runits_oft_capital_sf$price_2020_kDKK) &lt;- &quot;Adjusted prices (kDKK)&quot; labelled::var_label(runits_oft_capital_sf$BEBO_ARL) &lt;- &quot;Dwelling size (m2)&quot; labelled::var_label(runits_oft_capital_sf$price_2020_kDKK_m2) &lt;- &quot;Adjusted prices per square meter (kDKK/m2)&quot; library(tidyverse) library(gtsummary) # Summary table temp &lt;- as_tibble(runits_oft_capital_sf) temp %&gt;% # Select variables of interest select(type, price_2020_kDKK, BEBO_ARL, price_2020_kDKK_m2) %&gt;% # Summary values tbl_summary(by = type, type = all_continuous() ~ &quot;continuous2&quot;, statistic = all_continuous() ~ c(&quot;{mean}&quot;, &quot;{median}&quot;, &quot;{p25} - {p75}&quot;, &quot;{min} - {max}&quot;), missing = &quot;no&quot;) %&gt;% add_overall() %&gt;% modify_spanning_header(c(&quot;stat_1&quot;, &quot;stat_2&quot;, &quot;stat_3&quot;) ~ &quot;**House type**&quot;) %&gt;% modify_footnote(update = everything() ~ NA) %&gt;% bold_labels() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #nufwpmaoon .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #nufwpmaoon .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #nufwpmaoon .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #nufwpmaoon .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #nufwpmaoon .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #nufwpmaoon .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #nufwpmaoon .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #nufwpmaoon .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #nufwpmaoon .gt_column_spanner_outer:first-child { padding-left: 0; } #nufwpmaoon .gt_column_spanner_outer:last-child { padding-right: 0; } #nufwpmaoon .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #nufwpmaoon .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #nufwpmaoon .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #nufwpmaoon .gt_from_md > :first-child { margin-top: 0; } #nufwpmaoon .gt_from_md > :last-child { margin-bottom: 0; } #nufwpmaoon .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #nufwpmaoon .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #nufwpmaoon .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #nufwpmaoon .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #nufwpmaoon .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #nufwpmaoon .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #nufwpmaoon .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #nufwpmaoon .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #nufwpmaoon .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #nufwpmaoon .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #nufwpmaoon .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #nufwpmaoon .gt_sourcenote { font-size: 90%; padding: 4px; } #nufwpmaoon .gt_left { text-align: left; } #nufwpmaoon .gt_center { text-align: center; } #nufwpmaoon .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #nufwpmaoon .gt_font_normal { font-weight: normal; } #nufwpmaoon .gt_font_bold { font-weight: bold; } #nufwpmaoon .gt_font_italic { font-style: italic; } #nufwpmaoon .gt_super { font-size: 65%; } #nufwpmaoon .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Overall, N = 342,227 House type Multi-storey, N = 251,254 Semi-detached house, N = 33,976 Single-family house, N = 56,997 Adjusted prices (kDKK) Mean 27,772 35,883 5,628 5,219 Median 3,515 3,309 3,458 3,950 IQR 2,183 - 6,703 1,937 - 10,228 2,680 - 4,589 3,111 - 5,437 Range 0 - 1,893,909 0 - 1,893,909 0 - 339,878 0 - 251,743 Dwelling size (m2) Mean 96 83 116 144 Median 88 76 112 137 IQR 64 - 118 58 - 99 96 - 130 112 - 165 Range 10 - 6,100 10 - 6,100 12 - 442 10 - 1,205 Adjusted prices per square meter (kDKK/m2) Mean 376 495 50 43 Median 36 39 31 31 IQR 27 - 55 28 - 125 25 - 40 24 - 40 Range 0 - 39,456 0 - 39,456 0 - 12,613 0 - 15,136 House prices by type (removing very low prices; i.e. &lt;1 kDKK/m2, n = 1450). ggplot(data = filter(runits_oft_capital_sf, price_2020_kDKK_m2 &gt; 1), aes(y = price_2020_kDKK_m2, x = factor(year), fill = type)) + geom_boxplot(show.legend = FALSE) + scale_y_log10() + labs(x = &quot;&quot;, y = &quot;kDKK/m2&quot;) + facet_wrap( ~ type) + theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) Figure 3.14: Boxplot of residential units in the open free trade by house typr (values have been truncated with house prices &gt;1 kDkk/m2) House prices parish (spatial distribution) # Summary house prices by parish sum_runits_oft_prices &lt;- runits_oft_capital_sf %&gt;% as.data.table() %&gt;% summarise.(n_runits_oft = n(), mean_2020_kDKK_m2 = mean(price_2020_kDKK_m2, na.rm = TRUE), median_2020_kDKK_m2 = median(price_2020_kDKK_m2, na.rm = TRUE), .by = c(year, prsh_id)) %&gt;% # Link with population data by ancestry left_join.(capital_prsh_ancestry_sf) %&gt;% st_sf() %&gt;% # Data from 2008 filter(year &gt;= 2008) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = cut(median_2020_kDKK_m2, breaks = quantile(sum_runits_oft_prices$median_2020_kDKK_m2, seq(0, 1, 0.1), na.rm = TRUE), include.lowest = TRUE, right = TRUE, dig.lab = 0, ordered_result = TRUE)), color = NA) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;magma&quot;, direction = -1) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- sum_runits_oft_prices %&gt;% group_split(year) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation years_pd &lt;- seq(2008, end_year, 1) for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 3.15: Median 2020-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m ggplot() + geom_sf(data = dk_country_crop, fill = &quot;grey&quot;) + geom_sf(data = sum_runits_oft_prices, aes(fill = cut_number(median_2020_kDKK_m2, n = 10, ordered_result = TRUE, dig.lab = 0)), color = NA) + geom_sf(data = capital_muni, fill = NA, color = &quot;white&quot;, size = 0.05) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;magma&quot;, direction = -1) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~year, ncol = 3) Figure 3.16: Median 2019-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m remove one parish with non-western migrants up to 80% (NAME). There were not house prices in the ordinary free sale (only for one year); WHY? 3.3 Compositional data analysis Migration data usually reflected a percentage over the total population, which make them close data. We need to applu therefore CoDa framework. Types of transformation worr working with these data (i.e. alr, clr, ilr). We can use standart statistics over these lorg-rations, mainly with ilr transformations (Lloyd, Pawlowsky-Glahn, and Egozcue (2012)) balances - concept and aplications. How to obtain the best transformation (based on expert knowlegde of the data- PCA). library(compositions) # CoDa (2020) x &lt;- capital_prsh_ancestry_sf %&gt;% filter(year == 2020) %&gt;% select(prsh_id, pop_dan, pop_frgn_nwst, pop_frgn_wst) %&gt;% rename(dan = pop_dan, nwst = pop_frgn_nwst, wst = pop_frgn_wst) %&gt;% as_tibble() %&gt;% drop_na() %&gt;% select(-geometry) xc &lt;- x %&gt;% clo(parts = c(&quot;dan&quot;, &quot;nwst&quot;, &quot;wst&quot;), total = 100) %&gt;% acomp() PCA (with clr transformations). Helps to identify the variables that account the most for the variability of the results and chose the balance. . par(mfrow = c(1, 2)) # PCA pc &lt;- princomp(xc) # summary(pc) coloredBiplot(x = pc, pc.biplot = T, xlabs.pc = c(1, 2, 3), xlabs.col = 2:4, col = &quot;black&quot;, xlab = &quot;Comp. 1 (73%)&quot;, ylab = &quot;Comp. 1 (27%)&quot;) # Dendrogram balances signary &lt;- t(matrix( c(1, -1, 1, 1, 0, -1), ncol = 3, nrow = 2, byrow = TRUE)) CoDaDendrogram(X = xc, signary = signary, col = &quot;black&quot;, range = c(-8,8), # type = &quot;l&quot;, main = &quot;CoDa Dendrogram&quot;) Figure 3.17: Biplot of clr transfomation and balance dendrogram In our cases, with only three variables, our balances are: \\[ b_1 = \\sqrt{\\frac{2}{3}} * ln(\\frac{x_1 x_2}{x_3^2}) \\] \\[ b_2 = \\sqrt{\\frac{1}{2}} * ln(\\frac{x_1}{x_2}) \\] Where \\(x_1\\), \\(x_2\\), \\(x_3\\) are the Danes, Western, and Non-wester population in the parish. # bal &lt;- balance(xc, ~pop_dan/pop_frgn_wst/pop_frgn_nwst) bal_sf &lt;- capital_prsh_ancestry_sf %&gt;% filter(year == 2020) %&gt;% mutate(b1 = sqrt(2/3) * log( ((pop_dan * pop_frgn_wst)^0.5) / (pop_frgn_nwst)), b2 = sqrt(1/2) * log(pop_dan / pop_frgn_wst)) We can therefore analyse the spatial autocorrelation of the balances: # Moran nb &lt;- poly2nb(bal_sf, queen = TRUE) wts &lt;- nb2listw(nb, style = &quot;W&quot;, zero.policy = TRUE) # Global index GMI_b1 &lt;- moran.test(bal_sf$b1, listw = wts) %&gt;% tidy() %&gt;% mutate(balance = &quot;b1&quot;) %&gt;% select(balance, everything()) %&gt;% rename(moran_I = estimate1, expectation = estimate2, variance = estimate3) GMI_b2 &lt;- moran.test(bal_sf$b2, listw = wts) %&gt;% tidy() %&gt;% mutate(balance = &quot;b2&quot;) %&gt;% select(balance, everything()) %&gt;% rename(moran_I = estimate1, expectation = estimate2, variance = estimate3) GMI &lt;- bind_rows(GMI_b1, GMI_b2) %&gt;% print() # # A tibble: 2 x 8 # balance moran_I expectation variance statistic p.value method alternative # &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; # 1 b1 0.470 -0.00794 0.00312 8.56 5.50e-18 Moran I test under randomisation greater # 2 b2 0.542 -0.00794 0.00313 9.84 3.92e-23 Moran I test under randomisation greater f_local_moran(df = bal_sf, year = 2020, variable = &quot;b1&quot;, signif = 0.1) f_local_moran(df = bal_sf, year = 2020, variable = &quot;b2&quot;, signif = 0.1) Spatial clusters (k-means cluster) with balances: separate Non-western from Danes and Western citizens. # based on https://www.tidymodels.org/learn/statistics/k-means/ # Select the optimal number of clusters dat_cluster &lt;- bal_sf %&gt;% select(b1, b2) %&gt;% as_tibble() %&gt;% select(-geometry) kclusts &lt;- tibble(k = 1:9) %&gt;% mutate( kclust = map(k, ~kmeans(dat_cluster, .x)), tidied = map(kclust, tidy), glanced = map(kclust, glance), augmented = map(kclust, augment, bal_sf) ) # Plot total within sum of squares clusterings &lt;- kclusts %&gt;% unnest(cols = c(glanced)) ggplot(clusterings, aes(k, tot.withinss)) + geom_line() + geom_point() + theme_bw() assignments &lt;- kclusts %&gt;% unnest(cols = c(augmented)) %&gt;% st_sf() # plot k = 4 assignments %&gt;% filter(k == 4) %&gt;% ggplot() + geom_sf(aes(fill = .cluster)) assignments %&gt;% filter(k == 4 ) %&gt;% group_by(.cluster) %&gt;% summarise(across(.cols = ends_with(&quot;pct&quot;), .fns = median)) %&gt;% as_tibble() %&gt;% select(-geometry) # # A tibble: 4 x 5 # .cluster pop_dan_pct pop_frgn_wst_pct pop_frgn_nwst_pct pop_total_pct # &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 1 54.3 7.17 37.3 100 # 2 2 85.5 4.47 9.78 100 # 3 3 81.7 9.95 7.42 100 # 4 4 75.4 6.45 19.1 100 assignments %&gt;% filter(k == 4 ) %&gt;% select(.cluster, pop_dan_pct, pop_frgn_nwst_pct, pop_frgn_wst_pct) %&gt;% as_tibble() %&gt;% pivot_longer(!c(.cluster, geometry), names_to = &quot;name&quot;, values_to = &quot;value&quot;) %&gt;% mutate(name = gsub(&quot;pop_&quot;, &quot;&quot;, name), name = gsub(&quot;_pct&quot;, &quot;&quot;, name), name = gsub(&quot;frgn_&quot;, &quot;&quot;, name)) %&gt;% ggplot() + geom_boxplot(aes(y = value, x = name), fill = &quot;red&quot;) + labs(x = &quot;&quot;, y = &quot;Percentage [%]&quot;) + facet_grid(~.cluster) + theme_bw() Figure 3.18: Cluster characteristics Links with house prices (zoom the figure to the parishes with median values). knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-price-all-1.png&quot;) Figure 3.19: Median housing prices and popupation distribution by parish (all data) knitr::include_graphics(&quot;https://github.com/javiereliomedina/ternary_maps_DK/raw/main/_bookdown_files/ternary_maps_DK_files/figure-html/fig-cap-reg-tern-pop-year-prsh-1.png&quot;) Figure 3.20: Median housing prices and popupation distribution by parish and year Linear models with N &gt; 5. # Link median prices (sum_runits_oft_prices) with population (balances - bal_sf) bal_prices &lt;- sum_runits_oft_prices %&gt;% # Analyse only 2020 filter(year == 2020) %&gt;% # Remove parish with less that 6 data filter(n_runits_oft &gt; 5) %&gt;% # Select variables of interest select(prsh_id, pop_dan, pop_frgn_wst, pop_frgn_nwst, pop_total_km2, median_2020_kDKK_m2) %&gt;% # Add balances mutate(b1 = sqrt(2/3) * log( ((pop_dan * pop_frgn_wst)^0.5) / (pop_frgn_nwst)), b2 = sqrt(1/2) * log(pop_dan / pop_frgn_wst)) # Model prices m1 &lt;- lm(log10(median_2020_kDKK_m2) ~ b1 + b2, data = bal_prices) summary(m1) # # Call: # lm(formula = log10(median_2020_kDKK_m2) ~ b1 + b2, data = bal_prices) # # Residuals: # Min 1Q Median 3Q Max # -1.8865 -0.0442 0.0015 0.0623 1.1099 # # Coefficients: # Estimate Std. Error t value Pr(&gt;|t|) # (Intercept) 1.7008 0.1197 14.21 &lt; 2e-16 *** # b1 0.1557 0.0423 3.68 0.00035 *** # b2 -0.1260 0.0663 -1.90 0.05971 . # --- # Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # # Residual standard error: 0.251 on 122 degrees of freedom # Multiple R-squared: 0.134, Adjusted R-squared: 0.12 # F-statistic: 9.46 on 2 and 122 DF, p-value: 0.000152 bal_prices$pred1 &lt;- predict(m1) plot(log10(median_2020_kDKK_m2) ~ pred1, bal_prices) abline(0, 1, col = &quot;red&quot;) References "],["level-CPH.html", "Chapter 4 Copenhagen city 4.1 Population density by grid cells of 100m x 100m 4.2 House prices by grid cells of 100m x 100m 4.3 Population density and house prices", " Chapter 4 Copenhagen city We focus the study on Copenhagen (muni_id = 0101) and Frederiksberg (muni_id = 0147) municipalities (Figure 4.1A), and we make the analysis at a scale of grid cells of 100m x 100m (Figure 4.1B). # Codes of the communes under study (KOMKODE) study_area_codes &lt;- c(&quot;0101&quot;, &quot;0147&quot;) # Select municipalities under study cph_muni &lt;- dk_muni %&gt;% filter(muni_id %in% study_area_codes) # Parishes polygons of Denmark, and select those in the study area parish_link &lt;- paste(loc_dir, &quot;DAGIREF_SHAPE_UTM32-EUREF89/ADM&quot;, &quot;SOGN.shp&quot;, sep = &quot;/&quot;) dk_parish &lt;- read_sf(parish_link) %&gt;% st_zm() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Select those where the centroid is in the study area dk_parish_cent &lt;- st_centroid(dk_parish) cph_parish_cent &lt;- st_intersection(dk_parish_cent, cph_muni) cph_parish &lt;- filter(dk_parish, SOGNEKODE %in% cph_parish_cent$SOGNEKODE) %&gt;% # Combine several parish features geometries into one polygon group_by(SOGNEKODE, SOGNENAVN) %&gt;% summarise(geometry = st_union(geometry)) %&gt;% ungroup() %&gt;% # add area of the parish (in km2) mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2))) # Contour of the study area (merge the parishes in one polygon): study_area &lt;- cph_parish %&gt;% st_union() %&gt;% st_sf() %&gt;% st_transform(crs = &quot;EPSG:25832&quot;) # Make grid cells of 100m x 100m grids100m &lt;- study_area %&gt;% # Make regular grids (100m x 100m) st_make_grid(cellsize = 100) %&gt;% st_sf() %&gt;% # Select grids only in the study area mutate(int = st_intersects(., study_area) %&gt;% lengths &gt; 0) %&gt;% filter(int == TRUE) %&gt;% select(-int) %&gt;% # Name grids as &quot;g001&quot;, &quot;g002&quot;, ... mutate(grid_ID = paste0(&quot;g&quot;, stringr::str_pad(seq(1, nrow(.), 1), 3, pad = &quot;0&quot;))) # Centroids of the grid cells (for Potential Model) grids100m &lt;- grids100m %&gt;% # Nesting nest(data_poly = everything()) %&gt;% # add centroids of the grids mutate(data_points = map(data_poly, st_centroid)) # Plot parish in the study area p1 &lt;- ggplot() + geom_sf(data = cph_muni, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + my_theme_map() + labs(title = &quot;A) Municipalities&quot;) # Plot grids p2 &lt;- ggplot() + geom_sf(data = cph_muni, fill = NA, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = grids100m$data_poly[[1]], fill = NA, color = &quot;red&quot;, size = 0.05) + my_theme_map() + labs(title = &quot;B) Grid cells of 100m x 100m&quot;) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(1.30, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) # Plot p1 + p2 Figure 4.1: Copenhagen and Frederiksberg municipalities 4.1 Population density by grid cells of 100m x 100m We disaggregate therefore population data at municipality level to the grid cells of 100m x 100m (i.e. 10786 grid cells in the study area) using all residences for year-round living (ENH_ANVEND_KODE) (i.e. from the Building and Dwelling Register - BBR as ancillary data. We also removed from the dataset those dwellings that are not actually used for residential purpose (i.e. BOLIGTYPE_KODE \\(\\neq\\) E - Andet (bl.a. institutioner og erhverv) or BOLIGTYPE_KODE \\(\\neq\\) 5 - Sommer-/fritidsbolig) and dwellings with a size lower than that 10 \\(m^2\\). # Buildings for year round living res_codes &lt;- tribble (~ENH_ANVEND_KODE, ~type, 110, &quot;Farmhouse&quot;, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;, 150, &quot;College&quot;, 160, &quot;Residential institution&quot;, 190, &quot;Second building&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) %&gt;% # Convert to data.table as.data.table() # Function for reading residential units in the study area from a BBR files (.csv): f_res_units &lt;- function(.file, .muni = study_area_codes) { fread(.file) %&gt;% # Select only Residential houses - Buildings for year-round living filter.(ENH_ANVEND_KODE %in% res_codes$ENH_ANVEND_KODE) %&gt;% # Format KomKode and select municipalities of the study area mutate.(KomKode = paste0(&quot;0&quot;, KomKode)) %&gt;% filter.(KomKode %in% .muni) %&gt;% # Remove residential units not used for for residential purpose filter.(BOLIGTYPE_KODE != &quot;E&quot; | BOLIGTYPE_KODE != &quot;5&quot;) %&gt;% # Remove tiny dwellings (area &lt; 10 m2) filter.(BEBO_ARL &gt;= 10) %&gt;% # Add year of the BBR dataset mutate.(year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert house price (KONTANT_KOEBESUM) to numeric and kDKK mutate.(price_kDKK = KONTANT_KOEBESUM / 1000, price_kDKK = as.numeric(price_kDKK)) %&gt;% # Drop unused factors levels droplevels() } # Load residential units (from .csv files) # NOTE: you may need to change the path to your file on &quot;OneDrive - Aalborg Universitet&quot; csv_files_path &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) plan(multisession, workers = 7) res_units_read &lt;- future_map_dfr(.x = csv_files_path, .f = f_res_units) plan(&quot;default&quot;) # Clean dataset res_units &lt;- res_units_read %&gt;% # Input empty cells (buildings with only one floor) in Etagebetegn as &quot;st&quot; mutate.(Etagebetegn = fifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn)) %&gt;% # Etagebetegn as ordered factor mutate.(Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE)) %&gt;% # Group floor levels with 5 or more mutate.(floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join.(res_codes, by = &quot;ENH_ANVEND_KODE&quot;) %&gt;% # Convert columns with codes (*_KODE) to character mutate.(across.(ends_with(&quot;KODE&quot;), ~as.character(.))) # Convert to sf objects res_units_sf &lt;- res_units %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) The population data at municipality level for the same period we have BBR data (2004-2020) have been retrieved from Statistics Denmark. We have used the R-package danstat and the table FT: Population figures from the censuses. id_table &lt;- &quot;FT&quot; dat_meta &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Variables variables &lt;- list( # Municipalities list(code = &quot;HOVEDDELE&quot;, values = c(&quot;101&quot;,&quot;147&quot;)), # Population at the first day of the year (from 2004 to 2020) list(code = &quot;Tid&quot;, values = seq(start_year, end_year, 1)) ) # Get data pop_tot_muni &lt;- get_data(&quot;FT&quot;, variables) %&gt;% # Translate names into English rename(muni_name = HOVEDDELE, date = TID, pop_total = INDHOLD) %&gt;% # Translate København mutate(muni_name = gsub(&quot;Copenhagen&quot;, &quot;København&quot;, muni_name)) # Add spatial information pop_tot_muni_sf &lt;- cph_muni %&gt;% left_join(pop_tot_muni, by = &quot;muni_name&quot;) The procedure for disaggregating the population data is therefore as follow: Calculate the occupancy rate (OR) for the residential units of each municipality (j): \\[OR_{j} = \\frac{pop_{j}}{N_{j}}\\] Make grid cells of 100m x 100m over the study area, and select only the grids with residential units Detect to what municipality (j) belong each grid (i) (Note that one grids may be in more that one municipality) Calculate the number of dwellings per grid and municipality (\\(N_{ij}\\)) Estimate the population in each grid (i) base the occupancy rate by parish (j): \\[pop_{gi} = \\sum_{j = 1}^{n}(OR_{j} \\cdot N_{ij})\\] Population density: \\[PD_{i} = \\frac{pop_{i}}{A_{i}}\\] We can therefore estimate the population density at the first day of the year by grid cells of 100m x 100m (figure 4.2). #&#39; Aux. function for calculate the population density in the grids created by f_grids #&#39; @param .year Year of the analysis (e.g. 2020) f_pd_grids &lt;- function(.year) { # Population at the first day of the year (.year) in each municipality pop_year &lt;- pop_tot_muni_sf %&gt;% # select the data at the first day of the year filter(date == .year) # Dwellings (points) of the selected year BBR_year &lt;- res_units_sf %&gt;% filter(year == .year) %&gt;% select(geometry) # Calculate occupancy rate (&quot;OR&quot;) of the residential units in each municipality in a year OR &lt;- pop_year %&gt;% # number of units per municipality mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # mean population per unit in each parish mutate(across(starts_with(&quot;pop&quot;), ~ . / n_units)) %&gt;% # output as table as_tibble() %&gt;% select(-n_units, -geometry) # Get only the grids with residential units on them gru &lt;- grids100m$data_poly[[1]] %&gt;% # Number of residential units per grid mutate(n_units = st_intersects(., BBR_year) %&gt;% map(., ~length(.)) %&gt;% unlist()) %&gt;% # Get grids with residential buildings filter(n_units &gt; 0) %&gt;% # Add date mutate(date = .year) # Detect to what area belong the grid gru_muni &lt;- gru %&gt;% st_intersection(., cph_muni) %&gt;% # Remove parish area select(-area_km2, -muni_name) # Population density by grids pop_grids &lt;- gru_muni %&gt;% # convert to table as_tibble() %&gt;% select(-geometry) %&gt;% # Merge OR per area left_join(OR, by = &quot;muni_id&quot;) %&gt;% # recalculate population by grid mutate(across(starts_with(&quot;pop&quot;), ~ . * n_units)) %&gt;% # sum population of each municipality of the grid group_by(grid_ID) %&gt;% summarise(pop_total = sum(pop_total), n_units = sum(n_units)) %&gt;% ungroup() # Add spatial information gru %&gt;% select(-n_units) %&gt;% left_join(pop_grids, by = &quot;grid_ID&quot;) %&gt;% # Area of the grid mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %&gt;% # Population density (pop/area) mutate(across(starts_with(&quot;pop_&quot;), ~ . / (1000 * area_km2))) %&gt;% rename_with(~paste(.x, &quot;km2&quot;, sep = &quot;_&quot;), starts_with(&quot;pop&quot;)) %&gt;% # Remove polygons with 0 population filter(pop_total_km2 &gt; 0) } # List of years with BBR data (2004-2020) and population data (2008-2020) years_pd &lt;- seq(start_year, end_year, 1) # Increase future maximum allowed size of global variables options(future.globals.maxSize = 8000 * 1024^2) # Population density plan(multisession, workers = 7) pop_g100m &lt;- future_map_dfr(.x = years_pd, .f = f_pd_grids) plan(&quot;default&quot;) # Default value options(future.globals.maxSize = 500 * 1024^2) # Add breaks brks &lt;- c(min(pop_g100m$pop_total_km2), 1, 2, 3, 4, 5, 10, 15, 20, 30, ceiling(max(pop_g100m$pop_total_km2))) pop_g100m &lt;- pop_g100m %&gt;% mutate(pop_total_km2_cut = cut(pop_total_km2, breaks = brks, include.lowest = TRUE)) # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = pop_total_km2), color = NA) + # geom_sf(data = cph_muni, fill = NA, color = &quot;grey50&quot;, size = 0.1) + scale_fill_viridis(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), option = &quot;turbo&quot;, limits = c(0.2, 174), trans = &quot;log10&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$date, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- pop_g100m %&gt;% group_split(date) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 4.2: Population density by grid cells of 100m x 100m ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = pop_g100m, aes(fill = pop_total_km2), color = NA) + scale_fill_viridis(name = TeX(&quot;$\\\\overset{\\\\textbf{Population}}{(x1000/km^2)}$&quot;), option = &quot;turbo&quot;, trans = &quot;log10&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap(~date) Figure 4.3: Population density by grid cells of 100m x 100m 4.2 House prices by grid cells of 100m x 100m However, for housing prices we focus our analysis to the main building types in the City of Copenhagen (Figure 4.4), which are in this order: i) multi-storey residential buildings (code 140), ii) detached single-family houses (codes 120, 121, 122), iii) colleges (code 150), and iv) semi-detached houses (codes 130, 131, 132). # Aux. function for plotting 2D kernel density maps: f &lt;- function(.data) { .data %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_point(aes(X, Y), size = 0.02, shape = 16) + stat_density_2d(aes(X, Y, fill = ..level..), alpha = 0.5, h = 700, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = .data$type, x = &quot;&quot;, y = &quot;&quot;) } # Plots p &lt;- res_units_sf %&gt;% filter(year == 2020) %&gt;% # Reorder type factors by the frequency they appear mutate(type = fct_infreq(type)) %&gt;% # Split by house type group_split(type) %&gt;% map( ~ f(.)) wrap_plots(p) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(0.70, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) + plot_annotation(title = &quot;Residential units in 2020&quot;, theme = theme(plot.title = element_text(size = 14, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), plot.caption = element_text(size = 9, colour = &quot;grey25&quot;) ) ) Figure 4.4: 2D kernel density map res_units_oft &lt;- runits_oft_capital %&gt;% filter(KomKode %in% study_area_codes) # Detect to what grid belongs a house plan(multisession, workers = 7) res_units_oft_g100m &lt;- res_units_oft %&gt;% st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = 25832) %&gt;% group_split(year) %&gt;% future_map_dfr(., ~st_intersection(., grids100m$data_poly[[1]])) plan(&quot;default&quot;) # Add population data of the grid cells res_units_oft_g100m &lt;- res_units_oft_g100m %&gt;% as_tibble() %&gt;% left_join(pop_g100m %&gt;% rename(year = date), by = c(&quot;year&quot;, &quot;grid_ID&quot;)) # Summary house prices by grid cells of 100m x 100m sum_runits_prices &lt;- res_units_oft_g100m %&gt;% group_by(year, grid_ID, pop_total_km2, n_units) %&gt;% summarise(n_runits_oft = n(), mean_2020_kDKK_m2 = mean(price_2020_kDKK_m2, na.rm = TRUE), median_2020_kDKK_m2 = median(price_2020_kDKK_m2, na.rm = TRUE)) %&gt;% ungroup() # Link with population data by grids of 100m x 100m prices_g100m &lt;- sum_runits_prices %&gt;% left_join(grids100m$data_poly[[1]], by = &quot;grid_ID&quot;) %&gt;% st_sf() # Aux. function for plotting f_plot &lt;- function(df) { ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = df, aes(fill = cut(median_2020_kDKK_m2, breaks = quantile(prices_g100m$median_2020_kDKK_m2, seq(0, 1, 0.1), na.rm = TRUE), include.lowest = TRUE, right = TRUE, dig.lab = 0, ordered_result = TRUE)), color = NA) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;turbo&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;, caption = paste(&quot;Date&quot;, df$year, sep = &quot;: &quot;)) } # Plot each year plan(multisession, workers = 7) plts &lt;- prices_g100m %&gt;% group_split(year) %&gt;% future_map(., .f = f_plot, .options = furrr_options(seed = 123)) plan(&quot;default&quot;) # Animation for(i in seq_along(years_pd)) { print(plts[[i]]) } Figure 4.5: Median 2020-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;) + geom_sf(data = prices_g100m, aes(fill = cut_number(median_2020_kDKK_m2, n = 10, ordered_result = TRUE, dig.lab = 0)), color = NA) + scale_fill_viridis_d(name = TeX(&quot;$\\\\overset{\\\\textbf{Percentiles}}{(kDKK/m^2)}$&quot;), option = &quot;turbo&quot;) + my_theme_map() + labs(x = &quot;&quot;, y = &quot;&quot;) + facet_wrap( ~year) Figure 4.6: Median 2020-adjusted house prices in the ordinary free trade by grid cells of 100m x 100m 4.3 Population density and house prices ggplot(data = filter(prices_g100m, n_runits_oft &gt;= 5, median_2020_kDKK_m2 &gt; 1), aes(x = pop_total_km2, y = median_2020_kDKK_m2, colour = factor(year))) + geom_point() + scale_x_log10() + scale_y_log10() + theme_bw() "],["hedonic-price-model.html", "Chapter 5 Hedonic model 5.1 House characteristics 5.2 Location characteristics 5.3 Neighbourhood characteristics", " Chapter 5 Hedonic model House prices can be modelled based on the structural characteristics of the house (e.g. age, size, building materials, floor level, etc.), their location (e.g. proximity to urban services, distance to Central Business District - CBD, accessibility, etc.), and the surrounding environment (e.g. neighbourhood services and socio-economic aspects of its inhabitants, leisure facilities, noise levels, etc.) (Chen and Hao (2008), Gultekin and Yamamura (2006)). We will focus our study in the socio-economic aspects of the neighbourhood and, in particular, in the migration structure (e.g. migration pressure, ethnic groups, ). The house prices can be therefore defined by the following function (Chen and Hao (2008), Gultekin and Yamamura (2006)). \\[P_i = f(H_i, L_i, N_i) + \\epsilon \\] Where \\(f\\) represents the functional function in the hedonic model, P is the price of the house i, and \\(H_i\\), \\(L_i\\) and \\(N_i\\) are the vector of the structural characteristics, the location variables, and the neighbourhood characteristics of the house i, respectively. Finally, \\(\\epsilon\\) is the error term. 5.1 House characteristics We get the housing prices and the house properties from the Building and Dwelling Register (BBR). The dataset contains information about the building (e.g. building area, renovation year, etc.) and the residential unit (e.g. size, number of rooms, floor level, etc.). The data from residential units are unique for each dwelling, while some building characteristics are shared by several dwellings. We therefore merge both dataset for getting a dataset in which each row represents only one dwelling. There are data from 2006 to 2019. 5.2 Location characteristics OpenStreetMaps and kortforsyningen were used for getting the data about the urban services (e.g. public transport network, parks, ). Then, the interaction between those services and the house was modelled by potential models (Weber and Hirsch (2000), Gultekin and Yamamura (2006)), where the intensity of the interaction between the elements and the house is inversely proportional to the distance between them (Giraud and Commenges (2020)). \\[ p_i = \\sum_{j = i}^{n} M_i \\cdot f(d_{ij}) \\] Where \\(p_i\\) is the potential of the housing unit, \\(M_j\\) the mass of the service, and \\(f(d_{ij})\\) the negative function of the distance between the dwelling i and the service j. 5.3 Neighbourhood characteristics We have used the smallest administrative area of Denmark (i.e. parish) for evaluating the influence of the neighbourhoog characteristics on housing prices (Use also potential model here -&gt; e.g. locate the stock of migrant population on the centroid of each parish and get the interaction intensity in each house??). The following tables from the Denmark Statistics were used: SOGN10B: Disposable income for households by parish, price unit and income. SOGN05: Population (end November) by parish, socioeconomic status and sex SOGN07: Households disposal of vehicles by parish and use of cars (do you think it could be relevant? Do people think on parking issues when they buy a house?) KMSTA003: Summary vital statistics by parish and movements KMSTA001: Population 1. January by parish, ancestry and member of the National Church. VAN1AAR: Immigration (yearly) by municipality, sex, age, country of origin and citizenship Can we also have this dataset at parish level? References "],["OSM-features.html", "Chapter 6 Open Street Map 6.1 Features 6.2 Potential model", " Chapter 6 Open Street Map The location information has been obtained from Open Street Map. We have selected services inside a buffer of approx. 2 km around the study area (Figure 6.1 and 6.2), assuming that people may use then (e.g. parks, parking areas) outside Copenhagen City but they are close enough to people houses. Then, we estimate the accessibility to each services (i.e. feature) in the centroid of the grid cell of 100m x 100m; i.e. Potential model chapter 1. We selected two types of features; i. areal features and ii. point features; where the mass of the service (\\(M_j\\)) is the area of the polygon in \\(m^2\\) or equal for all services (i.e. 1), respectively. On the other hand, the distance (\\(d_{ij}\\) in \\(m^2\\)) is the distance between the centroid of the polygon (i.e. areas features) or the point (i.e. point feature) and the centroid of the grid cells. 6.1 Features 6.1.1 Areal features The selected features and their expected effect on housing prices are reported in Table 6.1. Hospital, and Schools (e.g. schools) may create traffic and noise. Therefore, they may have a negative effect on housing prices (Gultekin and Yamamura (2006)). # List of OSM data # Available features: https://wiki.openstreetmap.org/wiki/Map_features osm_poly_list &lt;- tribble( ~feature, ~key, ~value, ~exp_effect, # Transportation &quot;Parking&quot;, &quot;amenity&quot;, &quot;parking&quot;, &quot;positive&quot;, # Green areas &quot;Park&quot;, &quot;leisure&quot;, c(&quot;park&quot;, &quot;garden&quot;, &quot;playground&quot;), &quot;positive&quot;, &quot;Allotment&quot;, &quot;landuse&quot;, &quot;allotments&quot;, &quot;positive&quot;, &quot;Meadow&quot;, &quot;landuse&quot;, &quot;meadow&quot;, &quot;positive&quot;, # Recreation ground &quot;Recreation&quot;, &quot;landuse&quot;, &quot;recreation_ground&quot;, &quot;positive&quot;, # Education &quot;School&quot;, &quot;amenity&quot;, c(&quot;school&quot;, &quot;kindergarten&quot;), &quot;negative&quot;, &quot;University&quot;, &quot;amenity&quot;, c(&quot;university&quot;, &quot;college&quot;), &quot;positive&quot;, # Healthcare &quot;Hospital&quot;, &quot;amenity&quot;, c(&quot;hospital&quot;), &quot;negative&quot; ) osm_poly_list &lt;- osm_poly_list %&gt;% unnest(c(value)) %&gt;% as.data.table() osm_poly_list %&gt;% group_by(feature, key, exp_effect) %&gt;% summarise(value = paste(value, collapse = &quot;, &quot;)) %&gt;% relocate(value, .after = key) %&gt;% kbl(caption = &quot;Expeced effect of polygon features on housing prices&quot;) %&gt;% kable_paper() Table 6.1: Expeced effect of polygon features on housing prices feature key value exp_effect Allotment landuse allotments positive Hospital amenity hospital negative Meadow landuse meadow positive Park leisure park, garden, playground positive Parking amenity parking positive Recreation landuse recreation_ground positive School amenity school, kindergarten negative University amenity university, college positive # Bounding of the study area (approx. buffer of 2km) box &lt;- c(xmin = 714906, xmax = 733618, ymin = 6166579, ymax = 6184092) bbox &lt;- st_bbox(box) bbox_sf &lt;- st_as_sfc(bbox) %&gt;% st_set_crs(&quot;EPSG:25832&quot;) # Get polygons osm_poly_dnld &lt;- oe_get(place = &quot;Copenhagen&quot;, layer = &quot;multipolygons&quot;, extra_tags = c(&quot;building&quot;, &quot;railway&quot;), provider = &quot;bbbike&quot;) %&gt;% # Convert to data.table as.data.table() %&gt;% # Long format melt(id.vars = c(&quot;osm_id&quot;, &quot;osm_way_id&quot;, &quot;type&quot;, &quot;name&quot;, &quot;geometry&quot;), variable.name = &quot;key&quot;, value.name = &quot;value&quot;) # Reading layer `multipolygons&#39; from data source `C:\\OSM_data\\bbbike_Copenhagen.gpkg&#39; using driver `GPKG&#39; # Simple feature collection with 377023 features and 26 fields # Geometry type: MULTIPOLYGON # Dimension: XY # Bounding box: xmin: 12.3 ymin: 55.6 xmax: 12.7 ymax: 55.8 # Geodetic CRS: WGS 84 # Merge and convert to sf osm_poly &lt;- merge(osm_poly_list, osm_poly_dnld, by = c(&quot;key&quot;, &quot;value&quot;)) %&gt;% # Convert to sf object st_sf() %&gt;% # Transform CRS st_transform(&quot;EPSG:25832&quot;) %&gt;% # # Remove non-valid polygons (i.e. 2 polygons) # mutate(valid = st_is_valid(.)) %&gt;% # filter(!is.na(valid)) %&gt;% # From Meadow get only &quot;Kalvebod Fælled&quot; filter(feature != &quot;Meadow&quot; | (key == &quot;landuse&quot; &amp; value == &quot;meadow&quot; &amp; name == &quot;Kalvebod Fælled&quot;)) %&gt;% mutate(feature = case_when(feature == &quot;Meadow&quot; ~ &quot;Kalvebod_Fælled&quot;, TRUE ~ feature)) %&gt;% # Mass of the service (area of the polygons) mutate(m_service = as.numeric(units::set_units(st_area(.), m^2))) %&gt;% # crop to Bounding of the study area %&gt;% st_crop(bbox_sf) %&gt;% # Nest by feature group_by(feature) %&gt;% nest() %&gt;% ungroup() %&gt;% rename(data_poly = data) %&gt;% # Get centroids mutate(data_points = map(data_poly, st_centroid)) Spatial distribution (Figure 6.1) osm_poly %&gt;% unnest(cols = c(data_poly)) %&gt;% st_sf() %&gt;% ggplot() + geom_sf(data = st_crop(dk_country, bbox_sf), fill = &quot;grey95&quot;) + geom_sf(data = cph_parish, fill = &quot;grey85&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(fill = &quot;#D55E00&quot;, col = NA) + labs(caption = &quot;Source: Open Street Map&quot;) + theme_void() + facet_wrap(~feature) Figure 6.1: Spatial distribution of OSM areal features 6.1.2 Point features Point features and their expected effect on housing prices (Table 6.2). # Sustenance (points) osm_points_list &lt;- tribble( ~feature, ~key, ~value, ~exp_effect, # Sustenance &quot;Sustenance&quot;, &quot;amenity&quot;, c(&quot;bar&quot;, &quot;biergarten&quot;, &quot;cafe&quot;, &quot;fast_food&quot;, &quot;food_court&quot;, &quot;ice_cream&quot;, &quot;pub&quot;, &quot;restaurant&quot;), &quot;negative&quot;, # Shops &quot;Shop&quot;, &quot;shop&quot;, c(&quot;supermarket&quot;, &quot;mall&quot;, &quot;general&quot;, &quot;dairy&quot;, &quot;department_store&quot;, &quot;butcher&quot;, &quot;seafood&quot;, &quot;bakery&quot;, &quot;convenience&quot;), &quot;positive&quot;, # Entertainment, Arts &amp; Culture.... &quot;Entmt_pos&quot;, &quot;amenity&quot;, c(&quot;cinema&quot;, &quot;social_centre&quot;, &quot;theatre&quot;, &quot;community_centre&quot;, &quot;arts_centre&quot;, &quot;public_bookcase&quot;), &quot;positive&quot;, &quot;Entmt_neg&quot;, &quot;amenity&quot;, c(&quot;brothel&quot;, &quot;casino&quot;, &quot;gambling&quot;, &quot;love_hotel&quot;, &quot;nightclub&quot;, &quot;stripclub&quot;, &quot;swingerclub&quot;), &quot;negative&quot;, # Healthcare &quot;Social_fac&quot;, &quot;amenity&quot;, &quot;social_facility&quot;, &quot;negative&quot;, # Public transport &quot;Underground&quot;, &quot;railway&quot;, &quot;subway_entrance&quot;, &quot;positive&quot;, &quot;Bus_stop&quot;, &quot;highway&quot;, &quot;bus_stop&quot;, &quot;positive&quot;, &quot;Train_stop&quot;, &quot;railway&quot;, &quot;stop&quot;, &quot;positive&quot;) %&gt;% unnest(cols = c(value)) %&gt;% as.data.table() osm_points_list %&gt;% group_by(feature, key, exp_effect) %&gt;% summarise(value = paste(value, collapse = &quot;, &quot;)) %&gt;% relocate(value, .after = key) %&gt;% kbl(caption = &quot;Expeced effect of points features on housing prices&quot;) %&gt;% kable_paper() Table 6.2: Expeced effect of points features on housing prices feature key value exp_effect Bus_stop highway bus_stop positive Entmt_neg amenity brothel, casino, gambling, love_hotel, nightclub, stripclub, swingerclub negative Entmt_pos amenity cinema, social_centre, theatre, community_centre, arts_centre, public_bookcase positive Shop shop supermarket, mall, general, dairy, department_store, butcher, seafood, bakery, convenience positive Social_fac amenity social_facility negative Sustenance amenity bar, biergarten, cafe, fast_food, food_court, ice_cream, pub, restaurant negative Train_stop railway stop positive Underground railway subway_entrance positive osm_points_dnld &lt;- oe_get(place = &quot;Copenhagen&quot;, layer = &quot;points&quot;, extra_tags = c(&quot;amenity&quot;, &quot;shop&quot;, &quot;railway&quot;, &quot;highway&quot;), provider = &quot;bbbike&quot;) %&gt;% # Convert to data.table as.data.table() %&gt;% # Long format melt(id.vars = c(&quot;osm_id&quot;, &quot;name&quot;, &quot;address&quot;, &quot;geometry&quot;), variable.name = &quot;key&quot;, value.name = &quot;value&quot;) # Reading layer `points&#39; from data source `C:\\OSM_data\\bbbike_Copenhagen.gpkg&#39; using driver `GPKG&#39; # Simple feature collection with 399818 features and 13 fields # Geometry type: POINT # Dimension: XY # Bounding box: xmin: 12.3 ymin: 55.6 xmax: 12.7 ymax: 55.8 # Geodetic CRS: WGS 84 osm_points &lt;- merge(osm_points_list, osm_points_dnld, by = c(&quot;key&quot;, &quot;value&quot;)) %&gt;% # Convert to sf object st_sf() %&gt;% # Transform CRS st_transform(&quot;EPSG:25832&quot;) %&gt;% # crop to Bounding of the study area %&gt;% st_crop(bbox_sf) %&gt;% # Mass of the service (The same for all points = 1) mutate(m_service = 1) %&gt;% # Nest by feature group_by(feature) %&gt;% nest() %&gt;% rename(data_points = data) Spatial distribution (Figure 6.2) osm_points %&gt;% unnest(cols = c(data_points)) %&gt;% st_sf() %&gt;% ggplot() + geom_sf(data = st_crop(dk_country, bbox_sf), fill = &quot;grey95&quot;) + geom_sf(data = cph_parish, fill = &quot;grey85&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(colour = &quot;#D55E00&quot;, size = 0.5) + labs(caption = &quot;Source: Open Street Map&quot;) + theme_void() + facet_wrap(~feature) Figure 6.2: Spatial distribution of OSM point features 6.2 Potential model We have used exponential functions with impedance factors of 2 and spans of 5000m, 500m, or 300m depending on the service we modelled (Table 6.3). # Based on: https://riatelab.github.io/potential/articles/potential.html # Set Spatial Interaction Function (fun, span, beta) sif &lt;- tribble( ~feature, ~fun, ~span, ~beta, &quot;Kalvebod_Fælled&quot;, &quot;e&quot;, 5000, 2, &quot;Recreation&quot;, &quot;e&quot;, 500, 2, &quot;Train_stop&quot;, &quot;e&quot;, 500, 2, &quot;Underground&quot;, &quot;e&quot;, 500, 2, &quot;Parking&quot;, &quot;e&quot;, 300, 2, &quot;Park&quot;, &quot;e&quot;, 300, 2, &quot;School&quot;, &quot;e&quot;, 300, 2, &quot;University&quot;, &quot;e&quot;, 300, 2, &quot;Hospital&quot;, &quot;e&quot;, 300, 2, &quot;Allotment&quot;, &quot;e&quot;, 300, 2, &quot;Sustenance&quot;, &quot;e&quot;, 300, 2, &quot;Entmt_pos&quot;, &quot;e&quot;, 300, 2, &quot;Entmt_neg&quot;, &quot;e&quot;, 300, 2, &quot;Social_fac&quot;, &quot;e&quot;, 300, 2, &quot;Shop&quot;, &quot;e&quot;, 300, 2, &quot;Bus_stop&quot;, &quot;e&quot;, 300, 2 ) sif %&gt;% group_by(fun, beta, span,) %&gt;% summarise(feature = paste(feature, collapse = &quot;, &quot;)) %&gt;% relocate(feature, .after = span) %&gt;% kbl(caption = &quot;Spatial interaction parameters&quot;) %&gt;% kable_paper() Table 6.3: Spatial interaction parameters fun beta span feature e 2 300 Parking, Park, School, University, Hospital, Allotment, Sustenance, Entmt_pos, Entmt_neg, Social_fac, Shop, Bus_stop e 2 500 Recreation, Train_stop, Underground e 2 5000 Kalvebod_Fælled The spatial interaction functions are therefero as follow (Figure 6.3). par(mfrow=c(2,2)) plot_inter(fun = &quot;e&quot;, span = 300, beta = 2) plot_inter(fun = &quot;e&quot;, span = 500, beta = 2) plot_inter(fun = &quot;e&quot;, span = 5000, beta = 2) Figure 6.3: Spatial interaction functions # Merge all OMS features (as points) OMS &lt;- osm_poly %&gt;% select(feature, data_points) %&gt;% bind_rows(osm_points) %&gt;% # Add SIF parameters left_join(sif, by = &quot;feature&quot;) # Aux. function for calculating the potential f_pot &lt;- function(df, fun, span, beta) { mcpotential(x = df, y = grids100m$data_points[[1]], var = &quot;m_service&quot;, fun = fun, span = span, beta = beta, limit = 5 * span) } # Estimate potential (in percentage - relatively to the maximum) pot_est &lt;- list() for(i in seq_along(OMS$data_points)) { # Values potential &lt;- f_pot(OMS$data_points[[i]], OMS$fun[i], OMS$span[i], OMS$beta[i]) # Percentage relatively to the maximum pot_est[[i]] &lt;- 100 * potential / max(potential) # Add names names(pot_est)[[i]] &lt;- OMS$feature[i] } # Add values to the grid cells of 100 x 100 m (grids100m) pot &lt;- rbind(pot_est) %&gt;% as_tibble() %&gt;% unnest(everything()) grids100m &lt;- grids100m %&gt;% bind_cols(pot %&gt;% nest(pot = everything())) Potential model (Figure 6.4) # Plots grids100m %&gt;% select(data_poly, pot) %&gt;% unnest(c(data_poly, pot)) %&gt;% pivot_longer(-c(grid_ID, geometry), names_to = &quot;feature&quot;, values_to = &quot;value&quot;) %&gt;% st_sf() %&gt;% ggplot() + geom_sf(aes(fill = value), col = NA) + scale_fill_gradient2(name = &quot;[%]&quot;, low = &quot;blue&quot;, mid = &quot;white&quot;, high = &quot;red&quot;, midpoint = 50) + geom_sf(data = cph_parish, fill = NA, color = &quot;grey50&quot;, size = 0.05) + theme_void() + facet_wrap(~feature) Figure 6.4: Potential model References "],["dist-CBD.html", "Chapter 7 Distance to Central Business District", " Chapter 7 Distance to Central Business District The distance between a house and the Central Business District (CBD) has an important role in its price (Chen and Hao (2008)). We add thereofre it as another feature in our model, with a possitive expected effec (i.e. the closer the house to the CBT, the higer the price). However, we do not measure the distance in km but the commuting time from the house to the CBD (i.e. Indre By). In this regard, we estimate the travel time (in public transport) from the centre of each grid cell of 100m x 100m to Kongens Nytorv (coordinates: 55.6805° N, 12.5860° E), and we associate the time to all dwellings at that grid. We have used used the open source OpenTripPlanner, and the r-package opentripplanner (Morgan et al. (2019)) for calculating the travel times by foot, bike, car, and public transport (Figure 7.1). # Kongens Nytorv KN &lt;- tibble(name = &quot;Kongens Nytorv&quot;, x = 12.5860, y = 55.6805) %&gt;% st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;)) %&gt;% st_set_crs(&quot;EPSG:4326&quot;) # NOT RUN (slow) uncomment if needed # # OTP folder structure # dir.create(&quot;otp&quot;) # dir.create(&quot;otp/graphs/default&quot;) # # path_data &lt;- file.path(&quot;./otp&quot;) # # # Data # # ## Download Denmark GTFS from dk_gtfs &lt;- &quot;http://www.rejseplanen.info/labs/GTFS.zip&quot; # ## and save as &quot;~./otp/graphs/default/gtfs.zip&quot;) # # ## Copenhagen pbf # cph_match &lt;- oe_match(&quot;Copenhagen&quot;, # provider = &quot;bbbike&quot;, # quiet = TRUE) # oe_download(cph_match$url, # provider = &quot;bbbike&quot;, # download_directory = &quot;./otp/graphs/default&quot;, # quiet = TRUE) # file.rename(from = &quot;./otp/graphs/default/bbbike_Copenhagen.osm.pbf&quot;, # to = &quot;./otp/graphs/default/osm.pbf&quot;) # # ## Get DEM # # # Download elevation model (10m resolution) # zip_files &lt;- c(&quot;DTM10_616_71_ASC_UTM32-EUREF89.ZIP&quot;, # &quot;DTM10_616_72_ASC_UTM32-EUREF89.ZIP&quot;, # &quot;DTM10_617_71_ASC_UTM32-EUREF89.ZIP&quot;, # &quot;DTM10_617_72_ASC_UTM32-EUREF89.ZIP&quot;, # &quot;DTM10_618_71_ASC_UTM32-EUREF89.ZIP&quot;, # &quot;DTM10_618_72_ASC_UTM32-EUREF89.ZIP&quot;) # # f1 &lt;- function(zip_file){ # dangeo_get_data(ftp_folder = &quot;dhm_danmarks_hoejdemodel/DHM-HISTORIK/DHM-2007/DTM_10M&quot;, # zip_name = zip_file) # } # # map(zip_files, f1) # # # Read files # asc_files_path &lt;- list.files(path = loc_dir , # pattern = &quot;*.asc&quot;, # full.names = TRUE, # recursive = TRUE) # # # Read blocks # dtm10_blocks &lt;- map(.x = asc_files_path, .f = read_stars) # # # Set crs (UTM32-ETRS89) # dtm10_blocks &lt;- map(dtm10_blocks, ~st_set_crs(., st_crs(study_area))) # # # Build a mosaic # dtm10 &lt;- st_mosaic(dtm10_blocks[[1]], # dtm10_blocks[[2]], # dtm10_blocks[[3]], # dtm10_blocks[[4]], # dtm10_blocks[[5]], # dtm10_blocks[[6]]) # # # Intersect with study area # cph_dtm10 &lt;- st_crop(dtm10, study_area) # # # Warping the raster # newgrid &lt;- study_area %&gt;% # st_transform(crs = &quot;EPSG:4326&quot;) %&gt;% # st_bbox() %&gt;% # st_as_stars(dx = 0.000065, dy = 0.000065) # approx. 10m # # cph_dtm10_WGS84 &lt;- cph_dtm10 %&gt;% st_warp(newgrid) # # # Export to otp folder # write_stars(cph_dtm10_WGS84, &quot;otp/graphs/default/dem.tif&quot;) # # Open Trip Planner # # ## Downloading OTP # path_otp &lt;- otp_dl_jar() # # ## Building an OTP Graph # log1 &lt;- otp_build_graph(otp = path_otp, dir = path_data, memory = 10240) # # ## Start OTP # log2 &lt;- otp_setup(otp = path_otp, dir = path_data) # # ## Connect R to OTP # otpcon &lt;- otp_connect() # # Origin points # op &lt;- grids100m$data_points[[1]] %&gt;% # st_transform(crs = &quot;EPSG:4326&quot;) # # # Calculate travel times (i.e. walk, bike, car, and public transport) # f_tt &lt;- function(feature){ # otp_plan(otpcon = otpcon, # fromPlace = op, # toPlace = c(12.5860, 55.6805), # get_geometry = FALSE, # mode = feature, # ncores = as.numeric(availableCores() - 1)) %&gt;% # select(fromPlace, toPlace, duration) # } # # dur_features &lt;- list(walk = &quot;WALK&quot;, # bike = &quot;BICYCLE&quot;, # car = &quot;CAR&quot;, # transit = c(&quot;WALK&quot;, &quot;TRANSIT&quot;)) # # tt &lt;- map(dur_features, f_tt) # # # Intersect with grid cells of 100 x 100 m # f1 &lt;- . %&gt;% # as_tibble() %&gt;% # mutate(duration = duration/60) %&gt;% # separate(fromPlace, c(&quot;Y&quot;, &quot;X&quot;), sep = &quot;,&quot;) %&gt;% # st_as_sf(coords = c(&quot;X&quot;, &quot;Y&quot;)) %&gt;% # st_set_crs(&quot;EPSG:4326&quot;) %&gt;% # st_transform(crs = &quot;EPSG:25832&quot;) %&gt;% # st_intersection(grids100m$data_poly[[1]]) # # tt_grids_cent &lt;- tt %&gt;% map(~f1(.)) # # # Add to grids polygons # f2 &lt;- . %&gt;% # st_drop_geometry() %&gt;% # left_join(as_tibble(grids100m$data_poly[[1]]), by = &quot;grid_ID&quot;) %&gt;% # st_sf() # # tt_grids_poly &lt;- tt_grids_cent %&gt;% map(~f2(.)) # # f3 &lt;- function(feature){ # tt_grids_poly %&gt;% # pluck(feature) %&gt;% # mutate(feature = feature) # } # # tt_grids_poly &lt;- names(tt_grids_poly) %&gt;% map(~f3(.)) # # # Merge grids # tt_cph_grids100m &lt;- bind_rows(tt_grids_poly) %&gt;% # mutate(feature = factor(feature, levels = c(&quot;walk&quot;, &quot;bike&quot;, &quot;car&quot;, &quot;transit&quot;))) # # saveRDS(tt_cph_grids100m, file = &quot;travel_times_grids100m_otp.rds&quot;) # # Stop OTP # otp_stop(warn = FALSE) tt_cph_grids100m &lt;- readRDS(file = &quot;travel_times_grids100m_otp.rds&quot;) myPalette &lt;- RColorBrewer::brewer.pal(8, &quot;RdYlBu&quot;) ggplot() + geom_sf(data = tt_cph_grids100m, aes(fill = cut(duration, breaks = c(0, 10, 20, 30, 40, 50, 60, 120, ceiling(max(duration))), include.lowest = TRUE)), col = NA) + scale_fill_manual(name = &quot;min&quot;, values = rev(myPalette)) + geom_sf(data = cph_parish, fill = NA, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = KN, color = &quot;black&quot;, shape = 16, size = 1.5) + theme_void() + facet_wrap(~feature) Figure 7.1: Travel times to Kongens Nytorv (black point) References "],["noise.html", "Chapter 8 Noise", " Chapter 8 Noise Denmark maps the noise levels from roads, railways, and aircraft in accordance with the guidelines in the Danish Noise Executive Order. The agency responsible for the measurements and the implementation of noise regulation is the Environmental Protection Agency, which display the maps in its website (link). The noise level are divided in six categories from 50 dB to more than 75 dB, and they represent a weighted mean value of the noise (\\(L_{den}\\)) or the night noise (\\(L_{night}\\)) both at 1.5 and 4 meters. We have used the last version of the noise map (i.e. 2017), which we have downloaded from the Danish Environmental Protection Agency (ftp server; file: Noise - Stoej2018_ArcGIS.zip). The main hypothesis is that high noise levels would have a negative impact on the prices. Furthermore, nigh noise would be more annoying and it may have a higher impact on housing prices. Therefore, we use both the average noise during a day (\\(L_{den}\\)) and the noise in the night (\\(L_{night}\\)) in our analysis. The perception of the noise is also different for roads and railways and they will therefore be analysed separately. However, aircraft noise is not significant in the area and we did not take it into account. From the two measurements heights (i.e. 1.5 and 4 meters) we select the last one for the study (Figure 8.1 and (Figure 8.2)). # Large file (3.5 GB) # # Stoej2018_link &lt;- &quot;https://sit-ftp.statens-it.dk/main.html?download&amp;weblink=6433b7b2af7578629f752343ad0d8e22&amp;realfilename=Stoej2018_ArcGIS.zip&quot; # # options(timeout = max(300, getOption(&quot;timeout&quot;))) # # download.file(Stoej2018_link, destfile = &quot;data/Stoej2018_ArcGIS.zip&quot;) # # httr::GET(Stoej2018_link, # httr::write_disk(&quot;data/Stoej2018_ArcGIS.zip&quot;), # httr::progress()) # # system2(&quot;unzip&quot;, # args = c(&quot;-o&quot;, # &quot;data/Stoej2018_ArcGIS.zip&quot;, # paste0(&quot;-d &quot;, &quot;data/Stoej2018_ArcGIS&quot;)), # stdout = TRUE) # Aux. function for loading road noise data f_roads &lt;- function(df) { read_sf(df, crs = &quot;EPSG:25832&quot;) %&gt;% st_zm() %&gt;% janitor::clean_names() %&gt;% st_make_valid() %&gt;% select(org, noise_cl, noise_in, date) %&gt;% group_by(org, noise_cl, noise_in, date) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% mutate(noise_type = case_when(noise_cl == &quot;B1&quot; ~ &quot;Lden (1.5 m)&quot;, noise_cl == &quot;B2&quot; ~ &quot;Lden (4.0 m)&quot;, noise_cl == &quot;B3&quot; ~ &quot;Lnight (1.5 m)&quot;, noise_cl == &quot;B4&quot; ~ &quot;Lnight (4.0 m)&quot;), noise_type = factor(noise_type)) %&gt;% mutate(noise_level = case_when(noise_in == &quot;1&quot; ~ &quot;&gt; 75 dB&quot;, noise_in == &quot;2&quot; ~ &quot;70-74 dB&quot;, noise_in == &quot;3&quot; ~ &quot;65-69 dB&quot;, noise_in == &quot;4&quot; ~ &quot;60-64 dB&quot;, noise_in == &quot;5&quot; ~ &quot;55-59 dB&quot;, noise_in == &quot;6&quot; ~ &quot;50-54 dB&quot;), noise_level = factor(noise_level, levels = c(&quot;&gt; 75 dB&quot;, &quot;70-74 dB&quot;, &quot;65-69 dB&quot;, &quot;60-64 dB&quot;, &quot;55-59 dB&quot;, &quot;50-54 dB&quot;), ordered = TRUE)) %&gt;% mutate(date = as.Date(date)) } # Files noise_files_path &lt;- c(&quot;data/Stoej2018_ArcGIS/b2_101_agg_road_lden_4m_region.shp&quot;, &quot;data/Stoej2018_ArcGIS/b2_147_agg_road_lden_4m.shp&quot;, &quot;data/Stoej2018_ArcGIS/b4_101_agg_road_lnight_4m.shp&quot;, &quot;data/Stoej2018_ArcGIS/b4_147_agg_road_lnight_4m.shp&quot;) noise_roads &lt;- map_dfr(.x = noise_files_path, .f = f_roads) # Plot mypal &lt;- c(&quot;#0065FD&quot;, &quot;#9833C9&quot;, &quot;#FD3300&quot;, &quot;#FD9800&quot; , &quot;#FDFD00&quot;, &quot;#90ee90&quot;) ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = noise_roads, aes(fill = noise_level), col = NA) + scale_fill_manual(name = &quot;Category&quot;, values = mypal) + theme_void() + facet_wrap(~noise_type) Figure 8.1: Road noise # Aux. function for loading train noise data f_train &lt;- function(df) { read_sf(df, crs = &quot;EPSG:25832&quot;) %&gt;% janitor::clean_names() %&gt;% st_intersection(study_area) %&gt;% # Merge polygons with the same noise category group_by(org, noise_cl, noise_in, date) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Polygons of lower noise level overlap other categories (get difference) st_difference() %&gt;% # Filter valid polygons filter(!st_is(. , c(&quot;MULTILINESTRING&quot;, &quot;LINESTRING&quot;))) %&gt;% # Format variables mutate(noise_type = case_when(noise_cl == &quot;C1&quot; ~ &quot;Lden (1.5 m)&quot;, noise_cl == &quot;C2&quot; ~ &quot;Lden (4.0 m)&quot;, noise_cl == &quot;C3&quot; ~ &quot;Lnight (1.5 m)&quot;, noise_cl == &quot;C4&quot; ~ &quot;Lnight (4.0 m)&quot;), noise_type = factor(noise_type)) %&gt;% mutate(noise_level = case_when(noise_in == &quot;1&quot; ~ &quot;&gt; 75 dB&quot;, noise_in == &quot;2&quot; ~ &quot;70-74 dB&quot;, noise_in == &quot;3&quot; ~ &quot;65-69 dB&quot;, noise_in == &quot;4&quot; ~ &quot;60-64 dB&quot;, noise_in == &quot;5&quot; ~ &quot;55-59 dB&quot;, noise_in == &quot;6&quot; ~ &quot;50-54 dB&quot;), noise_level = factor(noise_level, levels = c(&quot;&gt; 75 dB&quot;, &quot;70-74 dB&quot;, &quot;65-69 dB&quot;, &quot;60-64 dB&quot;, &quot;55-59 dB&quot;, &quot;50-54 dB&quot;), ordered = TRUE)) %&gt;% mutate(date = as.Date(date)) } # Read files noise_files_path &lt;- c(&quot;data/Stoej2018_ArcGIS/c2_bdk_mrail_lden_4m.shp&quot;, &quot;data/Stoej2018_ArcGIS/c2_ores_mrail_lden_4m.shp&quot;, &quot;data/Stoej2018_ArcGIS/c4_bdk_mrail_lnight_4m.shp&quot;, &quot;data/Stoej2018_ArcGIS/c4_ores_mrail_lnight_4m.shp&quot;) noise_train &lt;- map_dfr(.x = noise_files_path, .f = f_train) # Plot mypal &lt;- c(&quot;#0065FD&quot;, &quot;#9833C9&quot;, &quot;#FD3300&quot;, &quot;#FD9800&quot; , &quot;#FDFD00&quot;, &quot;#90ee90&quot;) ggplot() + geom_sf(data = study_area, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_sf(data = noise_train, aes(fill = noise_level), col = NA) + scale_fill_manual(name = &quot;Category&quot;, values = mypal) + theme_void() + facet_wrap(~noise_type) Figure 8.2: Railway noise "],["EDA-house-prices.html", "Chapter 9 Residential units saled as free scale 9.1 Residential units by floor level", " Chapter 9 Residential units saled as free scale We focused our study in residential dwellings on the ordinary free trade (Table ??). NOTES: There are large differences in the number of residential units between years, why?? Study only one year for the moment (e.g. 2020)?? Housing prices in different years -&gt; adjust to 2020 prices (what index; Table ??)? KONTANT_KOEBESUM = cash purchase price? Analyse it?? What about KOEBESUM_BELOEB = The purchase price agreed upon the sale of the property??? KONTANT_KOEBESUM = 0 or (&lt; 100000 DKK)? SKOEDE_DATO = The date on which the deed was signed -&gt; use as sale date?? Should we use this date (i.e. for the price index)?  What about housing prices = 0? Dwelling Area &lt;= 0? res_units_oft %&gt;% ggplot(aes(sample = log10(price_2020_kDKK), colour = factor(year))) + geom_qq() + #geom_qq_line() + facet_grid(~type) + theme_bw() 9.1 Residential units by floor level KL - basement ST - ground floor 1 - 1st floor 2 - 2nd floor 3 - 3rd floor 4 - 4th floor 5 or more = etc. res_units_oft %&gt;% group_by(floor_level, type) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # in percentage [%] mutate(perc = 100 * n / sum(n)) %&gt;% # Reorder type levels for plotting multi-storey first mutate(type = factor(type)) %&gt;% ggplot() + geom_bar(aes(y = floor_level, x = perc, fill = type), stat = &quot;identity&quot;) + labs(y = &quot;&quot;, x = &quot;Percentage [%]&quot;) + theme_bw() + theme(legend.position = &quot;bottom&quot;, legend.title = element_blank()) + guides(fill = guide_legend(ncol = 2)) + scale_x_continuous(labels = scales::comma) + scale_fill_manual(values = c(&quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;)) Figure 9.1: Residential units distribution by floor level "],["references.html", "References", " References "]]
