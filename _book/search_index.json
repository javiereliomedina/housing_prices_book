[["housing-data.html", "Chapter 2 Housing data", " Chapter 2 Housing data We load all buildings for year-round living (BYG_ANVEND_KODE) from the Building and Dwelling Register (BBR), we use this table for disaggregating population density from parish level to grid cells of 100m x 100m. 110 = Farmhouse for agricultural property. 120, 121, 122 = Detached single-family house (detached house). 130, 131, 132 = Townhouse, chain, or semi-detached house (vertical separation between the units). 140 = Multi-storey residential building (multi-family house, including two-family house (horizontal separation between the units). 150 = College. 160 = Residential building for residential institution. 190 = Second building for year-round living. # Buildings for year round living res_codes &lt;- tribble (~BYG_ANVEND_KODE, ~type, 110, &quot;Farmhouse&quot;, 120, &quot;Single-family house&quot;, 121, &quot;Single-family house&quot;, 122, &quot;Single-family house&quot;, 130, &quot;Semi-detached house&quot;, 131, &quot;Semi-detached house&quot;, 132, &quot;Semi-detached house&quot;, 140, &quot;Multi-storey&quot;, 150, &quot;College&quot;, 160, &quot;Residential institution&quot;, 190, &quot;Second building&quot;) %&gt;% # Convert type to factor mutate(type = factor(type)) # Function for reading residential units from a csv file: # Read residential units from BBR data # Get read residential units in an area # @param file Link to OneDrive with the data (.csv format) # @param area Area where we would get the data (default = study_area) f_res_units &lt;- function(.file, .area = study_area) { fread(.file) %&gt;% # Convert to tibble as_tibble() %&gt;% # Select only Residential houses - Buildings for year-round living filter(ENH_ANVEND_KODE %in% res_codes$BYG_ANVEND_KODE) %&gt;% # Input empty cells (buildings with only one floor) in Etagebetegn as &quot;st&quot; mutate(Etagebetegn = ifelse(Etagebetegn == &quot;&quot;, &quot;st&quot;, Etagebetegn), # Etagebetegn as ordened factor Etagebetegn = factor(Etagebetegn, c(&quot;k2&quot;, &quot;kl&quot;, &quot;st&quot;, seq(1, 36, 1)), ordered = TRUE), # Group floor levels with 5 or more floor_level = fct_other(Etagebetegn, drop = factor(seq(5, 36)), other_level = &quot;5 or more&quot;)) %&gt;% # Add residential description (type) into the dataset left_join(res_codes, by = c(&quot;ENH_ANVEND_KODE&quot; = &quot;BYG_ANVEND_KODE&quot;)) %&gt;% # Convert to sf objects st_as_sf(coords = c(&quot;etrs89koordinat_ost&quot;, &quot;etrs89koordinat_nord&quot;), crs = &quot;EPSG:25832&quot;) %&gt;% # Get only points in the study area mutate(int = st_intersects(., .area) %&gt;% lengths &gt; 0) %&gt;% filter(int == TRUE) %&gt;% # Add year of the BBR dataset mutate(BBR_year = parse_number(stringr::str_extract(.file, &quot;_[0-9]+_&quot;))) %&gt;% # Convert columns with codes (*_KODE) to factors mutate(across(.cols = ends_with(&quot;_KODE&quot;), .fns = as_factor)) } # Load all csv files (one file for each year) in the same tibble with a column indicating the year of the dataset: # Load residential units # NOTE: you may need to change the path to OneDrive - Aalborg Universitet # Read all the data together csv_files_link &lt;- list.files(path = Sys.getenv(&quot;OneDrive_BBR_path&quot;), pattern = &quot;*.csv&quot;, full.names = TRUE) plan(multisession, workers = 3) res_units &lt;- future_map_dfr(.x = csv_files_link, .f = f_res_units) plan(&quot;default&quot;) However, for housing prices we focus our analysis to the main building types in Copenhagen, which are in this order: i) multi-storey residential buildings (multi-family house or two-family house), ii) detached single-family houses, iii) colleges, and iv) semi-detached houses (Figure 2.1). # Aux. function for plotting 2D kernel density maps: f &lt;- function(.data) { .data %&gt;% st_coordinates() %&gt;% as_tibble() %&gt;% ggplot() + geom_sf(data = cph_parish, fill = &quot;grey&quot;, color = &quot;grey50&quot;, size = 0.05) + geom_point(aes(X, Y), size = 0.02, shape = 16) + stat_density_2d(aes(X, Y, fill = ..level..), alpha = 0.5, h = 700, geom = &quot;polygon&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = .data$type, x = &quot;&quot;, y = &quot;&quot;) } # Plots p &lt;- res_units %&gt;% filter(BBR_year == 2019) %&gt;% # Reorder type factors by the frequency they appear mutate(type = fct_infreq(type)) %&gt;% # Split by house type group_split(type) %&gt;% map( ~ f(.)) wrap_plots(p) + annotation_scale(location = &quot;br&quot;, text_cex = 1) + annotation_north_arrow(location = &quot;br&quot;, pad_x = unit(0.70, &quot;cm&quot;), pad_y = unit(0.65, &quot;cm&quot;), which_north = &quot;true&quot;, height = unit(0.5, &quot;cm&quot;), width = unit(0.5, &quot;cm&quot;), style = north_arrow_orienteering(text_col = &quot;white&quot;, text_size = 1)) + plot_annotation(title = &quot;Residential units in 2019&quot;, theme = theme(plot.title = element_text(size = 14, colour = &quot;darkblue&quot;, face = &quot;bold&quot;), plot.caption = element_text(size = 9, colour = &quot;grey25&quot;) ) ) Figure 2.1: 2D kernel density map Then, we selected from the main residential buildings those that are on the ordinary free trade (Table 2.1). Colleges were also removed from the data analysis since they are a special type of buildings dedicated to students residences mainly outside of the free marked. Inconsistent values have been also removed; i.e. prices &lt; 10 kDKK (approx. 1300) and area &lt; 10 \\(m^2\\). Finally, we removed from the analysis the residential units not used as residence (i.e. BOLIGTYPE_KODE = E). Egentlig beboelse = Actual residence Blandet erhverv og beboelse = Mixed occupations and housing Enkeltværelse = Single room E. Andet (bl.a. institutioner og erhverv) = Other (including institutions and professions) selected_res_units &lt;- c(&quot;Multi-storey&quot;, &quot;Single-family house&quot;, &quot;Semi-detached house&quot;) res_units_oft &lt;- res_units %&gt;% # Convert to tibble as_tibble() %&gt;% # Select main residential units in the area filter(type %in% selected_res_units) %&gt;% # ordinary free trade filter(OVERDRAGELSES_KODE == &quot;1&quot;) %&gt;% # Remove inconsistent values filter(KONTANT_KOEBESUM &gt;= 10000, BEBO_ARL &gt;= 10) %&gt;% # Remove BOLIGTYPE_KODE = E form the dataset filter(BOLIGTYPE_KODE != &quot;E&quot;) %&gt;% # Drop unused factors levels droplevels() # Table with Number of residential units res_units_oft %&gt;% # Summarize by type or residency and year group_by(type, BBR_year) %&gt;% summarise(n = n()) %&gt;% ungroup() %&gt;% # Arrange and add row with totals arrange(BBR_year, desc(n)) %&gt;% # Pivot pivot_wider(names_from = BBR_year, values_from = n) %&gt;% adorn_totals(&quot;row&quot;) %&gt;% kbl(caption = &quot;Number of residential dwellings in the free trade by year&quot;) %&gt;% kable_paper() %&gt;% row_spec(4, bold = TRUE) %&gt;% scroll_box(width = &quot;100%&quot;) Table 2.1: Number of residential dwellings in the free trade by year type 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 Multi-storey 12023 14080 13723 12195 7052 5056 13530 7128 8663 9589 11288 12733 11287 11910 11413 11759 Single-family house 663 669 547 561 462 429 770 527 885 653 692 694 711 703 660 716 Semi-detached house 267 288 280 355 256 203 303 471 451 481 514 525 1347 1254 1260 542 Total 12953 15037 14550 13111 7770 5688 14603 8126 9999 10723 12494 13952 13345 13867 13333 13017 Finally, we adjusted the housing prices to 2019 prices. In this regard, we take into account the inflation and prices from different years can be compared (Valtersdorf Møller (2020)). The adjusted price is obtained as follow: \\[ Pice_{2019} = Price_{i} \\cdot \\frac{Index_{2019}}{Index_{i}}\\] Where, \\(Price_{2019}\\) is the adjusting housing price for 2019, \\(Price_{i}\\) is the price of the respective year \\(i\\), and \\(Index_{i}\\) and \\(Index_{2019}\\) are the price indexes for the origin year \\({i}\\) and \\(2019\\), respectively. The indexes have been obtained from Statistic Denmark; i.e. table EJ66: Price index for sales property (2006=100) by region, category of real property and unit, and targeted for the study area; i.e. Province Byen København - Copenhagen City (Table 2.2). # DST table (EJ66: Price index for sales property (2006=100) by region, category of real property and unit) id_table &lt;- &quot;EJ66&quot; dat_meta &lt;- get_table_metadata(table_id = id_table, variables_only = TRUE) # Values to retrieve variables &lt;- list( # Province Byen København: region = 01 list(code = &quot;OMRÅDE&quot;, values = &quot;01&quot;), # Category of real property list(code = &quot;EJENDOMSKATE&quot;, values = c(&quot;0111&quot;, &quot;2103&quot;)), # Index list(code = &quot;TAL&quot;, values = NA), # From 2004 to 2019 list(code = &quot;Tid&quot;, values = seq(2004, 2019, 1)) ) # Get index price_index &lt;- get_data(&quot;EJ66&quot;, variables) %&gt;% # Get index filter(TAL == &quot;Index&quot;) %&gt;% # Translate into English rename(region = OMRÅDE, category = EJENDOMSKATE, unit = TAL, date = TID, index = INDHOLD) %&gt;% # Convert index tu numeric mutate(index = as.numeric(index)) %&gt;% # Remove region and unit columns select(-region, -unit) # Print price index table price_index %&gt;% # Wide format pivot_wider(names_from = date, values_from = index) %&gt;% kbl(caption = &quot;Price index for sale properties in Copenhagen City&quot;) %&gt;% kable_paper() %&gt;% scroll_box(width = &quot;100%&quot;) Table 2.2: Price index for sale properties in Copenhagen City category 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 One-family houses 60.9 79.4 100 96.1 89.7 74.7 80.9 81.5 79.5 85.7 93.3 102 109 115 123 125 Owner-occupied flats, total 60.2 79.4 100 91.8 82.2 71.2 77.7 79.1 80.6 89.4 99.2 112 122 132 139 138 # Adjust housing prices price_index_2019 &lt;- filter(price_index, date == 2019) %&gt;% rename(index_2019 = index) res_units_oft &lt;- res_units_oft %&gt;% # Column with price index categories mutate(category = case_when( type == &quot;Single-family house&quot; ~ &quot;One-family houses&quot;, TRUE ~ &quot;Owner-occupied flats, total&quot;)) %&gt;% # Add price index by year and category left_join(price_index, by = c(&quot;category&quot; = &quot;category&quot;, &quot;BBR_year&quot; = &quot;date&quot;)) %&gt;% # Add price index in 2019 by category left_join(price_index_2019, by = c(&quot;category&quot; = &quot;category&quot;)) %&gt;% # Calculate prices 2019 mutate(price2019_kDKK = (KONTANT_KOEBESUM * index_2019 / index) / 1000) The housing price per square meter (\\(kDDK/m^2\\)) is calculated by dividing the 2019 adjusted prices by the dwelling size (BEBO_ARL). res_units_oft &lt;- res_units_oft %&gt;% # Price per m2 mutate(price2019_kDKK_m2 = price2019_kDKK / BEBO_ARL) The summary descriptive statistics of the housing prices are: # Table theme theme_gtsummary_compact() # Create variable labels of the variables to be printed in the table labelled::var_label(res_units_oft$price2019_kDKK) &lt;- &quot;Adjusted prices (kDKK)&quot; labelled::var_label(res_units_oft$BEBO_ARL) &lt;- &quot;Dwelling size (m2)&quot; labelled::var_label(res_units_oft$price2019_kDKK_m2) &lt;- &quot;Adjusted prices per square meter (kDKK/m2)&quot; # Summary table res_units_oft %&gt;% # Select variables of interest select(type, price2019_kDKK, BEBO_ARL, price2019_kDKK_m2) %&gt;% # Summary values tbl_summary(by = type, type = all_continuous() ~ &quot;continuous2&quot;, statistic = all_continuous() ~ c(&quot;{mean}&quot;, &quot;{median}&quot;, &quot;{p25} - {p75}&quot;, &quot;{min} - {max}&quot;), missing = &quot;no&quot;) %&gt;% add_overall() %&gt;% modify_spanning_header(c(&quot;stat_1&quot;, &quot;stat_2&quot;, &quot;stat_3&quot;) ~ &quot;**House type**&quot;) %&gt;% modify_footnote(update = everything() ~ NA) %&gt;% bold_labels() html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #mwlefoodfi .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: small; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #mwlefoodfi .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mwlefoodfi .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #mwlefoodfi .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #mwlefoodfi .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mwlefoodfi .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mwlefoodfi .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #mwlefoodfi .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #mwlefoodfi .gt_column_spanner_outer:first-child { padding-left: 0; } #mwlefoodfi .gt_column_spanner_outer:last-child { padding-right: 0; } #mwlefoodfi .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #mwlefoodfi .gt_group_heading { padding: 1px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #mwlefoodfi .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #mwlefoodfi .gt_from_md > :first-child { margin-top: 0; } #mwlefoodfi .gt_from_md > :last-child { margin-bottom: 0; } #mwlefoodfi .gt_row { padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #mwlefoodfi .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #mwlefoodfi .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; } #mwlefoodfi .gt_first_summary_row { padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #mwlefoodfi .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; } #mwlefoodfi .gt_first_grand_summary_row { padding-top: 1px; padding-bottom: 1px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #mwlefoodfi .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #mwlefoodfi .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mwlefoodfi .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mwlefoodfi .gt_footnote { margin: 0px; font-size: 90%; padding: 1px; } #mwlefoodfi .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mwlefoodfi .gt_sourcenote { font-size: 90%; padding: 1px; } #mwlefoodfi .gt_left { text-align: left; } #mwlefoodfi .gt_center { text-align: center; } #mwlefoodfi .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #mwlefoodfi .gt_font_normal { font-weight: normal; } #mwlefoodfi .gt_font_bold { font-weight: bold; } #mwlefoodfi .gt_font_italic { font-style: italic; } #mwlefoodfi .gt_super { font-size: 65%; } #mwlefoodfi .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Overall, N = 192,568 House type Multi-storey, N = 173,429 Semi-detached house, N = 8,797 Single-family house, N = 10,342 Adjusted prices (kDKK) Mean 47,732 52,014 9,910 8,099 Median 4,375 4,255 5,057 4,973 IQR 2,699 - 14,468 2,586 - 20,917 3,842 - 6,920 3,887 - 6,400 Range 25 - 1,778,677 27 - 1,778,677 30 - 261,346 25 - 291,062 Dwelling size (m2) Mean 89 84 131 137 Median 81 77 130 128 IQR 60 - 108 58 - 101 115 - 142 103 - 158 Range 10 - 733 11 - 655 12 - 402 10 - 733 Adjusted prices per square meter (kDKK/m2) Mean 667 730 83 101 Median 46 47 42 40 IQR 36 - 169 37 - 254 31 - 53 32 - 48 Range 0 - 37,056 0 - 37,056 0 - 15,876 0 - 17,500 "]]
