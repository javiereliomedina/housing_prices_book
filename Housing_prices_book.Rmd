---
title: "Housing prices Copenhagen"
author: "Javier Elío, Henning S. Hansen, Carsten Keßler"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
github-repo: javiereliomedina/housing_prices_book
output: bookdown::gitbook
documentclass: book
bibliography: [library.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "Housing prices BBR data"
---
```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```

# Prerequisite {.unnumbered}

The data have been analysed with **R** (version `r paste(R.Version()$major, R.Version()$minor, sep = ".")`) and **Rstudio** (version `r rstudioapi::versionInfo()$version`), and the book has been created with **bookdown** package. The required packages are automatically checked and installed if needed from CRAN.

```{r pkgs, results='hide'}

# Create an auxiliary function for checking if a package is installed,
# install it if it is not, and load the package
# (based on https://gist.github.com/stevenworthington/3178163) 

 ipak <- function(pkg){
    new_pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new_pkg)) 
      install.packages(new_pkg,
                       dependencies = TRUE,
                       repos = "http://cran.us.r-project.org")
    sapply(pkg, require, character.only = TRUE)
  }

# List of packages 
  pkg <- c("bit64", "bookdown",
           "data.table", "danstat",
           "forcats", "furrr",
           "ggspatial", "giscoR", "gtsummary",
           "janitor",
           "kableExtra", "knitr",
           "latex2exp",
           "mapview",
           "osmdata", 
           "patchwork", "potential",
           "rmarkdown", "remotes", "RColorBrewer", "rappdirs",
           "sf", "stringr", "SnowballC", "stars",
           "units",
           "table1", "tidyverse", "tidytext", "tm", "tools")

# Check and install
  ipak(pkg)

```

```{r pkgs-bib, include=FALSE}

# automatically create a bib database for R packages
knitr::write_bib(x = c(.packages()), file = 'packages.bib')

```

Furthermore, we have created our own package for downloading [kortforsyningen](https://kortforsyningen.dk/) data to a local repository directly from R (i.e. [dangeo](https://github.com/javiereliomedina/dangeo.git)). The package can be downloaded from GitHub: 

```{r install-dangeo}

# Install package from GitHub
  if (!require("dangeo"))  remotes::install_github("javiereliomedina/dangeo")
  library(dangeo)

```

Although the *kortforsyningen* data are free, we would need to create a *username* and a *password* for getting access to them (you can make it here: ["Opret ny bruger"](https://kortforsyningen.dk/indhold/min-side-0)). By default **dangeo** looks for credentials on `.Renviron` as: `kortforsyningen_id = "username"` and `kortforsyningen_pwd = "password"`. You would need to save them with `usethis::edit_r_environ()`: 

```{r dangeo}

# Set username and password 
# usethis::edit_r_environ() # Open .Renviron file, and save the username (kortforsyningen_id = "your_username") and password (kortforsyningen_pwd = "your_password")

```

You would also need to define with `dangeo_set_param()` the local directory where the data are downloaded (`loc_dir`). It is defined as `loc_dir = rappdirs::user_cache_dir()`, although it can be changed `loc_dir = “./your/local/path”`. The first time a file is downloaded with `dangeo_get_data()`, the process can be time consuming (there are some very big files). However, it will not be downloaded in subsequent calls if the files is already in the local directory (the dataset can be overwritten be setting `overwrite = TRUE` on `dangeo_get_data()`). Once we have our *username* and *password*, and we have define the local repository for the data, we can set them on our R-session:

```{r}

# Set local repository and password to kortforsyningen
  dangeo_set_param()
  
```

Finally, the BBR data are storage in a *OneDrive* folder. You would need to have access to that folder, and save the path on `.Renviron` with `usethis::edit_r_environ()`. It has to be saved as `OneDrive_BBR_path = "your/OneDrive/BBR/path"`. 

## Acknowledgements {-}

This work has been financed by Aalborg University - AAU (Project: [Global flows of migrants and their impact on north European welfare states - FLOW](https://www.flow.aau.dk/)). The sole responsibility of this publication lies with the authors. AAU is not responsible for any use that may be made of the information contained therein.

## R session {-}

```{r R-session, echo = FALSE}

sessionInfo()

```

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# (PART) Introduction {-} 

# Hedonic price model

House prices can be modelled based on the structural characteristics of the house (e.g. age, size, building materials, floor level, etc.), their location (e.g. proximity to urban services, distance to Central Business District - CBD, accessibility, etc.), and the surrounding environment (e.g. neighbourhood services and socio-economic aspects of its inhabitants, leisure facilities, noise levels, etc.) (@Chen2008, @Gultekin2006). We will focus our study in the socio-economic aspects of the neighbourhood and, in particular, in the migration structure (e.g. migration pressure, ethnic groups, ...). The house prices can be therefore defined by the following function (@Chen2008, @Gultekin2006).

$$P_i = f(H_i, L_i, N_i) + \epsilon $$

Where $f$ represents the functional function in the hedonic model, *P* is the price of the house *i*, and $H_i$, $L_i$ and $N_i$ are the vector of the structural characteristics, the location variables, and the neighbourhood characteristics of the house *i*, respectively. Finally, $\epsilon$ is the error term.

## House characteristics

We get the housing prices and the house properties from the Building and Dwelling Register ([BBR](https://teknik.bbr.dk/forside)). The dataset contains information about the building (e.g. building area, renovation year, etc.) and the residential unit (e.g. size, number of rooms, floor level, etc.). The data from residential units are unique for each dwelling, while some building characteristics are shared by several dwellings. We therefore merge both dataset for getting a dataset in which each row represents only one dwelling. There are data from 2006 to 2019. 

## Location characteristics

[OpenStreetMaps](https://cran.r-project.org/web/packages/osmdata/vignettes/osmdata.html) and [kortforsyningen](https://kortforsyningen.dk/) were used for getting the data about the urban services (e.g. public transport network, parks, ...). Then, the interaction between those services and the house was modelled by potential models (@Weber2000, @Gultekin2006), where the intensity of the interaction between the elements and the house is inversely proportional to the distance between them (@Giraud2020).

$$ p_i = \sum_{j = i}^{n} M_i \cdot f(d_{ij}) $$

Where $p_i$ is the potential of the housing unit, $M_j$ the mass of the service, and $f(d_{ij})$ the negative function of the distance between the dwelling *i* and the service *j*.

## Neighbourhood characteristics

We have used the smallest administrative area of Denmark (i.e. parish) for evaluating the influence of the neighbourhoog characteristics on housing prices \color{red}(Use also potential model here -\> e.g. locate the stock of migrant population on the centroid of each parish and get the interaction intensity in each house??)\color{black}. The following tables from the [Denmark Statistics](https://www.dst.dk/da) were used:

-   [SOGN10B: Disposable income for households by parish, price unit and income](https://betalingsdata.statistikbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=SOGN10B&PLanguage=0&PXSId=0&wsid=cflist).
-   [SOGN05: Population (end November) by parish, socioeconomic status and sex](https://betalingsdata.statistikbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=SOGN05&PLanguage=0&PXSId=0&wsid=cflist)
-   [SOGN07: Households disposal of vehicles by parish and use of cars](https://betalingsdata.statistikbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=SOGN07&PLanguage=0&PXSId=0&wsid=cflist) \color{red}(do you think it could be relevant? Do people think on parking issues when they buy a house?)\color{black}
-   [KMSTA003: Summary vital statistics by parish and movements](https://www.statbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=KMSTA003&PLanguage=1&PXSId=0&wsid=cftree)
-   [KMSTA001: Population 1. January by parish, ancestry and member of the National Church](https://www.statbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=KMSTA001&PLanguage=1&PXSId=0&wsid=cftree).
-   [VAN1AAR: Immigration (yearly) by municipality, sex, age, country of origin and citizenship](https://www.statbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=VAN1AAR&PLanguage=1&PXSId=0&wsid=cftree) \color{red}Can we also have this dataset at parish level?\color{black}

<!--chapter:end:010_introduction.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# (PART) Load data {-}

# Administrative units

The Denmark's Administrative Geographical Division ([DAGI](https://sdfe.dk/hent-data/danmarks-administrative-geografiske-inddeling/)) has been used for obtaining the administrative boundaries of Denmark. In this sense, the country is divided in approx. 2200 parishes, 98 municipalities, 5 regions, 22 judicial districts, 12 police districts, 92 constituencies and approx. 1100 postcodes. However, we focused our study in the Copenhagen (*KOMKODE = 0101*) and Frederiksberg (*KOMKODE = 0147*) communes. 

```{r fig-adm-units, cache=TRUE, fig.cap="Parishes in the study area"}

# Download DAGI (scale 1:10000)
  dangeo_get_data(ftp_folder = "landinddelinger/dagi/SHAPE",
                  zip_name   = "DAGIREF_SHAPE_UTM32-EUREF89.zip")

# Codes of the communes under study (KOMKODE)
  study_area_codes <- c("0101", "0147")

# Communes polygons of Denmark, and select those in the study area
  commune_link <- paste(loc_dir, "DAGIREF_SHAPE_UTM32-EUREF89/ADM", "KOMMUNE.shp", sep = "/")
  dk_commune  <- read_sf(commune_link) %>%
    st_zm() %>% 
    st_transform(crs = "EPSG:25832")
  
  dk_country <- st_union(dk_commune)
  
  cph_commune <- filter(dk_commune, KOMKODE %in% study_area_codes)

# Parishes polygons of Denmark, and select those in the study area 
  parish_link <- paste(loc_dir, "DAGIREF_SHAPE_UTM32-EUREF89/ADM", "SOGN.shp", sep = "/")
  dk_parish  <- read_sf(parish_link) %>%
    st_zm() %>% 
    st_transform(crs = "EPSG:25832")

# Select those where the centroid is in the study area
  dk_parish_cent <- st_centroid(dk_parish)
  cph_parish_cent <- st_intersection(dk_parish_cent, cph_commune)

  cph_parish <- filter(dk_parish, SOGNEKODE %in% cph_parish_cent$SOGNEKODE) %>% 
    # Combine several parish features geometries into one polygon
    group_by(SOGNEKODE, SOGNENAVN) %>% 
    summarise(geometry = st_union(geometry)) %>% 
    ungroup() %>% 
    # add area of the parish (in km2)
    mutate(prsh_area_km2 = as.numeric(units::set_units(st_area(.), km^2)))

# Contour of the study area (merge the parishes in one polygon):
  study_area <- cph_parish %>%
    st_union() %>%
    st_sf() %>% 
    st_transform(crs = "EPSG:25832")

# Plot parish 
  ggplot() + 
    geom_sf(data = cph_parish, fill = "grey", color = "grey50", size = 0.05) +
    my_theme_map() +
    annotation_scale(location = "br", text_cex = 1) +
    annotation_north_arrow(location = "br",
                           pad_x = unit(1.6, "cm"),
                           pad_y = unit(0.65, "cm"),
                           which_north = "true",
                           height = unit(0.5, "cm"),
                           width = unit(0.5, "cm"),
                           style = north_arrow_orienteering(text_col = "white",
                                                            text_size = 1))
```

We have also created grid cells of 100m x 100m for aggregating some data at that scale (i.e. population density).   

```{r fig-grids-100m, cache = TRUE, dependson = "adm-units", fig.cap="Grid cells of 100m x 100m"}

# Make grids
  grids100m <- study_area %>% 
    # Make regular grids (100m x 100m)
    st_make_grid(cellsize = 100) %>% 
    st_sf() %>% 
    # Select grids only in the study area
    mutate(int = st_intersects(., study_area) %>% lengths > 0) %>% 
    filter(int == TRUE) %>% 
    # Name grids as "g001", "g002", ...
    mutate(grid_ID = paste0("g", stringr::str_pad(seq(1, nrow(.), 1), 3, pad = "0")))

# Plot
  ggplot() + 
    geom_sf(data = cph_parish, fill = "grey", color = "grey50", size = 0.05) +
    geom_sf(data = grids100m, fill = NA, color = "red", size = 0.05) + 
    my_theme_map() +
    annotation_scale(location = "br", text_cex = 1) +
    annotation_north_arrow(location = "br",
                           pad_x = unit(1.6, "cm"),
                           pad_y = unit(0.65, "cm"),
                           which_north = "true",
                           height = unit(0.5, "cm"),
                           width = unit(0.5, "cm"),
                           style = north_arrow_orienteering(text_col = "white",
                                                            text_size = 1))
  
```


There are therefore a total number of `r nrow(cph_parish)` parishes (Figure \@ref(fig:fig-adm-units) and `r nrow(grids100m)` grid cells (Figure \@ref(fig:fig-grids-100m)) in the study area. The statistics for neighbourhood characteristics at parish level since they are the smallest administrative units in Denmark. 

<!--chapter:end:021_load_adm_units.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# Housing data    

We load all buildings for year-round living (*BYG_ANVEND_KODE*) from the Building and Dwelling Register ([BBR](https://teknik.bbr.dk/forside)), we use this table for disaggregating population density from parish level to grid cells of 100m x 100m. 

- 110           = Farmhouse for agricultural property.  
- 120, 121, 122 = Detached single-family house (detached house). 
- 130, 131, 132 = Townhouse, chain, or semi-detached house (vertical separation between the units).
- 140           = Multi-storey residential building (multi-family house, including two-family house (horizontal separation between the units).
- 150           = College.
- 160           = Residential building for residential institution.
- 190           = Second building for year-round living.

```{r load-BBR, cache=TRUE, dependson = "adm-units", cache.extra = file.mtime(Sys.getenv("OneDrive_BBR_path"))}

# Buildings for year round living
  res_codes <- tribble (~BYG_ANVEND_KODE, ~type,
                        110, "Farmhouse",
                        120, "Single-family house",
                        121, "Single-family house",
                        122, "Single-family house",
                        130, "Semi-detached house",
                        131, "Semi-detached house",
                        132, "Semi-detached house",
                        140, "Multi-storey",
                        150, "College", 
                        160, "Residential institution",
                        190, "Second building") %>%
    # Convert type to factor
    mutate(type = factor(type))

# Function for reading residential units from a csv file:
# Read residential units from BBR data 
# Get read residential units in an area
# @param file Link to OneDrive with the data (.csv format)
# @param area Area where we would get the data (default = study_area)

  f_res_units  <- function(.file, .area = study_area) { 
    fread(.file) %>% 
      # Convert to tibble
      as_tibble() %>% 
      # Select only Residential houses - Buildings for year-round living 
      filter(ENH_ANVEND_KODE %in% res_codes$BYG_ANVEND_KODE) %>% 
      # Input empty cells (buildings with only one floor) in Etagebetegn as "st"
      mutate(Etagebetegn = ifelse(Etagebetegn == "", "st", Etagebetegn),
             # Etagebetegn as ordened factor
             Etagebetegn = factor(Etagebetegn, c("k2", "kl", "st", seq(1, 36, 1)),
                                  ordered = TRUE),
             # Group floor levels with 5 or more
             floor_level = fct_other(Etagebetegn,
                                     drop = factor(seq(5, 36)),
                                     other_level = "5 or more")) %>%
      # Add residential description (type) into the dataset
      left_join(res_codes, by = c("ENH_ANVEND_KODE" = "BYG_ANVEND_KODE")) %>% 
      # Convert to sf objects
      st_as_sf(coords = c("etrs89koordinat_ost", "etrs89koordinat_nord"),
               crs = "EPSG:25832") %>% 
      # Get only points in the study area
      mutate(int = st_intersects(., .area) %>% lengths > 0) %>% 
      filter(int == TRUE) %>% 
      # Add year of the BBR dataset  
      mutate(BBR_year = parse_number(stringr::str_extract(.file, "_[0-9]+_"))) %>% 
      # Convert columns with codes (*_KODE) to factors
      mutate(across(.cols = ends_with("_KODE"), .fns = as_factor))
  }

# Load all csv files (one file for each year) in the same tibble with a column indicating the year of the dataset: 
# Load residential units 
# NOTE: you may need to change the path to OneDrive - Aalborg Universitet 
# Read all the data together 
  
  csv_files_link <- list.files(path = Sys.getenv("OneDrive_BBR_path"),
                               pattern = "*.csv",
                               full.names = TRUE)
  
  plan(multisession, workers = 3)
  res_units <- future_map_dfr(.x = csv_files_link, .f = f_res_units)
  plan("default")

```

However, for housing prices we focus our analysis to the main building types in Copenhagen, which are in this order: i) multi-storey residential buildings (multi-family house or two-family house), ii) detached single-family houses, iii) colleges, and iv) semi-detached houses (Figure \@ref(fig:fig-sp-res-builds)).

```{r, fig-sp-res-builds, fig.width = 9, fig.height = 7, cache = TRUE, dependson = "load-BBR", fig.cap = "2D kernel density map"}

# Aux. function for plotting 2D kernel density maps:
  f <- function(.data) {
    .data %>% 
      st_coordinates() %>%
      as_tibble() %>%
      ggplot() +
      geom_sf(data = cph_parish, fill = "grey", color = "grey50", size = 0.05) +
      geom_point(aes(X, Y), size = 0.02, shape = 16) +
      stat_density_2d(aes(X, Y, fill = ..level..),
                      alpha = 0.5,
                      h = 700,
                      geom = "polygon") +
      scale_fill_distiller(palette = "Spectral")  +
      theme_void() + 
      theme(legend.position = "none") +
      labs(title = .data$type,
           x = "",
           y = "") 
  }

# Plots  
  p <- res_units %>% 
    filter(BBR_year == 2019) %>%  
    # Reorder type factors by the frequency they appear 
    mutate(type = fct_infreq(type)) %>% 
    # Split by house type
    group_split(type) %>%
    map( ~ f(.))
  
  wrap_plots(p) +
    annotation_scale(location = "br", text_cex = 1) +
    annotation_north_arrow(location = "br",
                           pad_x = unit(0.70, "cm"),
                           pad_y = unit(0.65, "cm"),
                           which_north = "true",
                           height = unit(0.5, "cm"),
                           width = unit(0.5, "cm"),
                           style = north_arrow_orienteering(text_col = "white",
                                                            text_size = 1)) +
    plot_annotation(title = "Residential units in 2019",
                    theme = theme(plot.title = element_text(size = 14,
                                                            colour = "darkblue",
                                                            face = "bold"),
                                  plot.caption = element_text(size = 9,
                                                              colour = "grey25")
                    )
    ) 
  
```

Then, we selected from the main residential buildings those that are on the ordinary free trade and are actually used for residential purpose (i.e. *BOLIGTYPE_KODE $\neq$ E - Andet (bl.a. institutioner og erhverv)*). Furthermore, dwelling with a size lower that 10 $m^2$ were removed from the analysis. Colleges were also excluded  from the data analysis since they are a special type of buildings dedicated to students residences mainly outside of the free marked.    

```{r runits-clean, cache = TRUE, dependson = "load-BBR"}

  selected_res_units <- c("Multi-storey", "Single-family house", "Semi-detached house")

  res_units_oft <- res_units %>%
    # Convert to tibble
    as_tibble() %>% 
    # Select main residential units in the area
    filter(type %in% selected_res_units) %>% 
    # ordinary free trade
    filter(OVERDRAGELSES_KODE == "1") %>% 
    # Remove BOLIGTYPE_KODE = E form the dataset
    filter(BOLIGTYPE_KODE != "E") %>% 
    # Remove tiny dwellings (area < 10 m2)
    filter(BEBO_ARL >= 10) %>%
    # Drop unused factors levels
    droplevels()
    
```

Finally, we adjusted the housing prices to 2019 prices. In this regard, we take into  account the inflation and, therefore, prices from different years can be compared (@Valtersdorf2020). The adjusted price is obtained as follow:

$$ Pice_{2019} = Price_{i} \cdot \frac{Index_{2019}}{Index_{i}}$$

Where, $Price_{2019}$ is the adjusted housing price for 2019, $Price_{i}$ is the price of the respective year $i$, and $Index_{i}$ and $Index_{2019}$ are the price indexes for the origin year ${i}$ and $2019$, respectively. The indexes have been obtained from Statistic Denmark; i.e. table [EJ66: Price index for sales property (2006=100) by region, category of real property and unit](https://www.statistikbanken.dk/statbank5a/SelectVarVal/Define.asp?MainTable=EJ66&PLanguage=1&PXSId=0&wsid=cftree), and targeted for the study area; i.e. *Province Byen København - Copenhagen City* (Table \@ref(tab:price-index)). Inconsistent values have been removed; i.e. 2019 adjusted prices < 10 kDKK (approx. €1300).  

```{r price-index}

# DST table (EJ66: Price index for sales property (2006=100) by region, category of real property and unit)
  id_table <- "EJ66"
  dat_meta <- get_table_metadata(table_id = id_table, variables_only = TRUE)
  
# Values to retrieve
  variables <- list(
    # Province Byen København: region = 01 
    list(code = "OMRÅDE", values = "01"),
    # Category of real property
    list(code = "EJENDOMSKATE", values = c("0111", "2103")),
    # Index
    list(code = "TAL", values = NA),
    # From 2004 to 2019
    list(code = "Tid", values = seq(2004, 2019, 1))
    )

# Get index
  price_index <- get_data("EJ66", variables) %>% 
    # Get index
    filter(TAL == "Index") %>% 
    # Translate into English 
    rename(region = OMRÅDE,
           category = EJENDOMSKATE,
           unit = TAL,
           date = TID, 
           index = INDHOLD) %>% 
    # Convert index tu numeric
    mutate(index = as.numeric(index)) %>% 
    # Remove region and unit columns
    select(-region, -unit) 
    
# Print price index table  
  price_index %>% 
    # Wide format
    pivot_wider(names_from = date, 
                values_from = index) %>% 
    kbl(caption = "Price index for sale properties in Copenhagen City") %>% 
    kable_paper() %>% 
    scroll_box(width = "100%")
  
```

```{r adj-price}

# Adjust housing prices
price_index_2019 <- filter(price_index, date == 2019) %>% rename(index_2019 = index)

res_units_oft <- res_units_oft %>% 
  # Column with price index categories
  mutate(category = case_when(
    type == "Single-family house" ~ "One-family houses",
    TRUE ~ "Owner-occupied flats, total")) %>%
  # Add price index by year and category
  left_join(price_index, by = c("category" = "category",
                                "BBR_year" = "date")) %>% 
  # Add price index in 2019 by category
  left_join(price_index_2019, by = c("category" = "category")) %>% 
  # Calculate prices 2019
  mutate(price2019_kDKK = (KONTANT_KOEBESUM * index_2019 / index) / 1000) %>% 
  # Remove prices < 10 kDKK
  filter(price2019_kDKK >= 10)
  
```

The housing price per square meter ($kDDK/m^2$) is calculated by dividing the 2019 adjusted prices by the dwelling size (*BEBO_ARL*).

```{r price-per-meter}

res_units_oft <- res_units_oft %>% 
  # Price per m2
  mutate(price2019_kDKK_m2 = price2019_kDKK / BEBO_ARL)

```

The total number of residential units used for the analysis is `r nrow(res_units_oft)` (Table \@ref(tab:tbl-runits-clean)).
```{r tbl-runits-clean, cache = TRUE, dependson = "runits-clean"}

# Table with Number of residential units
  res_units_oft %>%
    # Summarize by type or residency and year
    group_by(type, BBR_year) %>% 
    summarise(n = n()) %>% 
    ungroup() %>%
    # Arrange and add row with totals
    arrange(BBR_year, desc(n)) %>%
    # Pivot
    pivot_wider(names_from = BBR_year, values_from = n) %>% 
    adorn_totals("row") %>%
    kbl(caption = "Number of residential dwellings in the free trade by year") %>% 
    kable_paper() %>% 
    row_spec(4, bold = TRUE) %>% 
    scroll_box(width = "100%")

```

The summary descriptive statistics of the housing prices are:
```{r tbl-summary}

# Table theme
theme_gtsummary_compact()

# Create variable labels of the variables to be printed in the table
labelled::var_label(res_units_oft$price2019_kDKK)    <- "Adjusted prices (kDKK)"
labelled::var_label(res_units_oft$BEBO_ARL)          <- "Dwelling size (m2)"
labelled::var_label(res_units_oft$price2019_kDKK_m2) <- "Adjusted prices per square meter (kDKK/m2)"

# Summary table
res_units_oft %>% 
  # Select variables of interest
  select(type, price2019_kDKK,  BEBO_ARL, price2019_kDKK_m2) %>%
  # Summary values
  tbl_summary(by = type,
              type = all_continuous() ~ "continuous2",
              statistic = all_continuous() ~ c("{mean}",
                                               "{median}",
                                               "{p25} - {p75}", 
                                               "{min} - {max}"),
              missing = "no") %>% 
  add_overall() %>% 
  modify_spanning_header(c("stat_1", "stat_2", "stat_3") ~ "**House type**") %>% 
  modify_footnote(update = everything() ~ NA) %>% 
  bold_labels() 

```

<!--chapter:end:022_load_BBR.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# Population data 

Population data at parish level have been retrieved from [Statistics Denmark](https://www.dst.dk/en) using the R-package [danstat](https://cran.r-project.org/web/packages/danstat/index.html). We have created two auxiliary function for reading the data. `steps` loops by year for getting small pieces of information from the DST API and then putting all together in a data frame. In this sense, we overcome the limitation of the number of rows we can retrieve from the API (i.e. if we call a large dataset we get the error: *Error: API did not return text/csv*). Then, `rm_words` is used in the cleaning process for simplifying the description of some variables we would like to use as columns names. 

```{r aux-funct-DST}

# Loop by year for getting DST data 
  steps <- function(year){
    var_values <- list(id_region, id_ancestry, year)
    var_input <- purrr::map2(.x = var_codes,
                             .y = var_values,
                             .f = ~list(code = .x, values = .y))
    get_data(id_table, variables = var_input)
  }

# Remove punctuation, lowercase, stem, stopwords, and collapse strings
  rm_words <- function(x, stopwords) { x %>% 
      strsplit(" ", fixed = TRUE) %>% 
      lapply(tm::removePunctuation) %>% 
      lapply(tolower) %>% 
      lapply(SnowballC::wordStem) %>% 
      lapply(function(x) x[!x %in% stopwords]) %>% 
      vapply(function(x) paste(x , collapse = "_"), character(1))
  }

```

We have loaded the following tables:

- [KMSTA001: Population 1. January by parish, ancestry and National Church](https://www.statbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=KMSTA001&PLanguage=1&PXSId=0&wsid=cftree)

```{r load-KMSTA001, cache = TRUE, dependson = "adm-units"}

  id_table <- "KMSTA001"
  var_pop <- get_table_metadata(table_id = id_table, variables_only = TRUE)

# Codes for var_input
  var_codes <- c("SOGN", "HERKOMST", "Tid")

# Values for var_input
  # Region: parishes of the study area (i.e. cph_parish)
  id_region <- cph_parish$SOGNEKODE
  # Ancestry
  id_ancestry <- NA
  # Quarters
  id_year <- var_pop$values[[4]]$id   # Select all years
  
# Read data
  prsh_ances_dst <- id_year %>%
    future_map(steps) %>% 
    bind_rows()
  plan("default")

# Clean data 
  prsh_ances <- prsh_ances_dst %>% 
    # Translate column names into English
    rename(parish = SOGN,
           ancestry = HERKOMST,
           date = TID, 
           value = INDHOLD) %>% 
    # Get parish codes (first number of the string)
    mutate(prsh_id = stringr::str_extract(parish, "[[:alnum:]]*")) %>% 
    # Remove the code from the string (prsh)
    mutate(parish = sub("[[:alnum:]]* ", "", parish)) %>% 
    # Get municipality (info inside the parenthesis)
    mutate(prsh_muni = stringr::str_extract(parish, "(?<=\\().*(?=\\))"),
           prsh_muni = gsub(" Municipality", "", prsh_muni),
           # removes white space from start and end of string
           prsh_muni = stringr::str_trim(prsh_muni)) %>% 
    # Get parish name (outside parenthesis) 
    mutate(prsh_name = stringr::str_extract(parish, "(.*(?=\\())"),
           prsh_name = stringr::str_trim(prsh_name)) %>% 
    # Remove duplicate info and order columns 
    select(prsh_id, prsh_name, prsh_muni, date, ancestry, value) %>% 
    # Make shorter names in ancestry
    mutate(ancestry = case_when(
      ancestry == "Persons of Danish origin" ~ "pop_dan",
      ancestry == "Immigrants from western countries" ~ "pop_mi_wst",
      ancestry == "Immigrants from non-western countries" ~ "pop_mi_nwst",
      ancestry == "Descendants from western countries" ~ "pop_de_wst",
      ancestry == "Descendants from non-western countries" ~ "pop_de_nwst"), 
      ancestry = factor(ancestry)) %>% 
    # Pivot (one row for peach parish and year)
    pivot_wider(names_from = ancestry, values_from = value) %>% 
    # Merge immigrants and their descendants (i.e. foreigners) 
    mutate(pop_frgn_wst = pop_mi_wst + pop_de_wst, 
           pop_frgn_nwst = pop_mi_nwst + pop_de_nwst) %>% 
    select(-c(pop_mi_wst, pop_de_wst, pop_mi_nwst, pop_de_nwst)) %>% 
    # Add column with total population
    mutate(pop_total = select(., starts_with("pop_")) %>% rowSums())
  
```

- [KMSTA003: Summary vital statistics by parish and movements](https://www.statbank.dk/statbank5a/SelectVarVal/Define.asp?MainTable=KMSTA003&PLanguage=1&PXSId=0&wsid=cftree)

```{r load-KMSTA003, cache = TRUE, dependson = "adm-units"}

  id_table <- "KMSTA003"
  var_pop <- get_table_metadata(table_id = id_table, variables_only = TRUE)

# Codes for var_input
  var_codes <- c("SOGN", "KIRKEBEV", "Tid")

# Values for var_input
  # Region: all parish
  id_region <- cph_parish$SOGNEKODE
  # Ancestry
  id_movements <- NA
  # Quarters
  id_year <- var_pop$values[[3]]$id   # Select all years

# Read data
  plan(multisession)  
  prsh_stats_dst <- id_year %>%
    future_map(steps) %>% 
    bind_rows()
  plan("default")

# Clean data 
  prsh_stats <- prsh_stats_dst %>%
    # Translate column names into English
    rename(parish = SOGN,
           movements = KIRKEBEV,
           date = TID, 
           value = INDHOLD) %>% 
    # Get parish codes (first number of the string)
    mutate(prsh_id = stringr::str_extract(parish, "[[:alnum:]]*")) %>% 
    # Remove the code from the string (prsh)
    mutate(parish = sub("[[:alnum:]]* ", "", parish)) %>% 
    # Get municipality (info inside the parenthesis)
    mutate(prsh_muni = stringr::str_extract(parish, "(?<=\\().*(?=\\))"),
           prsh_muni = gsub(" Municipality", "", prsh_muni),
           # removes white space from start and end of string
           prsh_muni = stringr::str_trim(prsh_muni)) %>% 
    # Get parish name (outside parenthesis) 
    mutate(prsh_name = stringr::str_extract(parish, "(.*(?=\\())"),
           prsh_name = stringr::str_trim(prsh_name)) %>% 
    # remove duplicate info and order columns 
    select(prsh_id, prsh_name, prsh_muni, date, movements, value) %>% 
    # Clean arguments in movements (remove punctuation, stop-words, stem, and collapse)
    mutate(movements = rm_words(movements, c("in", "the", "of"))) %>%
    # Pivot (one row for each parish and year) 
    pivot_wider(names_from = movements, values_from = value)
  
```

One we have the data we merge both dataset and add the spatial information (note that there are only summary statistics from 2015): 
```{r merge-DST, cache = TRUE, dependson = "adm-units"}

# Merge both tables in one:
  prsh_pop <- prsh_ances %>%  
    full_join(prsh_stats) %>% 
    # remove rows with no summary data (summary data only from 2015 to 2020)
    filter(date >= 2015, date <= 2020)

# Add the spatial information:
  prsh_pop_sf <- cph_parish %>%
    rename(prsh_id = SOGNEKODE) %>% 
    select(prsh_id, prsh_area_km2) %>% 
    left_join(prsh_pop, by = c("prsh_id")) 

```

<!--chapter:end:023_load_pop_DST.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
#  CORINE land use 

Land use have been obtained from CORINE. We downloaded the shapefile from kortforsyningen and used the data from 2012 (*CLC12_DK.shp*).

```{r fig-land-use, cache=TRUE, fig.width = 9, fig.height = 7, fig.cap = "Land use (CORINE)"}

# Download CORINE to local repository (pks -  dangeo)
  dangeo_get_data(ftp_folder = "CORINE",
                  zip_name   = "DK_CORINE_SHP_UTM32-WGS84.zip")

# Create a table with the CORINE land use codes from the EEA
corine_code_link <- "https://www.eea.europa.eu/data-and-maps/data/corine-land-cover-2000-clc2000-250-m-version-9-2007/corine-land-cover-2000-classes-and-rgb-color-codes/clc2000legend.csv/at_download/file"

corine_code <- read_csv(corine_code_link) %>% 
  mutate_if(is.numeric, as.character)
  
# Load shapefile
  dangeo_set_param() # Get local directory
  corine_link <- paste(loc_dir, "DK_CORINE_SHP_UTM32-WGS84", "CLC12_DK.shp", sep = "/")
  dk_corine  <- read_sf(corine_link) %>%
    # Drop z dimension
    st_zm() %>% 
    # Transform coordinates
    st_transform(crs = "EPSG:25832") %>% 
    # Add code description
    left_join(corine_code, by = c("CODE_12" = "CLC_CODE")) 

# Select study area
  cph_corine <- st_intersection(dk_corine, study_area) %>% 
    select(CODE_12, LABEL1, LABEL2, LABEL3 , RGB) %>% 
    janitor::clean_names() %>% 
    separate(rgb, c("red", "green", "blue"), sep = "-") %>% 
    mutate(code_12 = as.numeric(code_12),
           hex_col = grDevices::rgb(red, green, blue, max = 255),
           hex_col = fct_reorder(hex_col, code_12),
           label3 = fct_reorder(label3, code_12)) %>% 
    st_sf()
  
# Plot
  ggplot() +
    geom_sf(data = cph_corine,
            aes(fill = label3),
            color = "grey50",
            size = 0.05) +
    #geom_sf(data = res_units, size = 0.02, shape = 16) +
    scale_fill_manual(name = "Land use",
                      values = levels(cph_corine$hex_col),
                      drop = TRUE) +
    my_theme_map() +
    labs(x = "",
         y = "") +
    annotation_scale(location = "br", text_cex = 1) +
    annotation_north_arrow(location = "br",
                           pad_x = unit(1.50, "cm"),
                           pad_y = unit(0.65, "cm"),
                           which_north = "true",
                           height = unit(0.5, "cm"),
                           width = unit(0.5, "cm"),
                           style = north_arrow_orienteering(text_col = "white",
                                                            text_size = 1))

```

<!--chapter:end:024_load_CORINE.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# Railway transport network

Downloaded from  kortforsyningen (i.e. Inspire_railway-transport-network). 

```{r dwn-rail}

dangeo_get_data(
  ftp_folder = "grundlaeggende_landkortdata/inspire_railway-transport-network",
  zip_name   = "DK_RailwayTransportNetwork_GML_UTM32-EUREF89.zip")

```

<!--chapter:end:025_load_railway_net.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# Open Street Map 

We get location information from [Open Street Map](https://wiki.openstreetmap.org/wiki/Map_features). We select services inside a buffer of approx. 2 km around the study area (Figure \@ref(fig:loc-box)), assuming that people may use then (e.g. parks, parking areas) outside Copenhagen City but they are close enough to they houses. 

```{r loc-box, cache=TRUE}

# Area for OSM data: Copenhagen
CPH_osm_bb <- getbb("Copenhagen")

# Bounding of the study area (approx. buffer of 2km)
box <- c(xmin = 714906,
         xmax = 733618,
         ymin = 6166579,
         ymax = 6184092)
bbox <- st_bbox(box)

bbox_sf <- st_as_sfc(bbox) %>% 
  st_set_crs("EPSG:25832") 

```

## Parking areas

Parking areas are tagged as `key = amenity` and `value = parking` (Figure \@ref(fig:osm-parking)). 
```{r osm-parking, fig.cap="Parking areas"}

# Get car packs from OSM
parking_osm <- CPH_osm_bb %>%
  opq() %>%
  add_osm_feature(key = "amenity", value = c("parking")) %>%
  osmdata_sf() 

# Clean dataset
parking <- parking_osm$osm_polygons %>%
  # Transform CRS
  st_transform(crs = "EPSG:25832") %>% 
  select(osm_id, amenity) %>% 
  # Calculate the area of the polygons
  mutate(area_m2 = as.numeric(units::set_units(st_area(.), m^2))) %>% 
  # Crop to area of influence
  st_crop(bbox_sf)

# Plot
ggplot() +
  geom_sf(data = st_crop(dk_country, bbox_sf),
          fill = "grey95") +
  geom_sf(data = cph_parish,
          fill = "grey85",
          color = "grey50",
          size = 0.05) +
  geom_sf(data = parking, fill = "#D55E00", col = NA) +
  my_theme_map() +
  labs(caption = "Source: Open Street Map")

```

Potential model
```{r set-pot-model-parking, cache=TRUE, dependson="loc-box"}

# Based on: https://riatelab.github.io/potential/articles/potential.html

# Points to estimate the potential 
grids100m_cent <- st_centroid(grids100m)

# Calculate centroid of the parking area
parking_cent <- st_centroid(parking)

# Distance matrix
d <- create_matrix(x = parking_cent, y = grids100m_cent)

```

Spatial interaction function (Figure \@ref(fig:spat-inter-parking)).
```{r spat-inter-parking, fig.cap="Spatial interaction function"}

span <- 300
beta <- 2
plot_inter(fun = "e",
           span = span,
           beta = beta)

```

Calculate the potential (Figure \@ref(fig:pot-model-parking)).
```{r pot-model-parking, fig.cap="Potential of parking areas"}

# Calculate the potential
grids100m_cent$pot <- potential(x = parking_cent,
                                y = grids100m_cent,
                                d = d,
                                var = "area_m2",
                                fun = "e",
                                span = span,
                                beta = beta)

# Potential relatively to its maximum
grids100m_cent$pot_perc <- 100 * grids100m_cent$pot / max(grids100m_cent$pot)

# Add info to grids100m
grids100m_cent <- grids100m_cent %>%
  as_tibble() %>%
  select(-geometry, int)

parking_pot <- grids100m %>% 
  as_tibble() %>% 
  left_join(grids100m_cent, by = "grid_ID") %>% 
  st_sf()

# Plot
ggplot() +
  geom_sf(data = parking_pot, aes(fill = pot_perc), col = NA) +
  scale_fill_viridis_c(name = "Perc [%]", option = "plasma") +
  geom_sf(data = cph_parish, fill = NA, color = "grey50", size = 0.05) +
  my_theme_map() 

```

## Parks

"A park is an area of open space for recreational use, usually designed and in semi-natural state with grassy areas, trees and bushes - OMS"  (Figure \@ref(fig:green-areas-osm)).
```{r green-areas-osm, fig.cap="Green areas"}

# Green areas 
  CPH_parks <- CPH_osm_bb %>%
    opq() %>%
    add_osm_feature(key = "leisure", value = c("park",
                                               "common",
                                               "garden",
                                               "firepit",
                                               "nature_reserve")) %>%
    osmdata_sf() 
  
# Clean
  parks <- select(CPH_parks$osm_polygons, osm_id, name) %>% 
    # Transform CRS
    st_transform(crs = "EPSG:25832") %>% 
    # Encoding names (Danish)
    mutate(name = iconv(name, "UTF-8")) %>% 
    # Calculate the area of the polygons
    mutate(area_m2 = as.numeric(units::set_units(st_area(.), m^2))) %>% 
    # Crop to area of influence
    st_crop(bbox_sf) 
    
# Plot
ggplot() +
  geom_sf(data =st_crop(dk_country, bbox_sf),
           fill = "grey95") +
  geom_sf(data = cph_parish,
          fill = "grey85",
          color = "grey50",
          size = 0.05) +
  geom_sf(data = parks,
          colour = NA,
          fill = "palegreen3",
          alpha = .3) +
  my_theme_map()
  
```

Potential model
```{r set-pot-model-parks, cache=TRUE, dependson="loc-box"}

# Points to estimate the potential 
grids100m_cent <- st_centroid(grids100m)

# Calculate centroid of the parking area
parks_cent <- st_centroid(parks)

# Distance matrix
d <- create_matrix(x = parks_cent, y = grids100m_cent)

```

Spatial interaction function (Figure \@ref(fig:spat-inter-parks)).
```{r spat-inter-parks, fig.cap="Spatial interaction function"}

span <- 300
beta <- 2
plot_inter(fun = "e",
           span = span,
           beta = beta)

```

Calculate the potential (Figure \@ref(fig:pot-model-parks)).
```{r pot-model-parks, fig.cap="Potential of parking areas"}

# Calculate the potential
grids100m_cent$pot <- potential(x = parks_cent,
                                y = grids100m_cent,
                                d = d,
                                var = "area_m2",
                                fun = "e",
                                span = span,
                                beta = beta)

# Potential relatively to its maximum
grids100m_cent$pot_perc <- 100 * grids100m_cent$pot / max(grids100m_cent$pot)

# Add info to grids100m
grids100m_cent <- grids100m_cent %>%
  as_tibble() %>%
  select(-geometry, int)

parks_pot <- grids100m %>% 
  as_tibble() %>% 
  left_join(grids100m_cent, by = "grid_ID") %>% 
  st_sf()

# Plot
ggplot() +
  geom_sf(data = parks_pot, aes(fill = pot_perc), col = NA) +
  scale_fill_viridis_c(name = "Perc [%]", option = "plasma") +
  geom_sf(data = cph_parish, fill = NA, color = "grey50", size = 0.05) +
  my_theme_map() 

```

# Forest

```{r}

CPH_forest <- CPH_osm_bb %>%
    opq() %>%
    add_osm_feature(key = "landuse", value = c("meadow", "allotments", "forest")) %>%
    osmdata_sf() 
  
  CPH_scrub <- CPH_osm_bb %>%
    opq() %>% 
    add_osm_feature(key = "natural", value = "scrub") %>% 
    osmdata_sf() 
  
  # Land_use: recreation_ground
  
```


<!--chapter:end:026_load_OSM.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# (PART) Data analysis {-}

# Population density {#Population}

BBR data represent the situation at the begining of the given year. Therefore, when we link the BBR data with the population data, which also represent the situation at the first day of the year, we use the population of the same year (e.g. BBR data from 2019 and population data from 2019).

## Choropleth by ancestry

Plot population density at the last day of 2019 (first of 2010) by parish and ancestry.
```{r fig-pop-chor, fig.width = 9, fig.height = 7, fig.cap = "Population density at the first day of 2019 by parishes (choropleth)"}

  col <- brewer.pal(9, "YlGnBu")
  pal <- colorRampPalette(col)
  my_pallette <- pal(10)
  
  pop_dens_choropleth <-  prsh_pop_sf %>% 
    select(prsh_id, prsh_name, prsh_area_km2, date, 
           pop_total, pop_dan, pop_frgn_wst, pop_frgn_nwst) %>% 
    filter(date == 2019) %>%
    # Calulate population density (pop/area)
    mutate(across(starts_with("pop_"), ~ . / (1000 * prsh_area_km2))) %>% 
    rename_with(~paste(.x, "km2", sep = "_"), starts_with("pop")) %>% 
    as_tibble() %>% 
    pivot_longer(starts_with("pop_")) %>% 
    st_as_sf() %>% 
    mutate(name = factor(name, 
                         levels = c("pop_total_km2", 
                                    "pop_dan_km2",
                                    "pop_frgn_wst_km2",
                                    "pop_frgn_nwst_km2"),
                         labels = c("Total",
                                    "Danish origin",
                                    "Immigrants and their descendants from western countries",
                                    "Immigrants and their descendants from non-western countries")))
  
  brks_c <- c(min(pop_dens_choropleth$value),
              1, 2, 4, 8, 12, 16, 20, 25, 30,
              ceiling(max(pop_dens_choropleth$value)))
  
  pop_dens_choropleth  %>% 
    ggplot() +
    geom_sf(aes(fill = cut(value, breaks = brks_c, include.lowest = T)),
            color = "grey50",
            size = 0.05) +
    scale_fill_manual(name = TeX("$\\overset{\\textbf{Population}}{(x1000/km^2)}$"),
                      values = my_pallette,
                      drop = FALSE,
                      guide = guide_legend(reverse=TRUE))  +
    my_theme_map() + 
    theme(plot.title = element_text(size = 12, colour = "darkblue", face = "bold"),
          strip.text = element_text(size = 9, color = "black", face = "italic")) +
    labs(x = "",
         y = "") +
    facet_wrap( ~ name)

```

## Disaggregating population data

We disaggregate the population data at Parish level to grid cells of 100m x 100m using residential buildings as ancillary data. The procedure is as follow: 

1. We calculate the occupancy rate (*OR*) for the residential units of each parish (*j*): $$OR_{j} = \frac{pop_{j}}{N_{j}}$$

1. We make grid cells of 100m x 100m over the study area

1. We select only the grids with residential units 

1. Detect to what parish (*j*) belong each grid (*i*). (Note that one grids may be in more that one parish)

1. Calculate the number of dwellings per grid and parish ($N_{ij}$)

1. Estimate the population in each grid (*i*) base the occupancy rate by parish (*j*): $$pop_{gi} = \sum_{j = 1}^{n}(OR_{j} \cdot N_{ij})$$

1. Population density: $$PD_{i} = \frac{pop_{i}}{A_{i}}$$

Therefore we create the following function:
```{r aux-funct-pop-den}

#' Calculate the population density in the grids created by f_grids 
#' @param .pop        POLYGONS with the population data (i.e. prsh_pop_sf)
#' @param .parish     POLYGONS where the number of units will be calculated 
#' @param .res_points POINTS with the residential units (e.g. res_units) 
#' @param .grids      Grid cells generated by f_grids
#' @param .year       Year of the analysis

  f_pd_grids <- function(.pop, .parish, .res_points, .grids, .year) {
    
    # Population at the last day of the year (.year)
    pop_year <- .pop %>%
      # Select population data at the first day of the quarter 
      select(prsh_id, prsh_name, prsh_area_km2, date, 
             pop_total, pop_dan, pop_frgn_wst, pop_frgn_nwst) %>% 
      # select the data at the end of the year (first dat of the next year) 
      filter(date == (.year))
    
    # BBR of the selected year (represent the last day of the year)
    BBR_year <- filter(.res_points, BBR_year == .year) 
    
    # Calculate occupancy rate ("OR") of the residential units in each parish in a year
    OR <- pop_year %>%  
      # number of units per parish
      mutate(n_units = st_intersects(., BBR_year, dist = 10) %>%
               map(., ~length(.)) %>%
               unlist()) %>% 
      # mean population per unit in each parish
      mutate(across(starts_with("pop"), ~ . / n_units)) %>% 
      rename_with(~paste(.x, "or", sep = "_"), starts_with("pop")) %>% 
      # output as table 
      as_tibble() %>% 
      select(-n_units, -geometry)
    
    # Get only the grids with residential units on them
    gru <- .grids %>% 
      # Number of residential units per grid
      mutate(n_units = st_intersects(., BBR_year , dist = 10) %>%
               map(., ~length(.)) %>%
               unlist()) %>% 
      # Get grids with residential buildings
      filter(n_units > 0) %>%
      # Detect to what parish belong the grid
      st_intersection(., .parish ) %>% 
      # Remove parish area
      select(-prsh_area_km2, -SOGNENAVN) %>% 
      # convert to table
      as_tibble()
  
    # Population density by grids
    gru %>% 
      # Merge OR per parish  
      left_join(OR, by = c("SOGNEKODE" = "prsh_id")) %>% 
      st_sf() %>% 
      # recalculate population by grid 
      mutate(across(starts_with("pop"), ~ . * n_units)) %>% 
      rename_with(~gsub("_or", "", .), .col = starts_with("pop")) %>% 
      # sum population of each parish of the grid
      group_by(grid_ID) %>% 
      summarise(pop_total = sum(pop_total),
                pop_dan = sum(pop_dan),
                pop_frgn_wst = sum(pop_frgn_wst),
                pop_frgn_nwst = sum(pop_frgn_nwst),
                n_units = sum(n_units)) %>% 
      ungroup() %>% 
      # Area of the grid
      mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %>% 
      # Population density (pop/area)
      mutate(across(starts_with("pop_"), ~ . / (1000 * area_km2))) %>% 
      rename_with(~paste(.x, "km2", sep = "_"), starts_with("pop")) %>% 
      # Pivot longer
      as_tibble() %>% 
      pivot_longer(starts_with("pop_")) %>% 
      st_as_sf() %>% 
      # Remove polygons with 0 population
      filter(value > 0)
  }

```

Population in 2019 (at the first dat of the year) by grid cells of 100m x 100m and ancestry.
```{r fig-pop-map-grid, fig.width = 9, fig.height = 7, cache = TRUE, dependson = "grids-100m", fig.cap = "Population density at the first day of 2019 by grid cells of 100m x 100m"}

  pop_2019_g100m <-  f_pd_grids(.pop = prsh_pop_sf,
                                .parish = cph_parish,
                                .res_points = res_units,
                                .grids = grids100m,
                                .year = 2019)

  brks <- c(min(pop_2019_g100m$value),
            1, 2, 4, 8, 12, 16, 20, 25, 30,
            ceiling(max(pop_2019_g100m$value)))
  
  pop_2019_g100m %>%
    mutate(name = factor(name, 
                         levels = c("pop_total_km2", 
                                    "pop_dan_km2",
                                    "pop_frgn_wst_km2",
                                    "pop_frgn_nwst_km2"),
                         labels = c("Total",
                                    "Danish origin",
                                    "Immigrants and their descendants from western countries",
                                    "Immigrants and their descendants from non-western countries"))) %>% 
    ggplot() +
    geom_sf(data = cph_parish, fill = "grey", color = "grey50", size = 0.05) +
    geom_sf(aes(fill = cut(value,
                           breaks = brks,
                           include.lowest = T)),
            color = NA) +
    scale_fill_manual(name = TeX("$\\overset{\\textbf{Population}}{(x1000/km^2)}$"),
                      values = my_pallette,
                      drop = FALSE,
                      guide = guide_legend(reverse = TRUE))  +
    my_theme_map() + 
    theme(plot.title = element_text(size = 12, colour = "darkblue", face = "bold"),
          strip.text = element_text(size = 9, color = "black", face = "italic")) +
    labs(x = "",
         y = "") +
    facet_wrap( ~ name)
  
```

## Population density WorldPop    

We can compare our results with the WorldPop total population estimation per grid-cell of 3 arc (approx. gri cells of 100m x 100m):
```{r fig-pop-den-worldpop, fig.width = 9, fig.height = 7, cache=TRUE, dependson = "adm-units", fig.cap = "WorldPop total population density estimations in 2019"}

  dnk_ppp_2019_link <- "https://data.worldpop.org/GIS/Population/Global_2000_2020/2019/DNK/dnk_ppp_2019.tif"
  
# Download data into the local repository (i.e. loc_dir)
  download.file(url = dnk_ppp_2019_link,
                destfile = paste(loc_dir, "dnk_ppp_2019.tif", sep = "/"),
                method = "curl")

# Load file 
  dnk_ppp_2019 <- read_stars(.x = paste(loc_dir, "dnk_ppp_2019.tif", sep = "/"),
                             proxy = TRUE) 
  
# Crop study area
  bbox <-  study_area %>% st_transform(crs = st_crs(dnk_ppp_2019))
  cph_ppp_2019 <- st_crop(dnk_ppp_2019, bbox) %>%
    st_transform(crs = "EPSG:25832")

# Plot
  col <- brewer.pal(9, "YlGnBu")
  pal <- colorRampPalette(col)
  my_pallette <- pal(10)
  brks <- c(min(cph_ppp_2019$dnk_ppp_2019.tif, na.rm = TRUE),
            1, 2, 4, 8, 12, 16, 20, 25, 30,
            max(cph_ppp_2019$dnk_ppp_2019.tif, na.rm = TRUE))
  
  cph_ppp_2019 <- cph_ppp_2019 %>% 
    mutate( pop_cuts = cut(dnk_ppp_2019.tif, breaks = brks, include.lowest = T))  
  
  ggplot() + 
    geom_sf(data = cph_parish, fill = "grey", color = "grey50", size = 0.05) +
    geom_stars(data = cph_ppp_2019, aes(fill = pop_cuts)) +
    scale_fill_manual(name = TeX("$\\overset{\\textbf{Population}}{(x1000/km^2)}$"),
                      values = my_pallette,
                      drop = FALSE,
                      guide = guide_legend(reverse=TRUE)) +
    labs(title = "Estimated total number of people per grid-cell of 3 arc",
         caption = "Source: WorlpPop (https://data.worldpop.org)") +
    my_theme_map()
  
```

<!--chapter:end:031_pop_density.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
# Residential units saled as free scale

We focused our study in residential dwellings on the ordinary free trade (Table \@ref(tab:tbl-runits-clean)). 

NOTES: 

- There are large differences in the number of residential units between years, why??
- Study only one year for the moment (e.g. 2019)??
- Housing prices in different years -> adjust to 2019 prices (what index; Table \@ref(tab:price-index))?
- **KONTANT_KOEBESUM** = cash purchase price? Analyse it?? What about **KOEBESUM_BELOEB** = The purchase price agreed upon the sale of the property???
- **KONTANT_KOEBESUM** = 0 or (< 100000 DKK)? 
- **SKOEDE_DATO** = "The date on which the deed was signed" -> use as sale date?? Should we use this date (i.e. for the price index)? ...   
 - What about housing prices = 0?
 - Dwelling Area <= 0? 
 
```{r}

res_units_oft %>% 
  ggplot(aes(sample = log10(price2019_kDKK),  colour = factor(BBR_year))) +
  geom_qq() +
  #geom_qq_line() +
  facet_grid(~type) +
  theme_bw()

```


## Residential units by floor level

- KL - basement
- ST - ground floor
- 1  - 1st floor
- 2  - 2nd floor
- 3  - 3rd floor
- 4  - 4th floor
- 5 or more = etc.

```{r fig-runits-floor, fig.cap = "Residential units distribution by floor level"}

  res_units_oft %>% 
    group_by(floor_level, type) %>% 
    summarise(n = n()) %>%
    ungroup() %>% 
    # in percentage [%]   
    mutate(perc = 100 * n / sum(n)) %>% 
    # Reorder type levels for plotting multi-storey first
    mutate(type = factor(type)) %>%
    ggplot() +
    geom_bar(aes(y = floor_level, x = perc, fill = type), stat = "identity") +
    labs(y = "", 
         x = "Percentage [%]") +
    theme_bw() +
    theme(legend.position = "bottom",
          legend.title = element_blank()) +
    guides(fill = guide_legend(ncol = 2)) +
    scale_x_continuous(labels = scales::comma) +
    scale_fill_manual(values = c("#0072B2", "#D55E00", "#CC79A7"))
  
```



<!--chapter:end:032_EDA.Rmd-->

```{r include=FALSE, cache=FALSE}
set.seed(1014)

knitr::opts_chunk$set(
  comment = "#",
  cache = TRUE, 
  cache.lazy = FALSE,
  warning = FALSE,
  message = FALSE,
  include = TRUE,
  echo = TRUE,
  fig.align = 'center',
  fig.pos = "H")

options(knitr.kable.NA = "-")
options(digits = 3)

# Create our own theme for plotting maps in ggplot2.
my_theme_map <- function() {
  theme_void() +
    theme(
      # Title and captions
      plot.title = element_text(size = 14, colour = "darkblue", face = "bold"),
      plot.caption = element_text(size = 10, colour = "grey25"),
      # Legend
      legend.title = element_text(size = 10, face = "bold"),
      legend.text = element_text(size = 10),
      # Facets
      strip.text = element_text(size = 12, color = "black", face = "italic")
    )
}

# Set local repository for downloading data (i.e. kortforsyningen)
dangeo::dangeo_set_param()

  
```
`r if (knitr::is_html_output()) '# References {-}'`

<!--chapter:end:999_references.Rmd-->

