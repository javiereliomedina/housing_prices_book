# Population density {#pop-DST}

Population data at municipality level for the same period we have BBR data (2004-2019) have been retrieved from [Statistics Denmark](https://www.dst.dk/en). We have used the R-package [danstat](https://cran.r-project.org/web/packages/danstat/index.html) and the table [FT: Population figures from the censuses](https://www.statbank.dk/statbank5a/SelectVarVal/Define.asp?Maintable=FT&PLanguage=1).

```{r}

id_table <- "FT"
dat_meta <- get_table_metadata(table_id = id_table, variables_only = TRUE)

# Variables
  variables <- list(
    # Municipalities
    list(code = "HOVEDDELE", values = c("101","147")),
    # Population at the first day of the year (from 2004 to 2019)
    list(code = "Tid", values = seq(2004, 2019, 1))
    )

# Get data 
  pop_tot_muni <- get_data("FT", variables) %>%
    # Translate names into English 
    rename(muni_name = HOVEDDELE,
           date = TID, 
           pop_total = INDHOLD) 

# Add spatial information
   pop_tot_muni_sf <- cph_commune %>% 
    left_join(pop_tot_muni, by = "muni_name")
   
```

We disaggregate the population data to grid cells of 100m x 100m using residential buildings as ancillary data. The procedure is as follow: 

1. Calculate the occupancy rate (*OR*) for the residential units of each municipality (*j*): $$OR_{j} = \frac{pop_{j}}{N_{j}}$$

1. Make grid cells of 100m x 100m over the study area, and select only the grids with residential units 

1. Detect to what municipality (*j*) belong each grid (*i*) (Note that one grids may be in more that one municipality)

1. Calculate the number of dwellings per grid and municipality ($N_{ij}$)

1. Estimate the population in each grid (*i*) base the occupancy rate by parish (*j*): $$pop_{gi} = \sum_{j = 1}^{n}(OR_{j} \cdot N_{ij})$$

1. Population density: $$PD_{i} = \frac{pop_{i}}{A_{i}}$$



We can therefore estimate the population density at the first day of the year by grid cells of 100m x 100m (figure \@ref(fig:fig-pop-density)).

```{r fig-pop-density-aux-function}

#' Aux. function for calculate the population density in the grids created by f_grids 
#' @param .year       Year of the analysis (e.g. 2019)

f_pd_grids <- function(.year) {

  # Population at the first day of the year (.year) in each municipality
  pop_year <- pop_tot_muni_sf %>%
    # select the data at the first day of the year 
    filter(date == .year)  
  
  # BBR of the selected year (represent the first day of the year)
  BBR_year <- res_units %>% 
    filter(BBR_year == .year) %>% 
    select(geometry)
  
  # Calculate occupancy rate ("OR") of the residential units in each municipality in a year
  OR <- pop_year %>%  
    # number of units per parish
    mutate(n_units = st_intersects(., BBR_year) %>%
             map(., ~length(.)) %>%
             unlist()) %>% 
    # mean population per unit in each parish
    mutate(across(starts_with("pop"), ~ . / n_units)) %>% 
    # output as table 
    as_tibble() %>% 
    select(-n_units, -geometry)
  
  # Get only the grids with residential units on them
  gru <- grids100m$data_poly[[1]] %>% 
    # Number of residential units per grid
    mutate(n_units = st_intersects(., BBR_year) %>%
             map(., ~length(.)) %>%
             unlist()) %>% 
    # Get grids with residential buildings
    filter(n_units > 0) %>% 
    # Add date
    mutate(date = .year)
  
  # Detect to what area belong the grid
  gru_muni <- gru %>% 
    st_intersection(., cph_commune) %>% 
    # Remove parish area
    select(-muni_area_km2, -muni_name) 
  
  # Population density by grids
  pop_grids <- gru_muni %>% 
    # convert to table
    as_tibble() %>% 
    select(-geometry) %>% 
    # Merge OR per area  
    left_join(OR, by = "muni_id") %>% 
    # recalculate population by grid 
    mutate(across(starts_with("pop"), ~ . * n_units)) %>% 
    # sum population of each municipality of the grid
    group_by(grid_ID) %>% 
    summarise(pop_total = sum(pop_total),
              n_units = sum(n_units)) %>% 
    ungroup() 
  
  # Add spatial information
  gru %>% 
    select(-n_units) %>% 
    left_join(pop_grids, by = "grid_ID") %>% 
    # Area of the grid
    mutate(area_km2 = as.numeric(units::set_units(st_area(.), km^2))) %>% 
    # Population density (pop/area)
    mutate(across(starts_with("pop_"), ~ . / (1000 * area_km2))) %>% 
    rename_with(~paste(.x, "km2", sep = "_"), starts_with("pop")) %>% 
    # Remove polygons with 0 population
    filter(pop_total_km2 > 0)
  
}

```

```{r pop-density-estimates}

# List of years with BBR data (2004-2019) and population data (2008-2019)
years_pd <- seq(2004, 2019, 1) 

# Increase future maximum allowed size of global variables
options(future.globals.maxSize = 8000 * 1024^2)

# Population density 
plan(multisession, workers = 7)
pop_g100m <- future_map_dfr(.x = years_pd, .f = f_pd_grids) 
plan("default")

# Default value
options(future.globals.maxSize = 500 * 1024^2)

```

```{r fig-pop-density, animation.hook="gifski", fig.cap = "Dasymetric map"}

# Add breaks
brks <- c(min(pop_g100m$pop_total_km2),
          1, 2, 3, 4, 5, 10, 15, 20, 30,
          ceiling(max(pop_g100m$pop_total_km2)))

pop_g100m <- pop_g100m %>%
  mutate(pop_total_km2_cut = cut(pop_total_km2,
                         breaks = brks,
                         include.lowest = TRUE))  

# Aux. function for plotting
f_plot <- function(df) {
  ggplot() +
    geom_sf(data = study_area, fill = "grey") +
    geom_sf(data = df, 
            aes(fill = pop_total_km2_cut,
                group = interaction(pop_total_km2_cut, date)),
            color = NA) +
    geom_sf(data = cph_commune, fill = NA, color = "grey50", size = 0.1) +
    scale_fill_brewer(
      name = TeX("$\\overset{\\textbf{Population}}{(x1000/km^2)}$"),
      palette = "RdYlBu",
      direction = -1,
      drop = FALSE)  +
    my_theme_map() +
    labs(x = "",
         y = "",
         title = "Population density by grid cells of 100m x 100m",
         subtitle = paste("Date", df$date, sep = ": "))
}

# Plot each year
plan(multisession, workers = 7)
plts <- pop_g100m %>% 
  group_split(date) %>%  
  future_map(., .f = f_plot, .options = furrr_options(seed = 123))
plan("default")

# Animation
for(i in seq_along(years_pd)) { print(plts[[i]]) }

```

